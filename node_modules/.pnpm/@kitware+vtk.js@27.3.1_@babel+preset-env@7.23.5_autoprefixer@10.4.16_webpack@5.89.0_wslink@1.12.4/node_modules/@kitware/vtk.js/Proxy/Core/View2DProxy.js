import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';
import vtkMouseRangeManipulator from '../../Interaction/Manipulators/MouseRangeManipulator.js';
import vtkViewProxy from './ViewProxy.js';
import { j as cross, E as getMajorAxisIndex } from '../../Common/Core/Math/index.js';
import { mat4, vec3 } from 'gl-matrix';
import vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';

var DEFAULT_STEP_WIDTH = 512;

function formatAnnotationValue(value) {
  if (Array.isArray(value)) {
    return value.map(formatAnnotationValue).join(', ');
  }

  if (Number.isInteger(value)) {
    return value;
  }

  if (Number.isFinite(value)) {
    if (Math.abs(value) < 0.01) {
      return '0';
    }

    return value.toFixed(2);
  }

  return value;
}
/**
 * Returns an array of points in world coordinates creating a coarse hull
 * around the prop given in argument
 * The returned array is empty if the prop is not visible or doesn't use bounds
 *
 * How it works: if possible, combine the mapper bounds corners with the prop matrix
 * otherwise, returns the prop bounds corners
 */


function getPropCoarseHull(prop) {
  var _prop$getMapper, _mapper$getBounds;

  if (!prop.getVisibility() || !prop.getUseBounds()) {
    return [];
  }

  var finestBounds = prop.getBounds();
  var finestMatrix = null; // Better bounds using mapper bounds and prop matrix

  var mapper = prop === null || prop === void 0 ? void 0 : (_prop$getMapper = prop.getMapper) === null || _prop$getMapper === void 0 ? void 0 : _prop$getMapper.call(prop);
  var mapperBounds = mapper === null || mapper === void 0 ? void 0 : (_mapper$getBounds = mapper.getBounds) === null || _mapper$getBounds === void 0 ? void 0 : _mapper$getBounds.call(mapper);

  if (mapperBounds && vtkBoundingBox.isValid(mapperBounds) && prop.getMatrix) {
    var _mapper$getInputData;

    finestBounds = mapperBounds;
    finestMatrix = prop.getMatrix().slice();
    mat4.transpose(finestMatrix, finestMatrix); // Better bounds using the image data matrix and prop matrix + imageData matrix

    if (mapper.isA('vtkImageMapper') && (_mapper$getInputData = mapper.getInputData()) !== null && _mapper$getInputData !== void 0 && _mapper$getInputData.isA('vtkImageData')) {
      prop.computeMatrix();
      var imageData = mapper.getInputData();
      finestBounds = imageData.getSpatialExtent();
      var imageDataMatrix = imageData.getIndexToWorld();
      mat4.mul(finestMatrix, finestMatrix, imageDataMatrix);
    }
  } // Compute corners and transform them if needed
  // It gives a more accurate hull than computing the corners of a transformed bounding box


  var corners = [];
  vtkBoundingBox.getCorners(finestBounds, corners);

  if (finestMatrix) {
    corners.forEach(function (pt) {
      return vec3.transformMat4(pt, pt, finestMatrix);
    });
  }

  return corners;
} // ----------------------------------------------------------------------------
// vtkView2DProxy methods
// ----------------------------------------------------------------------------


function vtkView2DProxy(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkView2DProxy');

  publicAPI.updateWidthHeightAnnotation = function () {
    var _model$cornerAnnotati = model.cornerAnnotation.getMetadata(),
        ijkOrientation = _model$cornerAnnotati.ijkOrientation,
        dimensions = _model$cornerAnnotati.dimensions;

    if (ijkOrientation && dimensions) {
      var realDimensions = dimensions;

      if (dimensions.length > 3) {
        // the dimensions is a string
        realDimensions = dimensions.split(',').map(Number);
      }

      var dop = model.camera.getDirectionOfProjection();
      var viewUp = model.camera.getViewUp();
      var viewRight = [0, 0, 0];
      cross(dop, viewUp, viewRight);
      var wIdx = getMajorAxisIndex(viewRight);
      var hIdx = getMajorAxisIndex(viewUp);
      var sliceWidth = realDimensions['IJK'.indexOf(ijkOrientation[wIdx])];
      var sliceHeight = realDimensions['IJK'.indexOf(ijkOrientation[hIdx])];
      publicAPI.updateCornerAnnotation({
        sliceWidth: sliceWidth,
        sliceHeight: sliceHeight
      });
    }
  };

  var superUpdateOrientation = publicAPI.updateOrientation;

  publicAPI.updateOrientation = function (axisIndex, orientation, viewUp) {
    var promise = superUpdateOrientation(axisIndex, orientation, viewUp);
    var count = model.representations.length;

    while (count--) {
      var rep = model.representations[count];
      var slicingMode = 'XYZ'[axisIndex];

      if (rep.setSlicingMode) {
        rep.setSlicingMode(slicingMode);
      }
    }

    publicAPI.updateCornerAnnotation({
      axis: 'XYZ'[axisIndex]
    });
    return promise;
  };

  var superAddRepresentation = publicAPI.addRepresentation;

  publicAPI.addRepresentation = function (rep) {
    superAddRepresentation(rep);

    if (rep.setSlicingMode) {
      rep.setSlicingMode('XYZ'[model.axis]);
      publicAPI.bindRepresentationToManipulator(rep);
    }
  };

  var superRemoveRepresentation = publicAPI.removeRepresentation;

  publicAPI.removeRepresentation = function (rep) {
    superRemoveRepresentation(rep);

    if (rep === model.sliceRepresentation) {
      publicAPI.bindRepresentationToManipulator(null);
      var count = model.representations.length;

      while (count--) {
        if (publicAPI.bindRepresentationToManipulator(model.representations[count])) {
          count = 0;
        }
      }
    }
  };

  var superInternalResetCamera = model._resetCamera;
  /**
   * If fitProps is true, calling resetCamera will exactly fit the bounds in the view
   * Exact fitting requires useParallelRendering, and an active camera
   * Otherwise, the default renderer.resetCamera is used and it uses a larger bounding box
   */

  model._resetCamera = function () {
    var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    // Always reset camera first to set physicalScale, physicalTranslation and trigger events
    var initialReset = superInternalResetCamera(bounds);

    if (!model.fitProps || !model.useParallelRendering || !initialReset) {
      return initialReset;
    } // For each visible prop get the smallest possible convex hull using bounds corners


    var visiblePoints = [];

    if (bounds) {
      // Bounds are given as argument, use their corners
      vtkBoundingBox.getCorners(bounds, visiblePoints);
    } else {
      publicAPI.getRepresentations().forEach(function (representationProxy) {
        return [representationProxy.getActors(), representationProxy.getVolumes()].flat().forEach(function (prop) {
          return visiblePoints.push.apply(visiblePoints, _toConsumableArray(getPropCoarseHull(prop)));
        });
      });
    } // Get the bounds in view coordinates


    var viewBounds = vtkBoundingBox.reset([]);
    var viewMatrix = model.camera.getViewMatrix();
    mat4.transpose(viewMatrix, viewMatrix);

    for (var i = 0; i < visiblePoints.length; ++i) {
      var point = visiblePoints[i];
      vec3.transformMat4(point, point, viewMatrix);
      vtkBoundingBox.addPoint.apply(vtkBoundingBox, [viewBounds].concat(_toConsumableArray(point)));
    } // Compute focal point and position


    var viewFocalPoint = vtkBoundingBox.getCenter(viewBounds); // Camera position in view coordinates is the center of the bounds in XY
    // and the maximum bound + 1 in Z

    var viewPosition = [viewFocalPoint[0], viewFocalPoint[1], viewBounds[5] + 1];
    var inverseViewMatrix = new Float64Array(16);
    var worldFocalPoint = new Float64Array(3);
    var worldPosition = new Float64Array(3);
    mat4.invert(inverseViewMatrix, viewMatrix);
    vec3.transformMat4(worldFocalPoint, viewFocalPoint, inverseViewMatrix);
    vec3.transformMat4(worldPosition, viewPosition, inverseViewMatrix); // Compute parallel scale

    var view = model.renderer.getRenderWindow().getViews()[0];
    var dims = view.getViewportSize(model.renderer);
    var aspect = dims[0] / dims[1];
    var xLength = vtkBoundingBox.getLength(viewBounds, 0);
    var yLength = vtkBoundingBox.getLength(viewBounds, 1);
    var parallelScale = 0.5 * Math.max(yLength, xLength / aspect);

    if (parallelScale <= 0) {
      return initialReset;
    } // Compute bounds in world coordinates


    var worldBounds = vtkBoundingBox.transformBounds(viewBounds, inverseViewMatrix);
    publicAPI.setCameraParameters({
      position: worldPosition,
      focalPoint: worldFocalPoint,
      bounds: worldBounds,
      parallelScale: parallelScale
    });
    return true;
  }; // --------------------------------------------------------------------------
  // Range Manipulator setup
  // -------------------------------------------------------------------------


  model.rangeManipulator = vtkMouseRangeManipulator.newInstance({
    button: 1,
    scrollEnabled: true
  });
  model.interactorStyle2D.addMouseManipulator(model.rangeManipulator);

  function setWindowWidth(windowWidth) {
    publicAPI.updateCornerAnnotation({
      windowWidth: windowWidth
    });

    if (model.sliceRepresentation && model.sliceRepresentation.setWindowWidth) {
      model.sliceRepresentation.setWindowWidth(windowWidth);
    }
  }

  function setWindowLevel(windowLevel) {
    publicAPI.updateCornerAnnotation({
      windowLevel: windowLevel
    });

    if (model.sliceRepresentation && model.sliceRepresentation.setWindowLevel) {
      model.sliceRepresentation.setWindowLevel(windowLevel);
    }
  }

  function setSlice(sliceRaw) {
    var numberSliceRaw = Number(sliceRaw);
    var slice = Number.isInteger(numberSliceRaw) ? sliceRaw : numberSliceRaw.toFixed(2); // add 'slice' in annotation

    var annotation = {
      slice: slice
    };

    if (model.sliceRepresentation && model.sliceRepresentation.setSlice) {
      model.sliceRepresentation.setSlice(numberSliceRaw);
    } // extend annotation


    if (model.sliceRepresentation && model.sliceRepresentation.getAnnotations) {
      var addOn = model.sliceRepresentation.getAnnotations();
      Object.keys(addOn).forEach(function (key) {
        annotation[key] = formatAnnotationValue(addOn[key]);
      });
    }

    publicAPI.updateCornerAnnotation(annotation);
  }

  publicAPI.bindRepresentationToManipulator = function (representation) {
    var nbListeners = 0;
    model.rangeManipulator.removeAllListeners();
    model.sliceRepresentation = representation;

    while (model.sliceRepresentationSubscriptions.length) {
      model.sliceRepresentationSubscriptions.pop().unsubscribe();
    }

    if (representation) {
      model.sliceRepresentationSubscriptions.push(model.camera.onModified(publicAPI.updateWidthHeightAnnotation));

      if (representation.getWindowWidth) {
        var update = function update() {
          return setWindowWidth(representation.getWindowWidth());
        };

        var windowWidth = representation.getPropertyDomainByName('windowWidth');
        var min = windowWidth.min,
            max = windowWidth.max;
        var step = windowWidth.step;

        if (!step || step === 'any') {
          step = 1 / DEFAULT_STEP_WIDTH;
        }

        model.rangeManipulator.setVerticalListener(min, max, step, representation.getWindowWidth, setWindowWidth);
        model.sliceRepresentationSubscriptions.push(representation.onModified(update));
        update();
        nbListeners++;
      }

      if (representation.getWindowLevel) {
        var _update = function _update() {
          return setWindowLevel(representation.getWindowLevel());
        };

        var windowLevel = representation.getPropertyDomainByName('windowLevel');
        var _min = windowLevel.min,
            _max = windowLevel.max;
        var _step = windowLevel.step;

        if (!_step || _step === 'any') {
          _step = 1 / DEFAULT_STEP_WIDTH;
        }

        model.rangeManipulator.setHorizontalListener(_min, _max, _step, representation.getWindowLevel, setWindowLevel);
        model.sliceRepresentationSubscriptions.push(representation.onModified(_update));

        _update();

        nbListeners++;
      }

      var domain = representation.getPropertyDomainByName('slice');

      if (representation.getSlice && domain) {
        var _update2 = function _update2() {
          return setSlice(representation.getSlice());
        };

        model.rangeManipulator.setScrollListener(domain.min, domain.max, domain.step, representation.getSlice, setSlice);
        model.sliceRepresentationSubscriptions.push(representation.onModified(_update2));

        _update2();

        nbListeners++;
      }
    }

    return nbListeners;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  axis: 2,
  orientation: -1,
  viewUp: [0, 1, 0],
  useParallelRendering: true,
  sliceRepresentationSubscriptions: [],
  fitProps: false
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkViewProxy.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ['axis']);
  macro.setGet(publicAPI, model, ['fitProps']); // Object specific methods

  vtkView2DProxy(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkView2DProxy'); // ----------------------------------------------------------------------------

var vtkView2DProxy$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkView2DProxy$1 as default, extend, newInstance };
