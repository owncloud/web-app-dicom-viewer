import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import vtk from '../../../vtk.js';
import vtkPiecewiseFunctionProxy from '../PiecewiseFunctionProxy.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function getProperties(proxy) {
  var props = {};
  proxy.listPropertyNames().forEach(function (name) {
    props[name] = proxy.getPropertyByName(name).value;
  });
  return props;
} // ----------------------------------------------------------------------------
// Proxy State Handling
// ----------------------------------------------------------------------------


function addStateAPI(publicAPI, model) {
  publicAPI.loadState = function (state) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve, reject) {
      var proxyMapping = {};
      var $oldToNewIdMapping = {};
      var cameras = {};
      var datasetHandler = options.datasetHandler || vtk;
      var sourcePromises = [];
      state.sources.forEach(function (_ref) {
        var id = _ref.id,
            group = _ref.group,
            name = _ref.name,
            props = _ref.props;
        sourcePromises.push(Promise.resolve(datasetHandler(props.dataset)).then(function (dataset) {
          if (dataset) {
            var proxy = publicAPI.createProxy(group, name);
            proxy.setName(props.name);
            proxy.setInputData(dataset, props.type);
            proxyMapping[id] = proxy;
            return proxy;
          }

          return null;
        }));
      });
      Promise.all(sourcePromises).then(function () {
        var views = publicAPI.getViews();
        state.views.forEach(function (_ref2) {
          var id = _ref2.id,
              group = _ref2.group,
              name = _ref2.name,
              props = _ref2.props,
              camera = _ref2.camera;
          var proxy = null;

          if (state.options.recycleViews) {
            proxy = views.find(function (v) {
              return v.getProxyGroup() === group && v.getProxyName() === name && v.getName() === props.name;
            });
          }

          if (!proxy) {
            proxy = publicAPI.createProxy(group, name, {
              disableAnimation: true
            });
          } else {
            proxy.setDisableAnimation(true);
          }

          proxy.set(props, true);
          proxyMapping[id] = proxy;
          cameras[id] = camera;
        });

        function updateView(view) {
          if (!proxyMapping[view] || !cameras[view]) {
            return;
          }

          proxyMapping[view].resetOrientation().then(function () {
            proxyMapping[view].getCamera().set(cameras[view]);
            proxyMapping[view].getRenderer().updateLightsGeometryToFollowCamera();
            proxyMapping[view].renderLater();
          });
        }

        state.representations.forEach(function (_ref3) {
          var source = _ref3.source,
              view = _ref3.view,
              props = _ref3.props;
          var proxy = publicAPI.getRepresentation(proxyMapping[source], proxyMapping[view]);
          proxy.set(props, true);
          updateView(view);
        }); // restore luts and pwfs after restoring reps to avoid
        // rep initialization from resetting restored luts/pwfs

        Object.keys(state.fields).forEach(function (fieldName) {
          var _state$fields$fieldNa = state.fields[fieldName],
              lookupTable = _state$fields$fieldNa.lookupTable,
              piecewiseFunction = _state$fields$fieldNa.piecewiseFunction;
          var lutProxy = publicAPI.getLookupTable(fieldName, lookupTable);
          lutProxy.setPresetName(lookupTable.presetName);
          lutProxy.setDataRange.apply(lutProxy, _toConsumableArray(lookupTable.dataRange));
          var pwfProxy = publicAPI.getPiecewiseFunction(fieldName, piecewiseFunction);

          switch (piecewiseFunction.mode) {
            case vtkPiecewiseFunctionProxy.Mode.Gaussians:
              pwfProxy.setGaussians(piecewiseFunction.gaussians);
              break;

            case vtkPiecewiseFunctionProxy.Mode.Points:
              pwfProxy.setPoints(piecewiseFunction.points);
              break;

            case vtkPiecewiseFunctionProxy.Mode.Nodes:
              pwfProxy.setNodes(piecewiseFunction.nodes);
              break;
          }

          pwfProxy.setMode(piecewiseFunction.mode);
          pwfProxy.setDataRange.apply(pwfProxy, _toConsumableArray(piecewiseFunction.dataRange));
        }); // Apply camera no matter what

        Object.keys(cameras).forEach(updateView); // Create id mapping

        Object.keys(proxyMapping).forEach(function (originalId) {
          var newId = proxyMapping[originalId].getProxyId();
          $oldToNewIdMapping[originalId] = newId;
        }); // Re-enable animation on views

        state.views.forEach(function (_ref4) {
          var id = _ref4.id;
          proxyMapping[id].setDisableAnimation(false);
        });
        resolve(_objectSpread(_objectSpread({}, state.userData), {}, {
          $oldToNewIdMapping: $oldToNewIdMapping
        }));
      }).catch(reject);
    });
  };

  publicAPI.saveState = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var userData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve, reject) {
      var sources = publicAPI.getSources(); // const representations = publicAPI.getRepresentations();

      var views = publicAPI.getViews(); // Extract handlers

      var datasetHandler = options.datasetHandler || function (d) {
        return d.getState();
      };

      delete options.datasetHandler;
      var datasets = [];
      var fieldNames = new Set();
      var state = {
        userData: userData,
        options: options,
        sources: [],
        views: [],
        representations: [],
        fields: {}
      };
      sources.forEach(function (source) {
        var dataset = Promise.resolve(datasetHandler(source.getDataset(), source));
        datasets.push(dataset);
        state.sources.push({
          id: source.getProxyId(),
          group: source.getProxyGroup(),
          name: source.getProxyName(),
          props: {
            name: source.getName(),
            type: source.getType(),
            dataset: dataset
          }
        });
      });
      views.forEach(function (view) {
        var camera = view.getCamera().get('position', 'viewUp', 'focalPoint');
        state.views.push({
          id: view.getProxyId(),
          group: view.getProxyGroup(),
          name: view.getProxyName(),
          props: Object.assign(getProperties(view), view.get('axis', 'orientation', 'viewUp')),
          camera: camera
        }); // Loop over view representations

        var representations = view.getRepresentations();
        representations.forEach(function (representation) {
          state.representations.push({
            source: representation.getInput().getProxyId(),
            view: view.getProxyId(),
            props: getProperties(representation)
          });
          fieldNames.add(representation.getColorBy()[0]);
        });
      });
      fieldNames.forEach(function (fieldName) {
        state.fields[fieldName] = {
          lookupTable: publicAPI.getLookupTable(fieldName).get('mode', 'presetName', 'rgbPoints', 'hsvPoints', 'nodes', 'arrayName', 'arrayLocation', 'dataRange'),
          piecewiseFunction: publicAPI.getPiecewiseFunction(fieldName).get('mode', 'gaussians', 'points', 'nodes', 'arrayName', 'arrayLocation', 'dataRange')
        };
      });
      Promise.all(datasets).then(function () {
        var _loop = function _loop(i) {
          state.sources[i].props.dataset.then(function (value) {
            state.sources[i].props.dataset = value;
          });
        };

        // Patch datasets in state to the result of the promises
        for (var i = 0; i < state.sources.length; i++) {
          _loop(i);
        } // provide valide state


        resolve(state);
      }).catch(reject);
    });
  };
}

export { addStateAPI as default };
