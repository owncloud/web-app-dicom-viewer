import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkDataArray from '../../Common/Core/DataArray.js';
import { f as vtkMath } from '../../Common/Core/Math/index.js';
import vtkPolyData from '../../Common/DataModel/PolyData.js';
import vtkTriangle from '../../Common/DataModel/Triangle.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// vtkPolyDataNormals methods
// ----------------------------------------------------------------------------

function vtkPolyDataNormals(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPolyDataNormals');

  publicAPI.vtkPolyDataNormalsExecute = function (pointsData, polysData) {
    if (!pointsData) {
      return null;
    }

    var normalsData = new Float32Array(pointsData.length);
    var numberOfPoints = 0;
    var polysDataLength = polysData.length;
    var cellPointIds = [0, 0, 0];

    for (var c = 0; c < polysDataLength; c += numberOfPoints + 1) {
      numberOfPoints = polysData[c];

      if (numberOfPoints < 3) {
        continue; // eslint-disable-line
      }

      for (var i = 1; i <= 3; ++i) {
        cellPointIds[i - 1] = 3 * polysData[c + i];
      }

      var cellNormal = [];
      vtkTriangle.computeNormal(pointsData.slice(cellPointIds[0], cellPointIds[0] + 3), pointsData.slice(cellPointIds[1], cellPointIds[1] + 3), pointsData.slice(cellPointIds[2], cellPointIds[2] + 3), cellNormal);

      for (var _i = 1; _i <= numberOfPoints; ++_i) {
        var pointId = 3 * polysData[c + _i];
        normalsData[pointId] += cellNormal[0];
        normalsData[++pointId] += cellNormal[1];
        normalsData[++pointId] += cellNormal[2];
      }
    }
    /* Normalize normals */


    for (var _i2 = 0; _i2 < pointsData.length;) {
      var pointNormal = normalsData.slice(_i2, _i2 + 3);
      vtkMath.normalize(pointNormal);
      normalsData[_i2++] = pointNormal[0];
      normalsData[_i2++] = pointNormal[1];
      normalsData[_i2++] = pointNormal[2];
    }

    return normalsData;
  };

  publicAPI.requestData = function (inData, outData) {
    var numberOfInputs = publicAPI.getNumberOfInputPorts();

    if (!numberOfInputs) {
      return;
    }

    var input = inData[0];

    if (!input) {
      return;
    }

    var outputNormalsData = publicAPI.vtkPolyDataNormalsExecute(input.getPoints().getData(), input.getPolys().getData());
    var output = vtkPolyData.newInstance();
    var outputNormals = vtkDataArray.newInstance({
      numberOfComponents: 3,
      values: outputNormalsData
    });
    output.setPoints(input.getPoints());
    output.setVerts(input.getVerts());
    output.setLines(input.getLines());
    output.setPolys(input.getPolys());
    output.setStrips(input.getStrips());
    output.getPointData().passData(input.getPointData());
    output.getCellData().passData(input.getCellData());
    output.getFieldData().passData(input.getFieldData());
    output.getPointData().setNormals(outputNormals);
    outData[0] = output;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


function defaultValues(initialValues) {
  return _objectSpread({}, initialValues);
} // ----------------------------------------------------------------------------


function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));
  /* Make this a VTK object */

  macro.obj(publicAPI, model);
  /* Also make it an algorithm with one input and one output */

  macro.algo(publicAPI, model, 1, 1);
  /* Object specific methods */

  vtkPolyDataNormals(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkPolyDataNormals'); // ----------------------------------------------------------------------------

var vtkPolyDataNormals$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkPolyDataNormals$1 as default, extend, newInstance };
