import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';
import vtkCellArray from '../../Common/Core/CellArray.js';
import vtkLine from '../../Common/DataModel/Line.js';
import { d as dot, j as cross, n as norm, t as jacobi, l as normalize, k as add } from '../../Common/Core/Math/index.js';
import vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';
import vtkOBBNode from './OBBTree/OBBNode.js';
import vtkPoints from '../../Common/Core/Points.js';
import { CellType } from '../../Common/DataModel/CellTypes/Constants.js';
import vtkPolyData from '../../Common/DataModel/PolyData.js';
import vtkTriangle from '../../Common/DataModel/Triangle.js';
import { pushArray, getCellTriangles } from './OBBTree/helper.js';
import { mat4, vec4 } from 'gl-matrix';

var vtkErrorMacro = macro.vtkErrorMacro;
var VTK_DOUBLE_MAX = Number.MAX_SAFE_INTEGER; // ----------------------------------------------------------------------------
// vtkOBBTree methods
// ----------------------------------------------------------------------------

function vtkOBBTree(publicAPI, model) {
  // Set our classname
  model.classHierarchy.push('vtkOBBTree');
  /**
   * Compute an OBB from the list of cells given.  This used to be
   * public but should not have been.  A public call has been added
   * so that the functionality can be accessed.
   * @param {Array} cells
   * @param {Array[3]} corner
   * @param {Array[3]} max
   * @param {Array[3]} mid
   * @param {Array[3]} min
   * @param {Array[3]} size
   */

  function computeOBB(cells, corner, max, mid, min, size) {
    model.OBBCount++;
    model.pointsList = []; //
    // Compute mean & moments
    //

    var numCells = cells.length;
    var mean = [0, 0, 0];
    var totMass = 0.0;
    var a0 = [0, 0, 0];
    var a1 = [0, 0, 0];
    var a2 = [0, 0, 0];
    var a = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    var dp0 = [0, 0, 0];
    var dp1 = [0, 0, 0];
    var c = [0, 0, 0];
    var triMass = 0;

    if (!model.dataset.getCells()) {
      model.dataset.buildCells();
    }

    for (var i = 0; i < numCells; i++) {
      var cellId = cells[i];
      var type = model.dataset.getCells().getCellType(cellId);
      var ptIds = model.dataset.getCellPoints(cellId).cellPointIds;
      var _numPts = ptIds.length;

      for (var j = 0; j < _numPts - 2; j++) {
        var cellsIds = getCellTriangles(ptIds, type, j);
        var pId = cellsIds.ptId0;
        var qId = cellsIds.ptId1;
        var rId = cellsIds.ptId2;

        if (pId < 0) {
          // eslint-disable-next-line no-continue
          continue;
        }

        var p = [];
        var q = [];
        var r = [];
        model.dataset.getPoints().getPoint(pId, p);
        model.dataset.getPoints().getPoint(qId, q);
        model.dataset.getPoints().getPoint(rId, r); // p, q, and r are the oriented triangle points.
        // Compute the components of the moment of inertia tensor.

        for (var k = 0; k < 3; k++) {
          // two edge vectors
          dp0[k] = q[k] - p[k];
          dp1[k] = r[k] - p[k]; // centroid

          c[k] = (p[k] + q[k] + r[k]) / 3;
        }

        var xp = cross(dp0, dp1, []);
        triMass = 0.5 * norm(xp);
        totMass += triMass;

        for (var _k = 0; _k < 3; _k++) {
          mean[_k] += triMass * c[_k];
        } // on-diagonal terms


        a0[0] += triMass * (9 * c[0] * c[0] + p[0] * p[0] + q[0] * q[0] + r[0] * r[0]) / 12;
        a1[1] += triMass * (9 * c[1] * c[1] + p[1] * p[1] + q[1] * q[1] + r[1] * r[1]) / 12;
        a2[2] += triMass * (9 * c[2] * c[2] + p[2] * p[2] + q[2] * q[2] + r[2] * r[2]) / 12; // off-diagonal terms

        a0[1] += triMass * (9 * c[0] * c[1] + p[0] * p[1] + q[0] * q[1] + r[0] * r[1]) / 12;
        a0[2] += triMass * (9 * c[0] * c[2] + p[0] * p[2] + q[0] * q[2] + r[0] * r[2]) / 12;
        a1[2] += triMass * (9 * c[1] * c[2] + p[1] * p[2] + q[1] * q[2] + r[1] * r[2]) / 12;
      } // end foreach triangle
      // While computing cell moments, gather all the cell's
      // point coordinates into a single list.


      for (var _j = 0; _j < _numPts; _j++) {
        if (model.insertedPoints[ptIds[_j]] !== model.OBBCount) {
          model.insertedPoints[ptIds[_j]] = model.OBBCount;
          var pt = [];
          model.dataset.getPoints().getPoint(ptIds[_j], pt);
          model.pointsList.push(pt);
        }
      } // for all points of this cell

    } // end foreach cell
    // normalize data


    for (var _i = 0; _i < 3; _i++) {
      mean[_i] /= totMass;
    } // matrix is symmetric


    a1[0] = a0[1];
    a2[0] = a0[2];
    a2[1] = a1[2];
    a = [a0[0], a0[1], a0[2], a1[0], a1[1], a1[2], a2[0], a2[1], a2[2]]; // get covariance from moments

    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j2 = 0; _j2 < 3; _j2++) {
        a[_i2 * 3 + _j2] = a[_i2 * 3 + _j2] / totMass - mean[_i2] * mean[_j2];
      }
    } //
    // Extract axes (i.e., eigenvectors) from covariance matrix.
    //


    var v = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    jacobi(a, size, v);
    max[0] = v[0];
    max[1] = v[3];
    max[2] = v[6];
    mid[0] = v[1];
    mid[1] = v[4];
    mid[2] = v[7];
    min[0] = v[2];
    min[1] = v[5];
    min[2] = v[8];

    for (var _i3 = 0; _i3 < 3; _i3++) {
      a[_i3] = mean[_i3] + max[_i3];
      a[3 + _i3] = mean[_i3] + mid[_i3];
      a[6 + _i3] = mean[_i3] + min[_i3];
    } //
    // Create oriented bounding box by projecting points onto eigenvectors.
    //


    var tMin = [VTK_DOUBLE_MAX, VTK_DOUBLE_MAX, VTK_DOUBLE_MAX];
    var tMax = [-VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX];
    var numPts = model.pointsList.length;

    for (var ptId = 0; ptId < numPts; ptId++) {
      var _p = model.pointsList[ptId];

      for (var _i4 = 0; _i4 < 3; _i4++) {
        var out = vtkLine.distanceToLine(_p, mean, a.slice(3 * _i4, 3 * (_i4 + 1)), []);

        if (out.t < tMin[_i4]) {
          tMin[_i4] = out.t;
        }

        if (out.t > tMax[_i4]) {
          tMax[_i4] = out.t;
        }
      }
    } // for all points


    for (var _i5 = 0; _i5 < 3; _i5++) {
      corner[_i5] = mean[_i5] + tMin[0] * max[_i5] + tMin[1] * mid[_i5] + tMin[2] * min[_i5];
      max[_i5] *= tMax[0] - tMin[0];
      mid[_i5] *= tMax[1] - tMin[1];
      min[_i5] *= tMax[2] - tMin[2];
    }
  }
  /**
   * Build the OBB tree
   * @param {Array} cells
   * @param {vtkOBBNode} obbNode
   * @param {Number} level
   */


  function buildTree(cells, obbNode, level) {
    var numCells = cells.length;

    if (level > model.level) {
      model.level = level;
    }

    var axes = obbNode.getAxes();
    var corner = obbNode.getCorner();
    var size = [0, 0, 0];
    computeOBB(cells, corner, axes[0], axes[1], axes[2], size);
    obbNode.setAxes(axes);
    obbNode.setCorner(corner); // Check whether to continue recursing; if so, create two children and
    // assign cells to appropriate child.

    if (level < model.maxLevel && numCells > model.numberOfCellsPerNode) {
      var LHlist = [];
      var RHlist = [];
      var p = [0, 0, 0];
      var n = [0, 0, 0]; // loop over three split planes to find acceptable one

      for (var i = 0; i < 3; i++) {
        // compute split point
        p[i] = corner[i] + axes[0][i] / 2 + axes[1][i] / 2 + axes[2][i] / 2;
      }

      var splitPlane = 0;
      var splitAcceptable = 0;
      var bestRatio = 1;
      var foundBestSplit = 0;
      var bestPlane = 0;

      for (; !splitAcceptable && splitPlane < 3;) {
        // compute split normal
        for (var _i6 = 0; _i6 < 3; _i6++) {
          n[_i6] = axes[splitPlane][_i6];
        }

        normalize(n); // traverse cells, assigning to appropriate child list as necessary

        var _loop = function _loop(_i7) {
          var cellId = cells[_i7];
          var pointsIDs = model.dataset.getCellPoints(cellId).cellPointIds;
          var cellPts = [];
          pointsIDs.forEach(function (id) {
            var pt = [];
            model.dataset.getPoints().getPoint(pointsIDs[id], pt);
            cellPts.push(pt);
          });
          var c = [0, 0, 0];
          var numPts = cellPts.length;
          var negative = 0;
          var positive = 0;

          for (var j = 0; j < numPts; j++) {
            var ptId = pointsIDs[j];
            var x = model.dataset.getPoints().getPoint(ptId);
            var val = n[0] * (x[0] - p[0]) + n[1] * (x[1] - p[1]) + n[2] * (x[2] - p[2]);
            c[0] += x[0];
            c[1] += x[1];
            c[2] += x[2];

            if (val < 0.0) {
              negative = 1;
            } else {
              positive = 1;
            }
          }

          if (negative && positive) {
            // Use centroid to decide straddle cases
            c[0] /= numPts;
            c[1] /= numPts;
            c[2] /= numPts;

            var _val = n[0] * (c[0] - p[0]) + n[1] * (c[1] - p[1]) + n[2] * (c[2] - p[2]);

            if (_val < 0.0) {
              LHlist.push(cellId);
            } else {
              RHlist.push(cellId);
            }
          } else if (negative) {
            LHlist.push(cellId);
          } else {
            RHlist.push(cellId);
          }
        };

        for (var _i7 = 0; _i7 < numCells; _i7++) {
          _loop(_i7);
        } // for all cells
        // evaluate this split


        var numInLHnode = LHlist.length;
        var numInRHnode = RHlist.length;
        var ratio = Math.abs((numInRHnode - numInLHnode) / numCells); // see whether we've found acceptable split plane

        if (ratio < 0.6 || foundBestSplit) {
          // accept right off the bat
          splitAcceptable = 1;
        } else {
          // not a great split try another
          LHlist = [];
          RHlist = [];

          if (ratio < bestRatio) {
            bestRatio = ratio;
            bestPlane = splitPlane;
          }

          if (++splitPlane === 3 && bestRatio < 0.95) {
            // at closing time, even the ugly ones look good
            splitPlane = bestPlane;
            foundBestSplit = 1;
          }
        } // try another split

      } // for each split


      if (splitAcceptable) {
        // otherwise recursion terminates
        var LHnode = vtkOBBNode.newInstance();
        var RHnode = vtkOBBNode.newInstance();
        obbNode.setKids([LHnode, RHnode]);
        LHnode.setParent(obbNode);
        RHnode.setParent(obbNode);
        cells.length = 0;
        buildTree(LHlist, LHnode, level + 1);
        buildTree(RHlist, RHnode, level + 1);
      } else {
        // free up local objects
        LHlist = [];
        RHlist = [];
      }
    } // if should build tree


    if (cells && model.retainCellLists) {
      obbNode.setCells(cells);
    } else if (cells) {
      cells.length = 0;
    }
  }

  function generatePolygons(obbNode, level, repLevel, points, cells) {
    if (level === repLevel || repLevel < 0 && obbNode.getKids()) {
      var nbPoints = points.getNumberOfPoints();
      var newPoints = [];
      var newCells = [];
      var cubeIds = [];
      newPoints.push.apply(newPoints, _toConsumableArray(obbNode.getCorner()));
      cubeIds[0] = nbPoints++;
      var x = [];
      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(0), x)));
      cubeIds[1] = nbPoints++;
      var y = [];
      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(1), y)));
      cubeIds[2] = nbPoints++;
      var xy = [];
      newPoints.push.apply(newPoints, _toConsumableArray(add(x, obbNode.getAxis(1), xy)));
      cubeIds[3] = nbPoints++;
      var z = [];
      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(2), z)));
      cubeIds[4] = nbPoints++;
      var xz = [];
      newPoints.push.apply(newPoints, _toConsumableArray(add(x, obbNode.getAxis(2), xz)));
      cubeIds[5] = nbPoints++;
      var yz = [];
      newPoints.push.apply(newPoints, _toConsumableArray(add(y, obbNode.getAxis(2), yz)));
      cubeIds[6] = nbPoints++;
      var xyz = [];
      newPoints.push.apply(newPoints, _toConsumableArray(add(xy, obbNode.getAxis(2), xyz)));
      cubeIds[7] = nbPoints++;
      newCells.push(4, cubeIds[0], cubeIds[2], cubeIds[3], cubeIds[1]);
      newCells.push(4, cubeIds[0], cubeIds[1], cubeIds[5], cubeIds[4]);
      newCells.push(4, cubeIds[0], cubeIds[4], cubeIds[6], cubeIds[2]);
      newCells.push(4, cubeIds[1], cubeIds[3], cubeIds[7], cubeIds[5]);
      newCells.push(4, cubeIds[4], cubeIds[5], cubeIds[7], cubeIds[6]);
      newCells.push(4, cubeIds[2], cubeIds[6], cubeIds[7], cubeIds[3]);
      points.setData(pushArray(points.getData(), newPoints));
      cells.setData(pushArray(cells.getData(), newCells));
    } else if ((level < repLevel || repLevel < 0) && obbNode.getKids()) {
      generatePolygons(obbNode.getKids()[0], level + 1, repLevel, points, cells);
      generatePolygons(obbNode.getKids()[1], level + 1, repLevel, points, cells);
    }
  }
  /**
   * Transform the whole OBB tree by using input transform
   * @param {Transform} transform vtkjs Transform object
   */


  publicAPI.transform = function (transform) {
    // Setup matrix used to transform vectors
    var matrix = mat4.create();
    mat4.copy(matrix, transform.getMatrix());
    matrix[12] = 0;
    matrix[13] = 0;
    matrix[14] = 0;
    matrix[15] = 1;
    var transformVector = vtkMatrixBuilder.buildFromRadian().setMatrix(matrix);
    var obbStack = new Array(model.level + 1);
    obbStack[0] = model.tree;
    var depth = 1;

    while (depth > 0) {
      depth -= 1;
      var node = obbStack[depth];
      var corner = node.getCorner();
      var max = node.getAxis(0);
      var mid = node.getAxis(1);
      var min = node.getAxis(2);
      transform.apply(corner);
      transformVector.apply(max);
      transformVector.apply(mid);
      transformVector.apply(min);
      node.setCorner(corner);
      node.setAxes([max, mid, min]);

      if (node.getKids() !== null) {
        // push kids onto stack
        obbStack[depth] = node.getKids()[0];
        obbStack[depth + 1] = node.getKids()[1];
        depth += 2;
      }
    }
  };
  /**
   * Deep copy input node into class attribute tree
   * @param {vtkOBBNode} tree
   * @returns
   */


  publicAPI.deepCopy = function (tree) {
    if (!tree) {
      return;
    }

    publicAPI.setLevel(tree.getLevel());
    publicAPI.setRetainCellLists(tree.getRetainCellLists());
    publicAPI.setDataset(tree.getDataset());
    publicAPI.setAutomatic(tree.getAutomatic());
    publicAPI.setNumberOfCellsPerNode(tree.getNumberOfCellsPerNode());
    publicAPI.setTolerance(tree.getTolerance());
    var root = tree.getTree();

    if (root) {
      model.tree = vtkOBBNode.newInstance();
      model.tree.deepCopy(root);
    }
  };
  /**
   * A method to compute the OBB of a dataset without having to go through the
   * Execute method; It does set
   * @param {vtkPolyData} input
   * @param {Array[3]} corner
   * @param {Array[3]} max
   * @param {Array[3]} mid
   * @param {Array[3]} min
   * @param {Array[3]} size
   */


  publicAPI.computeOBBFromDataset = function (input, corner, max, mid, min, size) {
    if (!input) {
      return;
    }

    var numPts = input.getPoints().getNumberOfPoints();
    var numCells = input.getNumberOfCells();

    if (numPts < 1 || numCells < 1) {
      vtkErrorMacro("Can't compute OBB - no data available!");
      return;
    }

    model.dataset = input;
    model.OBBCount = 0;
    model.insertedPoints = Array.from({
      length: numPts
    }, function (_) {
      return 0;
    });
    model.pointsList = [];
    var cellList = Array.from({
      length: numCells
    }, function (_, i) {
      return i;
    });
    computeOBB(cellList, corner, max, mid, min, size);
  };
  /**
   * Returns true if nodeB and nodeA are disjoint after optional
   * transformation of nodeB with matrix XformBtoA
   * @param {vtkOBBNode} nodeA
   * @param {vtkOBBNode} nodeB
   * @param {mat4} XformBtoA
   */


  publicAPI.disjointOBBNodes = function (nodeA, nodeB, XformBtoA) {
    if (!nodeA || !nodeB) {
      return 5; // A and B are disjoint
    }

    var input = new Array(4);
    var output = new Array(4);
    var eps = model.tolerance;
    var pA = nodeA;
    var pB = vtkOBBNode.newInstance();
    var dotAB = [0, 0, 0, 0, 0, 0, 0, 0, 0];

    if (XformBtoA) {
      // Here we assume that XformBtoA is an orthogonal matrix
      input[0] = nodeB.getCorner()[0];
      input[1] = nodeB.getCorner()[1];
      input[2] = nodeB.getCorner()[2];
      input[3] = 1.0;
      vec4.transformMat4(output, input, XformBtoA);
      pB.setCorner([output[0] / output[3], output[1] / output[3], output[2] / output[3]]); // Clean this up when the bug input MultiplyVectors is fixed!

      for (var ii = 0; ii < 3; ii++) {
        pB.getAxis(0)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(0)[ii];
        pB.getAxis(1)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(1)[ii];
        pB.getAxis(2)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(2)[ii];
      }

      for (var _ii = 0; _ii < 3; _ii++) {
        input[0] = pB.getAxis(_ii)[0];
        input[1] = pB.getAxis(_ii)[1];
        input[2] = pB.getAxis(_ii)[2];
        input[3] = 1.0;
        vec4.transformMat4(output, input, XformBtoA);
        pB.getAxis(_ii)[0] = output[0] / output[3];
        pB.getAxis(_ii)[1] = output[1] / output[3];
        pB.getAxis(_ii)[2] = output[2] / output[3];
      }

      for (var _ii2 = 0; _ii2 < 3; _ii2++) {
        pB.getAxis(0)[_ii2] = pB.getAxis(0)[_ii2] - pB.getCorner()[_ii2];
        pB.getAxis(1)[_ii2] = pB.getAxis(1)[_ii2] - pB.getCorner()[_ii2];
        pB.getAxis(2)[_ii2] = pB.getAxis(2)[_ii2] - pB.getCorner()[_ii2];
      }
    } else {
      pB = nodeB;
    }

    var centerA = [0, 0, 0];
    var centerB = [0, 0, 0];
    var AtoB = [0, 0, 0];

    for (var _ii3 = 0; _ii3 < 3; _ii3++) {
      centerA[_ii3] = pA.getCorner()[_ii3] + 0.5 * (pA.getAxis(0)[_ii3] + pA.getAxis(1)[_ii3] + pA.getAxis(2)[_ii3]);
      centerB[_ii3] = pB.getCorner()[_ii3] + 0.5 * (pB.getAxis(0)[_ii3] + pB.getAxis(1)[_ii3] + pB.getAxis(2)[_ii3]);
      AtoB[_ii3] = centerB[_ii3] - centerA[_ii3];
    } // Project maximal and minimal corners onto line between centers


    var rangeAmin = dot(pA.getCorner(), AtoB);
    var rangeAmax = rangeAmin;
    var rangeBmin = dot(pB.getCorner(), AtoB);
    var rangeBmax = rangeBmin;
    var dotA = 0;
    var dotB = 0;

    for (var _ii4 = 0; _ii4 < 3; _ii4++) {
      // compute A range
      dotA = dot(pA.getAxis(_ii4), AtoB);

      if (dotA > 0) {
        rangeAmax += dotA;
      } else {
        rangeAmin += dotA;
      } // compute B range


      dotB = dot(pB.getAxis(_ii4), AtoB);

      if (dotB > 0) {
        rangeBmax += dotB;
      } else {
        rangeBmin += dotB;
      }
    }

    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
      return 1; // A and B are Disjoint by the 1st test.
    } // now check for a separation plane parallel to the faces of B


    for (var _ii5 = 0; _ii5 < 3; _ii5++) {
      // plane is normal to pB.getAxis(ii)
      // computing B range is easy...
      rangeBmin = dot(pB.getCorner(), pB.getAxis(_ii5));
      rangeBmax = rangeBmin;
      rangeBmax += dot(pB.getAxis(_ii5), pB.getAxis(_ii5)); // compute A range...

      rangeAmin = dot(pA.getCorner(), pB.getAxis(_ii5));
      rangeAmax = rangeAmin;

      for (var jj = 0; jj < 3; jj++) {
        // (note: we are saving all 9 dotproducts for future use)
        dotA = dot(pB.getAxis(_ii5), pA.getAxis(jj));
        dotAB[_ii5 * 3 + jj] = dotA;

        if (dotA > 0) {
          rangeAmax += dotA;
        } else {
          rangeAmin += dotA;
        }
      }

      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
        return 2; // A and B are Disjoint by the 3rd test.
      }
    } // now check for a separation plane parallel to the faces of A


    for (var _ii6 = 0; _ii6 < 3; _ii6++) {
      // plane is normal to pA.getAxis(ii)
      // computing A range is easy...
      rangeAmin = dot(pA.getCorner(), pA.getAxis(_ii6));
      rangeAmax = rangeAmin;
      rangeAmax += dot(pA.getAxis(_ii6), pA.getAxis(_ii6)); // compute B range...

      rangeBmin = dot(pB.getCorner(), pA.getAxis(_ii6));
      rangeBmax = rangeBmin;

      for (var _jj = 0; _jj < 3; _jj++) {
        // (note: we are using the 9 dotproducts computed earlier)
        dotB = dotAB[_jj * 3 + _ii6];

        if (dotB > 0) {
          rangeBmax += dotB;
        } else {
          rangeBmin += dotB;
        }
      }

      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
        return 3; // A and B are Disjoint by the 2nd test.
      }
    } // Bad luck: now we must look for a separation plane parallel
    // to one edge from A and one edge from B.


    for (var _ii7 = 0; _ii7 < 3; _ii7++) {
      for (var _jj2 = 0; _jj2 < 3; _jj2++) {
        // the plane is normal to pA.getAxis(ii) X pB.getAxis(jj)
        cross(pA.getAxis(_ii7), pB.getAxis(_jj2), AtoB);
        rangeAmin = dot(pA.getCorner(), AtoB);
        rangeAmax = rangeAmin;
        rangeBmin = dot(pB.getCorner(), AtoB);
        rangeBmax = rangeBmin;

        for (var kk = 0; kk < 3; kk++) {
          // compute A range
          dotA = dot(pA.getAxis(kk), AtoB);

          if (dotA > 0) {
            rangeAmax += dotA;
          } else {
            rangeAmin += dotA;
          } // compute B range


          dotB = dot(pB.getAxis(kk), AtoB);

          if (dotB > 0) {
            rangeBmax += dotB;
          } else {
            rangeBmin += dotB;
          }
        }

        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
          return 4; // A and B are Disjoint by the 4th test.
        }
      }
    } // if we fall through to here, the OBB's overlap


    return 0;
  };
  /**
   * Intersect this OBBTree with OBBTreeB (as transformed) and
   * call processing function for each intersecting leaf node pair.
   * If the processing function returns a negative integer, terminate.
   * For each intersecting leaf node pair, call callback.
   * OBBTreeB is optionally transformed by XformBtoA before testing
   * @param {vtkOBBTree} obbTreeB
   * @param {mat4|null|undefined} XformBtoA
   * @param {function|null|undefined} callback Compared function that takes in argument:
   * nodeA (vtkOBBNode), nodeB (vtkOBBNode), XForm (mat4), arg
   */


  publicAPI.intersectWithOBBTree = function (obbTreeB, XformBtoA) {
    var onIntersect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
      return -1;
    };
    var maxDepth = model.level;
    var minDepth = obbTreeB.getLevel();

    if (minDepth > maxDepth) {
      minDepth = maxDepth;
      maxDepth = obbTreeB.getLevel();
    }

    var maxStackDepth = 3 * minDepth + 2 * (maxDepth - minDepth) + 1;
    var OBBStackA = new Array(maxStackDepth);
    var OBBStackB = new Array(maxStackDepth);
    OBBStackA[0] = model.tree;
    OBBStackB[0] = obbTreeB.getTree();
    var depth = 1;
    var count = 0;
    var returnValue = 0; // simulate recursion without overhead of real recursion.

    while (depth > 0 && returnValue > -1) {
      depth--;
      var nodeA = OBBStackA[depth];
      var nodeB = OBBStackB[depth];

      if (!publicAPI.disjointOBBNodes(nodeA, nodeB, XformBtoA)) {
        // Collision
        if (!nodeA.getKids()) {
          if (!nodeB.getKids()) {
            returnValue = onIntersect(nodeA, nodeB, XformBtoA);
            count += Math.abs(returnValue);
          } else {
            // A is a leaf, but B goes deeper.
            OBBStackA[depth] = nodeA;
            OBBStackB[depth] = nodeB.getKids()[0];
            OBBStackA[depth + 1] = nodeA;
            OBBStackB[depth + 1] = nodeB.getKids()[1];
            depth += 2;
          }
        } else if (!nodeB.getKids()) {
          // B is a leaf, but A goes deeper.
          OBBStackB[depth] = nodeB;
          OBBStackA[depth] = nodeA.getKids()[0];
          OBBStackB[depth + 1] = nodeB;
          OBBStackA[depth + 1] = nodeA.getKids()[1];
          depth += 2;
        } else {
          // neither A nor B are leaves. Go to the next level.
          OBBStackA[depth] = nodeA.getKids()[0];
          OBBStackB[depth] = nodeB.getKids()[0];
          OBBStackA[depth + 1] = nodeA.getKids()[1];
          OBBStackB[depth + 1] = nodeB.getKids()[0];
          OBBStackA[depth + 2] = nodeA.getKids()[0];
          OBBStackB[depth + 2] = nodeB.getKids()[1];
          OBBStackA[depth + 3] = nodeA.getKids()[1];
          OBBStackB[depth + 3] = nodeB.getKids()[1];
          depth += 4;
        }
      }
    }

    return count;
  };

  publicAPI.triangleIntersectsNode = function (nodeA, p0, p1, p2, XformBtoA) {
    var eps = model.tolerance;
    var pA = nodeA;
    var pB = [_toConsumableArray(p0), _toConsumableArray(p1), _toConsumableArray(p2)];

    if (XformBtoA) {
      // Here we assume that XformBtoA is an orthogonal matrix
      var input = [0, 0, 0, 1];
      var output = [];

      for (var ii = 0; ii < 3; ii++) {
        input[0] = pB[ii][0];
        input[1] = pB[ii][1];
        input[2] = pB[ii][2];
        vec4.transformMat4(output, input, XformBtoA);
        pB[ii][0] = output[0] / output[3];
        pB[ii][1] = output[1] / output[3];
        pB[ii][2] = output[2] / output[3];
      }
    } // now check for a separation plane parallel to the triangle


    var v0 = [];
    var v1 = [];

    for (var _ii8 = 0; _ii8 < 3; _ii8++) {
      // plane is normal to the triangle
      v0[_ii8] = pB[1][_ii8] - pB[0][_ii8];
      v1[_ii8] = pB[2][_ii8] - pB[0][_ii8];
    }

    var xprod = cross(v0, v1, []); // computing B range is easy...

    var rangeBmax = dot(pB[0], xprod);
    var rangeBmin = rangeBmax; // compute A range...

    var rangeAmax = dot(pA.getCorner(), xprod);
    var rangeAmin = rangeAmax;
    var dotA;

    for (var jj = 0; jj < 3; jj++) {
      dotA = dot(xprod, pA.getAxis(jj));

      if (dotA > 0) {
        rangeAmax += dotA;
      } else {
        rangeAmin += dotA;
      }
    }

    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
      return 0; // A and B are Disjoint by the 1st test.
    } // now check for a separation plane parallel to the faces of A


    for (var _ii9 = 0; _ii9 < 3; _ii9++) {
      // plane is normal to pA->Axes[ii]
      // computing A range is easy...
      rangeAmax = dot(pA.getCorner(), pA.getAxis(_ii9));
      rangeAmin = rangeAmax;
      rangeAmax += dot(pA.getAxis(_ii9), pA.getAxis(_ii9)); // compute B range...

      rangeBmax = dot(pB[0], pA.getAxis(_ii9));
      rangeBmin = rangeBmax;

      var _dotB = dot(pB[1], pA.getAxis(_ii9));

      if (_dotB > rangeBmax) {
        rangeBmax = _dotB;
      } else {
        rangeBmin = _dotB;
      }

      _dotB = dot(pB[2], pA.getAxis(_ii9));

      if (_dotB > rangeBmax) {
        rangeBmax = _dotB;
      } else if (_dotB < rangeBmin) {
        rangeBmin = _dotB;
      }

      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
        return 0; // A and B are Disjoint by the 2nd test.
      }
    } // Bad luck: now we must look for a separation plane parallel
    // to one edge from A and one edge from B.


    var AtoB = [];
    var dotB;

    for (var _ii10 = 0; _ii10 < 3; _ii10++) {
      for (var _jj3 = 0; _jj3 < 3; _jj3++) {
        // the plane is normal to pA->Axes[ii] X (pB[jj+1]-pB[jj])
        v0[0] = pB[(_jj3 + 1) % 3][0] - pB[_jj3][0];
        v0[1] = pB[(_jj3 + 1) % 3][1] - pB[_jj3][1];
        v0[2] = pB[(_jj3 + 1) % 3][2] - pB[_jj3][2];
        cross(pA.getAxis(_ii10), v0, AtoB);
        rangeAmax = dot(pA.getCorner(), AtoB);
        rangeAmin = rangeAmax;
        rangeBmax = dot(pB[_jj3], AtoB);
        rangeBmin = rangeBmax;

        for (var kk = 0; kk < 3; kk++) {
          // compute A range
          dotA = dot(pA.getAxis(kk), AtoB);

          if (dotA > 0) {
            rangeAmax += dotA;
          } else {
            rangeAmin += dotA;
          }
        } // compute B range


        dotB = dot(pB[(_jj3 + 2) % 3], AtoB);

        if (dotB > rangeBmax) {
          rangeBmax = dotB;
        } else {
          rangeBmin = dotB;
        }

        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
          return 0; // A and B are Disjoint by the 3rd test.
        }
      }
    } // if we fall through to here, the OBB overlaps the triangle.


    return 1;
  };
  /**
   *
   * @param {*} info must be an object with { obbTree1, intersectionLines }
   * @param {*} node0
   * @param {*} node1
   * @param {*} transform
   * @returns the number of intersection lines found
   */


  publicAPI.findTriangleIntersections = function (info, node0, node1, transform) {
    // Set up local structures to hold Impl array information
    // vtkOBBTree* obbTree1 = info->OBBTree1;
    // vtkCellArray* intersectionLines = info->IntersectionLines;
    // vtkIdTypeArray* intersectionSurfaceId = info->SurfaceId;
    // vtkIdTypeArray* intersectionCellIds0 = info->CellIds[0];
    // vtkIdTypeArray* intersectionCellIds1 = info->CellIds[1];
    // vtkPointLocator* pointMerger = info->PointMerger;
    // double tolerance = info->Tolerance;
    var mesh0 = publicAPI.getDataset();
    var mesh1 = info.obbTree1.getDataset();
    var pointOffset = info.intersectionLines.getPoints().getNumberOfPoints();
    var intersectionPoints = [];
    var intersectionLines = []; // The number of cells in OBBTree

    var numCells0 = node0.getCells().length;

    for (var id0 = 0; id0 < numCells0; id0++) {
      var cellId0 = node0.getCells()[id0];
      var type0 = mesh0.getCellType(cellId0); // Make sure the cell is a triangle

      if (type0 === CellType.VTK_TRIANGLE) {
        var _mesh0$getCellPoints = mesh0.getCellPoints(cellId0),
            triPtIds0 = _mesh0$getCellPoints.cellPointIds;

        var triPts0 = [[], [], []];

        for (var id = 0; id < triPtIds0.length; id++) {
          mesh0.getPoints().getPoint(triPtIds0[id], triPts0[id]);
        }

        if (info.obbTree1.triangleIntersectsNode(node1, triPts0[0], triPts0[1], triPts0[2], transform)) {
          var numCells1 = node1.getCells().length;

          for (var id1 = 0; id1 < numCells1; id1++) {
            var cellId1 = node1.getCells()[id1];
            var type1 = mesh1.getCellType(cellId1);

            if (type1 === CellType.VTK_TRIANGLE) {
              // See if the two cells actually intersect. If they do,
              // add an entry into the intersection maps and add an
              // intersection line.
              var _mesh1$getCellPoints = mesh1.getCellPoints(cellId1),
                  triPtIds1 = _mesh1$getCellPoints.cellPointIds;

              var triPts1 = [[], [], []];

              for (var _id = 0; _id < triPtIds1.length; _id++) {
                mesh1.getPoints().getPoint(triPtIds1[_id], triPts1[_id]);
              }

              var _vtkTriangle$intersec = vtkTriangle.intersectWithTriangle.apply(vtkTriangle, triPts0.concat(triPts1, [model.tolerance])),
                  intersect = _vtkTriangle$intersec.intersect,
                  coplanar = _vtkTriangle$intersec.coplanar,
                  outpt0 = _vtkTriangle$intersec.pt1,
                  outpt1 = _vtkTriangle$intersec.pt2;

              if (intersect && !coplanar) {
                var pointId = intersectionPoints.length / 3;
                intersectionPoints.push.apply(intersectionPoints, _toConsumableArray(outpt0).concat(_toConsumableArray(outpt1)));
                intersectionLines.push(2, pointOffset + pointId, pointOffset + pointId + 1);
              } // If actual intersection, add point and cell to edge, line,
              // and surface maps!

              /*
              if (coplanar) {
                // Coplanar triangle intersection is not handled.
                // This intersection will not be included in the output. TODO
                // vtkDebugMacro(<<"Coplanar");
                intersects = false;
                continue;
              }
              if (intersects)
              {
                vtkIdType lineId = info.intersectionLines->GetNumberOfCells();
                   vtkIdType ptId0, ptId1;
                int unique[2];
                unique[0] = pointMerger->InsertUniquePoint(outpt0, ptId0);
                unique[1] = pointMerger->InsertUniquePoint(outpt1, ptId1);
                   int addline = 1;
                if (ptId0 == ptId1)
                {
                  addline = 0;
                }
                   if (ptId0 == ptId1 && surfaceid[0] != surfaceid[1])
                {
                  intersectionSurfaceId->InsertValue(ptId0, 3);
                }
                else
                {
                  if (unique[0])
                  {
                    intersectionSurfaceId->InsertValue(ptId0, surfaceid[0]);
                  }
                  else
                  {
                    if (intersectionSurfaceId->GetValue(ptId0) != 3)
                    {
                      intersectionSurfaceId->InsertValue(ptId0, surfaceid[0]);
                    }
                  }
                  if (unique[1])
                  {
                    intersectionSurfaceId->InsertValue(ptId1, surfaceid[1]);
                  }
                  else
                  {
                    if (intersectionSurfaceId->GetValue(ptId1) != 3)
                    {
                      intersectionSurfaceId->InsertValue(ptId1, surfaceid[1]);
                    }
                  }
                }
                   info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));
                info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));
                info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));
                info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));
                   // Check to see if duplicate line. Line can only be a duplicate
                // line if both points are not unique and they don't
                // equal each other
                if (!unique[0] && !unique[1] && ptId0 != ptId1)
                {
                  vtkSmartPointer<vtkPolyData> lineTest = vtkSmartPointer<vtkPolyData>::New();
                  lineTest->SetPoints(pointMerger->GetPoints());
                  lineTest->SetLines(intersectionLines);
                  lineTest->BuildLinks();
                  int newLine = info->CheckLine(lineTest, ptId0, ptId1);
                  if (newLine == 0)
                  {
                    addline = 0;
                  }
                }
                if (addline)
                {
                  // If the line is new and does not consist of two identical
                  // points, add the line to the intersection and update
                  // mapping information
                  intersectionLines->InsertNextCell(2);
                  intersectionLines->InsertCellPoint(ptId0);
                  intersectionLines->InsertCellPoint(ptId1);
                     intersectionCellIds0->InsertNextValue(cellId0);
                  intersectionCellIds1->InsertNextValue(cellId1);
                     info->PointCellIds[0]->InsertValue(ptId0, cellId0);
                  info->PointCellIds[0]->InsertValue(ptId1, cellId0);
                  info->PointCellIds[1]->InsertValue(ptId0, cellId1);
                  info->PointCellIds[1]->InsertValue(ptId1, cellId1);
                     info->IntersectionMap[0]->insert(std::make_pair(cellId0, lineId));
                  info->IntersectionMap[1]->insert(std::make_pair(cellId1, lineId));
                     // Check which edges of cellId0 and cellId1 outpt0 and
                  // outpt1 are on, if any.
                  int isOnEdge = 0;
                  int m0p0 = 0, m0p1 = 0, m1p0 = 0, m1p1 = 0;
                  for (vtkIdType edgeId = 0; edgeId < 3; edgeId++)
                  {
                    isOnEdge = info->AddToPointEdgeMap(
                      0, ptId0, outpt0, mesh0, cellId0, edgeId, lineId, triPtIds0);
                    if (isOnEdge != -1)
                    {
                      m0p0++;
                    }
                    isOnEdge = info->AddToPointEdgeMap(
                      0, ptId1, outpt1, mesh0, cellId0, edgeId, lineId, triPtIds0);
                    if (isOnEdge != -1)
                    {
                      m0p1++;
                    }
                    isOnEdge = info->AddToPointEdgeMap(
                      1, ptId0, outpt0, mesh1, cellId1, edgeId, lineId, triPtIds1);
                    if (isOnEdge != -1)
                    {
                      m1p0++;
                    }
                    isOnEdge = info->AddToPointEdgeMap(
                      1, ptId1, outpt1, mesh1, cellId1, edgeId, lineId, triPtIds1);
                    if (isOnEdge != -1)
                    {
                      m1p1++;
                    }
                  }
                  // Special cases caught by tolerance and not from the Point
                  // Merger
                  if (m0p0 > 0 && m1p0 > 0)
                  {
                    intersectionSurfaceId->InsertValue(ptId0, 3);
                  }
                  if (m0p1 > 0 && m1p1 > 0)
                  {
                    intersectionSurfaceId->InsertValue(ptId1, 3);
                  }
                }
                // Add information about origin surface to std::maps for
                // checks later
                if (intersectionSurfaceId->GetValue(ptId0) == 1)
                {
                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));
                }
                else if (intersectionSurfaceId->GetValue(ptId0) == 2)
                {
                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));
                }
                else
                {
                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));
                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));
                }
                if (intersectionSurfaceId->GetValue(ptId1) == 1)
                {
                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));
                }
                else if (intersectionSurfaceId->GetValue(ptId1) == 2)
                {
                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));
                }
                else
                {
                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));
                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));
                }
              }
              */

            }
          }
        }
      }
    }

    if (intersectionPoints.length) {
      var points = vtkPoints.newInstance();
      points.setData(pushArray(info.intersectionLines.getPoints().getData(), intersectionPoints));
      info.intersectionLines.setPoints(points);
      var lines = vtkCellArray.newInstance();
      lines.setData(pushArray(info.intersectionLines.getLines().getData(), intersectionLines));
      info.intersectionLines.setLines(lines);
    }

    return intersectionLines.length / 3;
  };
  /**
   * Create polygonal representation for OBB tree at specified level. If
   * level < 0, then the leaf OBB nodes will be gathered. The aspect ratio (ar)
   * and line diameter (d) are used to control the building of the
   * representation. If a OBB node edge ratio's are greater than ar, then the
   * dimension of the OBB is collapsed (OBB->plane->line). A "line" OBB will be
   * represented either as two crossed polygons, or as a line, depending on
   * the relative diameter of the OBB compared to the diameter (d).
   * @param {Number} level Level of the representation
   * @returns {vtkPolyData}
   */


  publicAPI.generateRepresentation = function (level) {
    if (!model.tree) {
      vtkErrorMacro('No tree to generate representation for');
      return null;
    }

    var points = vtkPoints.newInstance();
    var polys = vtkCellArray.newInstance();
    generatePolygons(model.tree, 0, level, points, polys);
    var output = vtkPolyData.newInstance();
    output.setPoints(points);
    output.setPolys(polys);
    return output;
  };

  publicAPI.buildLocator = function () {
    if (model.dataset === null) {
      vtkErrorMacro("Can't build OBB tree - no data available!");
      return;
    }

    var numPts = model.dataset.getPoints().getNumberOfPoints();
    var numCells = model.dataset.getNumberOfCells();

    if (numPts < 1 || numCells < 1) {
      vtkErrorMacro("Can't build OBB tree - no data available!");
      return;
    }

    model.OBBCount = 0; // Initialize an array of numPts elements set to value 0

    model.insertedPoints = Array.from({
      length: numPts
    }, function (_) {
      return 0;
    });
    model.pointsList = [];
    var cellList = Array.from({
      length: numCells
    }, function (_, i) {
      return i;
    });
    model.tree = vtkOBBNode.newInstance();
    model.level = 0;
    buildTree(cellList, model.tree, 0);
    model.insertedPoints = [];
    model.pointsList = [];
    publicAPI.modified();
  };
} // ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  tolerance: 0.01,
  automatic: true,
  numberOfCellsPerNode: 32,
  dataset: null,
  tree: null,
  pointsList: [],
  insertedPoints: [],
  OBBCount: 0,
  level: 8,
  maxLevel: 8,
  retainCellLists: 1
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API

  macro.setGet(publicAPI, model, ['tolerance', 'automatic', 'numberOfCellsPerNode', 'dataset', 'tree', 'maxLevel', 'level', 'retainCellLists']); // Make this a VTK object

  macro.obj(publicAPI, model); // Object specific methods

  vtkOBBTree(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkOBBTree'); // ----------------------------------------------------------------------------

var vtkOBBTree$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkOBBTree$1 as default, extend, newInstance };
