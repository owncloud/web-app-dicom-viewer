import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import vtk from '../../vtk.js';
import macro from '../../macros.js';
import vtkDataArray from '../../Common/Core/DataArray.js';
import vtkPoints from '../../Common/Core/Points.js';
import { FieldDataTypes } from '../../Common/DataModel/DataSet/Constants.js';
import { AttributeTypes } from '../../Common/DataModel/DataSetAttributes/Constants.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------
// vtkCalculator methods
// ----------------------------------------------------------------------------

function vtkCalculator(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCalculator');

  publicAPI.setFormula = function (formula) {
    if (formula === model.formula) {
      return false;
    }

    model.formula = formula;
    publicAPI.modified();
    return true;
  };

  publicAPI.getFormula = function () {
    return model.formula;
  };

  publicAPI.augmentInputArrays = function (locn, arraysIn) {
    var arraysOut = arraysIn.slice(0); // shallow-copy the inputs
    // Make point coordinates available whenever the field-data is associated with
    // points or graph vertices:

    if (locn === FieldDataTypes.POINT || locn === FieldDataTypes.VERTEX) {
      arraysOut.push({
        location: FieldDataTypes.COORDINATE
      });
    } // TODO: Make cell connectivity available when field-data is associated with
    // cells or graph edges.


    return arraysOut;
  };

  publicAPI.createSimpleFormulaObject = function (locn, arrNames, resultName, singleValueFormula) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    return {
      getArrays: function getArrays() {
        return {
          input: publicAPI.augmentInputArrays(locn, arrNames.map(function (x) {
            return {
              location: locn,
              name: x
            };
          })),
          output: [{
            location: locn,
            name: resultName,
            attribute: 'outputAttributeType' in options ? options.outputAttributeType : AttributeTypes.SCALARS,
            numberOfComponents: 'numberOfOutputComponents' in options ? options.numberOfOutputComponents : 1
          }]
        };
      },
      evaluate: function evaluate(arraysIn, arraysOut) {
        var tuples = new Array(arraysIn.length);
        var arrayInAccessors = arraysIn.map(function (x, jj) {
          var nc = x.getNumberOfComponents();
          var rawData = x.getData();
          return nc === 1 ? function (ii) {
            return rawData[ii];
          } : function (ii) {
            return x.getTuple(ii, tuples[jj]);
          };
        });
        var arrayOut = arraysOut[0];
        var arrayOutRaw = arrayOut.getData();
        var nc = arrayOut.getNumberOfComponents();
        var tupleOut = new Array(nc);

        if (nc === 1) {
          arrayOutRaw.forEach(function (xxx, ii) {
            arrayOutRaw[ii] = singleValueFormula.apply(void 0, _toConsumableArray(arrayInAccessors.map(function (x) {
              return x(ii);
            })).concat([ii, tupleOut]));
          });
        } else {
          var nt = arrayOut.getNumberOfTuples();

          var _loop = function _loop(ii) {
            tupleOut = singleValueFormula.apply(void 0, _toConsumableArray(arrayInAccessors.map(function (x) {
              return x(ii);
            })).concat([ii, tupleOut]));
            arrayOut.setTuple(ii, tupleOut);
          };

          for (var ii = 0; ii < nt; ++ii) {
            _loop(ii);
          }
        }
      }
    };
  };

  publicAPI.setFormulaSimple = function (locn, arrNames, resultName, formula) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    return publicAPI.setFormula(publicAPI.createSimpleFormulaObject(locn, arrNames, resultName, formula, options));
  };

  publicAPI.prepareArrays = function (arraySpec, inData, outData) {
    var arraysIn = [];
    var arraysOut = [];
    arraySpec.input.forEach(function (spec) {
      if (spec.location === FieldDataTypes.COORDINATE) {
        arraysIn.push(inData.getPoints());
      } else {
        var fetchArrayContainer = [[FieldDataTypes.UNIFORM, function (x) {
          return x.getFieldData();
        }], [FieldDataTypes.POINT, function (x) {
          return x.getPointData();
        }], [FieldDataTypes.CELL, function (x) {
          return x.getCellData();
        }], [FieldDataTypes.VERTEX, function (x) {
          return x.getVertexData();
        }], [FieldDataTypes.EDGE, function (x) {
          return x.getEdgeData();
        }], [FieldDataTypes.ROW, function (x) {
          return x.getRowData();
        }]].reduce(function (result, value) {
          result[value[0]] = value[1];
          return result;
        }, {});
        var dsa = 'location' in spec && spec.location in fetchArrayContainer ? fetchArrayContainer[spec.location](inData) : null;

        if (dsa) {
          if (spec.name) {
            arraysIn.push(dsa.getArrayByName(spec.name));
          } else if ('index' in spec) {
            arraysIn.push(dsa.getArrayByIndex(spec.index));
          } else if ('attribute' in spec && spec.location !== FieldDataTypes.UNIFORM) {
            arraysIn.push(dsa.getActiveAttribute(spec.attribute));
          } else {
            vtkWarningMacro("No matching array for specifier \"".concat(JSON.stringify(spec), "\"."));
            arraysIn.push(null);
          }
        } else {
          vtkWarningMacro("Specifier \"".concat(JSON.stringify(spec), "\" did not provide a usable location."));
          arraysIn.push(null);
        }
      }
    });
    arraySpec.output.forEach(function (spec) {
      var fullSpec = _objectSpread({}, spec);

      var ncomp = 'numberOfComponents' in fullSpec ? fullSpec.numberOfComponents : 1;

      if (spec.location === FieldDataTypes.UNIFORM && 'tuples' in fullSpec) {
        fullSpec.size = ncomp * fullSpec.tuples;
      }

      if (spec.location === FieldDataTypes.COORDINATE) {
        var inPts = inData.getPoints();
        var pts = vtkPoints.newInstance({
          dataType: inPts.getDataType()
        });
        pts.setNumberOfPoints(inPts.getNumberOfPoints(), inPts.getNumberOfComponents());
        outData.setPoints(pts);
        arraysOut.push(pts);
      } else {
        var fetchArrayContainer = [[FieldDataTypes.UNIFORM, function (x) {
          return x.getFieldData();
        }, function (x, y) {
          return 'tuples' in y ? y.tuples : 0;
        }], [FieldDataTypes.POINT, function (x) {
          return x.getPointData();
        }, function (x) {
          return x.getPoints().getNumberOfPoints();
        }], [FieldDataTypes.CELL, function (x) {
          return x.getCellData();
        }, function (x) {
          return x.getNumberOfCells();
        }], [FieldDataTypes.VERTEX, function (x) {
          return x.getVertexData();
        }, function (x) {
          return x.getNumberOfVertices();
        }], [FieldDataTypes.EDGE, function (x) {
          return x.getEdgeData();
        }, function (x) {
          return x.getNumberOfEdges();
        }], [FieldDataTypes.ROW, function (x) {
          return x.getRowData();
        }, function (x) {
          return x.getNumberOfRows();
        }]].reduce(function (result, value) {
          result[value[0]] = {
            getData: value[1],
            getSize: value[2]
          };
          return result;
        }, {});
        var dsa = null;
        var tuples = 0;

        if ('location' in spec && spec.location in fetchArrayContainer) {
          dsa = fetchArrayContainer[spec.location].getData(outData);
          tuples = fetchArrayContainer[spec.location].getSize(inData, fullSpec);
        }

        if (tuples <= 0) {
          vtkWarningMacro("Output array size could not be determined for ".concat(JSON.stringify(spec), "."));
          arraysOut.push(null);
        } else if (dsa) {
          fullSpec.size = ncomp * tuples;
          var arrOut = vtkDataArray.newInstance(fullSpec);
          var arrIdx = dsa.addArray(arrOut);

          if ('attribute' in fullSpec && spec.location !== FieldDataTypes.UNIFORM) {
            dsa.setActiveAttributeByIndex(arrIdx, fullSpec.attribute);
          }

          arraysOut.push(arrOut);
        } else {
          vtkWarningMacro("Specifier \"".concat(JSON.stringify(spec), "\" did not provide a usable location."));
          arraysOut.push(null);
        }
      }
    });
    return {
      arraysIn: arraysIn,
      arraysOut: arraysOut
    };
  };

  publicAPI.requestData = function (inData, outData) {
    if (!model.formula) {
      return 0;
    }

    var arraySpec = model.formula.getArrays(inData);
    var newDataSet = vtk({
      vtkClass: inData[0].getClassName()
    });
    newDataSet.shallowCopy(inData[0]);
    outData[0] = newDataSet;
    var arrays = publicAPI.prepareArrays(arraySpec, inData[0], outData[0]);
    model.formula.evaluate(arrays.arraysIn, arrays.arraysOut);
    return 1;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  formula: {
    getArrays: function getArrays() {
      return {
        input: [],
        output: []
      };
    },
    evaluate: function evaluate() {
      return null;
    }
  }
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object

  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output

  macro.algo(publicAPI, model, 1, 1); // Object specific methods

  vtkCalculator(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkCalculator'); // ----------------------------------------------------------------------------

var vtkCalculator$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkCalculator$1 as default, extend, newInstance };
