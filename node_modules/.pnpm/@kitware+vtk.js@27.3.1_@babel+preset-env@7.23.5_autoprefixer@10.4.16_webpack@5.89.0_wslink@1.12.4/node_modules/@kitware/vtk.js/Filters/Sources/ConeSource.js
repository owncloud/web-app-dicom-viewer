import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';
import vtkPolyData from '../../Common/DataModel/PolyData.js';
import vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';

// vtkConeSource methods
// ----------------------------------------------------------------------------

function vtkConeSource(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkConeSource');

  function requestData(inData, outData) {
    var _vtkMatrixBuilder$bui;

    if (model.deleted) {
      return;
    }

    var dataset = outData[0];
    var angle = 2 * Math.PI / model.resolution;
    var xbot = -model.height / 2.0;
    var numberOfPoints = model.resolution + 1;
    var cellArraySize = 4 * model.resolution + 1 + model.resolution; // Points

    var pointIdx = 0;
    var points = macro.newTypedArray(model.pointType, numberOfPoints * 3); // Cells

    var cellLocation = 0;
    var polys = new Uint32Array(cellArraySize); // Add summit point

    points[0] = model.height / 2.0;
    points[1] = 0.0;
    points[2] = 0.0; // Create bottom cell

    if (model.capping) {
      polys[cellLocation++] = model.resolution;
    } // Add all points


    for (var i = 0; i < model.resolution; i++) {
      pointIdx++;
      points[pointIdx * 3 + 0] = xbot;
      points[pointIdx * 3 + 1] = model.radius * Math.cos(i * angle);
      points[pointIdx * 3 + 2] = model.radius * Math.sin(i * angle); // Add points to bottom cell in reverse order

      if (model.capping) {
        polys[model.resolution - cellLocation++ + 1] = pointIdx;
      }
    } // Add all triangle cells


    for (var _i = 0; _i < model.resolution; _i++) {
      polys[cellLocation++] = 3;
      polys[cellLocation++] = 0;
      polys[cellLocation++] = _i + 1;
      polys[cellLocation++] = _i + 2 > model.resolution ? 1 : _i + 2;
    } // Apply transformation to the points coordinates


    (_vtkMatrixBuilder$bui = vtkMatrixBuilder.buildFromRadian()).translate.apply(_vtkMatrixBuilder$bui, _toConsumableArray(model.center)).rotateFromDirections([1, 0, 0], model.direction).apply(points);

    dataset = vtkPolyData.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1); // Update output

    outData[0] = dataset;
  } // Expose methods


  publicAPI.requestData = requestData;
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  height: 1.0,
  radius: 0.5,
  resolution: 6,
  center: [0, 0, 0],
  direction: [1.0, 0.0, 0.0],
  capping: true,
  pointType: 'Float64Array'
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API

  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['height', 'radius', 'resolution', 'capping']);
  macro.setGetArray(publicAPI, model, ['center', 'direction'], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkConeSource(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkConeSource'); // ----------------------------------------------------------------------------

var vtkConeSource$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkConeSource$1 as default, extend, newInstance };
