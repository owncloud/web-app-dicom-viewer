import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';
import vtkImageData from '../../Common/DataModel/ImageData.js';
import vtkDataArray from '../../Common/Core/DataArray.js';

// Global methods
// ----------------------------------------------------------------------------

function generateCoordinates(origin, dimensions, spacing) {
  var coordinates = new Float64Array(dimensions[0] * dimensions[1] * dimensions[2] * 3);
  var offset = 0;

  for (var k = 0; k < dimensions[2]; k++) {
    var z = origin[2] + spacing[2] * k;

    for (var j = 0; j < dimensions[1]; j++) {
      var y = origin[1] + spacing[1] * j;

      for (var i = 0; i < dimensions[0]; i++) {
        var x = origin[0] + spacing[0] * i;
        coordinates[offset++] = x;
        coordinates[offset++] = y;
        coordinates[offset++] = z;
      }
    }
  }

  return coordinates;
} // ----------------------------------------------------------------------------
// vtkSLICSource methods
// ----------------------------------------------------------------------------


function vtkSLICSource(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkSLICSource');

  publicAPI.addCluster = function (centerX, centerY, centerZ, fnConst, fnDfDx, fnDfDy, fnDfDz) {
    var id = model.clusters.length;
    model.clusters.push(new Float64Array([centerX, centerY, centerZ, fnConst, fnDfDx, fnDfDy, fnDfDz]));
    publicAPI.modified();
    return id;
  };

  publicAPI.removeCluster = function (id) {
    model.clusters.splice(id, 1);
    publicAPI.modified();
  };

  publicAPI.removeAllClusters = function () {
    model.clusters = [];
    publicAPI.modified();
  };

  publicAPI.updateCluster = function (id, centerX, centerY, centerZ, fnConst, fnDfDx, fnDfDy, fnDfDz) {
    if (!model.clusters[id]) {
      model.clusters[id] = new Float64Array(7);
    }

    model.clusters[id][0] = centerX;
    model.clusters[id][1] = centerY;
    model.clusters[id][2] = centerZ;
    model.clusters[id][3] = fnConst;
    model.clusters[id][4] = fnDfDx;
    model.clusters[id][5] = fnDfDy;
    model.clusters[id][6] = fnDfDz;
    publicAPI.modified();
  };

  publicAPI.getNumberOfClusters = function () {
    return model.clusters.length;
  };

  publicAPI.requestData = function (inData, outData) {
    if (model.deleted) {
      return;
    }

    var dataSize = model.dimensions[0] * model.dimensions[1] * model.dimensions[2];
    var imageData = vtkImageData.newInstance();
    imageData.setSpacing.apply(imageData, _toConsumableArray(model.spacing));
    imageData.setExtent(0, model.dimensions[0] - 1, 0, model.dimensions[1] - 1, 0, model.dimensions[2] - 1);
    imageData.setOrigin.apply(imageData, _toConsumableArray(model.origin)); // Pixel centers

    var centers = generateCoordinates(model.origin, model.dimensions, model.spacing); // Fill clusterIdxValues

    var nbBytes = (model.clusters.length < 256 ? 8 : 0) || (model.clusters.length < 65536 ? 16 : 32);
    var clusterIdxValues = macro.newTypedArray("Uint".concat(nbBytes, "Array"), dataSize);

    var _loop = function _loop(i) {
      var clusterDistance = Number.MAX_VALUE;
      model.clusters.forEach(function (cluster, idx) {
        var dist = (cluster[0] - centers[i * 3]) * (cluster[0] - centers[i * 3]) + (cluster[1] - centers[i * 3 + 1]) * (cluster[1] - centers[i * 3 + 1]) + (cluster[2] - centers[i * 3 + 2]) * (cluster[2] - centers[i * 3 + 2]);

        if (dist < clusterDistance) {
          clusterDistance = dist;
          clusterIdxValues[i] = idx;
        }
      });
    };

    for (var i = 0; i < dataSize; i++) {
      _loop(i);
    }

    var clusters = vtkDataArray.newInstance({
      name: model.clusterArrayName,
      numberOfComponents: 1,
      values: clusterIdxValues
    });
    imageData.getPointData().addArray(clusters); // Fill scalarValues

    var scalarValues = new Float32Array(dataSize);

    for (var _i = 0; _i < dataSize; _i++) {
      var cluster = model.clusters[clusterIdxValues[_i]];
      scalarValues[_i] = cluster[3] + cluster[4] * (centers[_i * 3 + 0] - cluster[0]) + cluster[5] * (centers[_i * 3 + 1] - cluster[1]) + cluster[6] * (centers[_i * 3 + 2] - cluster[2]);
    }

    var scalars = vtkDataArray.newInstance({
      name: model.scalarArrayName,
      numberOfComponents: 1,
      values: scalarValues
    });
    imageData.getPointData().addArray(scalars); // Update output

    outData[0] = imageData;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  clusters: [],
  spacing: [1.0, 1.0, 1.0],
  origin: [0.0, 0.0, 0.0],
  dimensions: [10, 10, 10],
  clusterArrayName: 'cluster',
  scalarArrayName: 'field'
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API

  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['clusterArrayName', 'scalarArrayName']);
  macro.setGetArray(publicAPI, model, ['origin', 'spacing', 'dimensions'], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkSLICSource(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkSLICSource'); // ----------------------------------------------------------------------------

var vtkSLICSource$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkSLICSource$1 as default, extend, newInstance };
