import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';
import vtkDataArray from '../../Common/Core/DataArray.js';
import vtkPolyData from '../../Common/DataModel/PolyData.js';
import vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';

// vtkCylinderSource methods
// ----------------------------------------------------------------------------

function vtkCylinderSource(publicAPI, model) {
  // Set our classname
  model.classHierarchy.push('vtkCylinderSource');

  function requestData(inData, outData) {
    var _vtkMatrixBuilder$bui, _vtkMatrixBuilder$bui2;

    if (model.deleted) {
      return;
    }

    var dataset = outData[0];
    var angle = 2.0 * Math.PI / model.resolution;
    var numberOfPoints = 2 * model.resolution;
    var numberOfPolys = 5 * model.resolution;

    if (model.capping) {
      numberOfPoints = 4 * model.resolution;
      numberOfPolys = 7 * model.resolution + 2;
    } // Points


    var points = macro.newTypedArray(model.pointType, numberOfPoints * 3); // Cells

    var cellLocation = 0;
    var polys = new Uint32Array(numberOfPolys); // Normals

    var normalsData = new Float32Array(numberOfPoints * 3);
    var normals = vtkDataArray.newInstance({
      numberOfComponents: 3,
      values: normalsData,
      name: 'Normals'
    }); // Texture coords

    var tcData = new Float32Array(numberOfPoints * 2);
    var tcoords = vtkDataArray.newInstance({
      numberOfComponents: 2,
      values: tcData,
      name: 'TCoords'
    }); // Generate points for all sides

    var nbot = [0.0, 0.0, 0.0];
    var ntop = [0.0, 0.0, 0.0];
    var xbot = [0.0, 0.0, 0.0];
    var xtop = [0.0, 0.0, 0.0];
    var tcbot = [0.0, 0.0];
    var tctop = [0.0, 0.0];
    var otherRadius = model.otherRadius == null ? model.radius : model.otherRadius;

    for (var i = 0; i < model.resolution; i++) {
      // x coordinate
      nbot[0] = Math.cos(i * angle + model.initAngle);
      ntop[0] = nbot[0];
      xbot[0] = model.radius * nbot[0] + model.center[0];
      xtop[0] = xbot[0];
      tcbot[0] = Math.abs(2.0 * i / model.resolution - 1.0);
      tctop[0] = tcbot[0]; // y coordinate

      xbot[1] = 0.5 * model.height + model.center[1];
      xtop[1] = -0.5 * model.height + model.center[1];
      tcbot[1] = 0.0;
      tctop[1] = 1.0; // z coordinate

      nbot[2] = -Math.sin(i * angle + model.initAngle);
      ntop[2] = nbot[2];
      xbot[2] = otherRadius * nbot[2] + model.center[2];
      xtop[2] = xbot[2];
      var pointIdx = 2 * i;

      for (var j = 0; j < 3; j++) {
        normalsData[pointIdx * 3 + j] = nbot[j];
        normalsData[(pointIdx + 1) * 3 + j] = ntop[j];
        points[pointIdx * 3 + j] = xbot[j];
        points[(pointIdx + 1) * 3 + j] = xtop[j];

        if (j < 2) {
          tcData[pointIdx * 2 + j] = tcbot[j];
          tcData[(pointIdx + 1) * 2 + j] = tctop[j];
        }
      }
    } // Generate polygons for sides


    for (var _i = 0; _i < model.resolution; _i++) {
      polys[cellLocation++] = 4;
      polys[cellLocation++] = 2 * _i;
      polys[cellLocation++] = 2 * _i + 1;
      var pt = (2 * _i + 3) % (2 * model.resolution);
      polys[cellLocation++] = pt;
      polys[cellLocation++] = pt - 1;
    }

    if (model.capping) {
      // Generate points for top/bottom polygons
      for (var _i2 = 0; _i2 < model.resolution; _i2++) {
        // x coordinate
        xbot[0] = model.radius * Math.cos(_i2 * angle + model.initAngle);
        xtop[0] = xbot[0];
        tcbot[0] = xbot[0];
        tctop[0] = xbot[0];
        xbot[0] += model.center[0];
        xtop[0] += model.center[0]; // y coordinate

        nbot[1] = 1.0;
        ntop[1] = -1.0;
        xbot[1] = 0.5 * model.height + model.center[1];
        xtop[1] = -0.5 * model.height + model.center[1]; // z coordinate

        xbot[2] = -otherRadius * Math.sin(_i2 * angle + model.initAngle);
        xtop[2] = xbot[2];
        tcbot[1] = xbot[2];
        tctop[1] = xbot[2];
        xbot[2] += model.center[2];
        xtop[2] += model.center[2];
        var botIdx = 2 * model.resolution + _i2;
        var topIdx = 3 * model.resolution + model.resolution - _i2 - 1;

        for (var _j = 0; _j < 3; _j++) {
          normalsData[3 * botIdx + _j] = nbot[_j];
          normalsData[3 * topIdx + _j] = ntop[_j];
          points[3 * botIdx + _j] = xbot[_j];
          points[3 * topIdx + _j] = xtop[_j];

          if (_j < 2) {
            tcData[2 * botIdx + _j] = tcbot[_j];
            tcData[2 * topIdx + _j] = tctop[_j];
          }
        }
      } // Generate polygons for top/bottom


      polys[cellLocation++] = model.resolution;

      for (var _i3 = 0; _i3 < model.resolution; _i3++) {
        polys[cellLocation++] = 2 * model.resolution + _i3;
      }

      polys[cellLocation++] = model.resolution;

      for (var _i4 = 0; _i4 < model.resolution; _i4++) {
        polys[cellLocation++] = 3 * model.resolution + _i4;
      }
    } // Apply transformation to the points coordinates


    (_vtkMatrixBuilder$bui = (_vtkMatrixBuilder$bui2 = vtkMatrixBuilder.buildFromRadian()).translate.apply(_vtkMatrixBuilder$bui2, _toConsumableArray(model.center)).rotateFromDirections([0, 1, 0], model.direction)).translate.apply(_vtkMatrixBuilder$bui, _toConsumableArray(model.center.map(function (c) {
      return c * -1;
    }))).apply(points);

    dataset = vtkPolyData.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    dataset.getPointData().setNormals(normals);
    dataset.getPointData().setTCoords(tcoords); // Update output

    outData[0] = dataset;
  } // Expose methods


  publicAPI.requestData = requestData;
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  height: 1.0,
  initAngle: 0,
  radius: 1.0,
  resolution: 6,
  center: [0, 0, 0],
  direction: [0.0, 1.0, 0.0],
  capping: true,
  pointType: 'Float64Array'
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API

  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['height', 'initAngle', 'otherRadius', 'radius', 'resolution', 'capping']);
  macro.setGetArray(publicAPI, model, ['center', 'direction'], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkCylinderSource(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkCylinderSource'); // ----------------------------------------------------------------------------

var vtkCylinderSource$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkCylinderSource$1 as default, extend, newInstance };
