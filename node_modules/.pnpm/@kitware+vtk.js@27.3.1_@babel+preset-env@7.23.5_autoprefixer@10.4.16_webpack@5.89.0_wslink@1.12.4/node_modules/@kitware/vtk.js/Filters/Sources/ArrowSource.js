import macro from '../../macros.js';
import vtkAppendPolyData from '../General/AppendPolyData.js';
import vtkConeSource from './ConeSource.js';
import vtkCylinderSource from './CylinderSource.js';
import vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';

// vtkArrowSource methods
// ----------------------------------------------------------------------------

function vtkArrowSource(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkArrowSource');

  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }

    var cylinder = vtkCylinderSource.newInstance({
      capping: true
    });
    cylinder.setResolution(model.shaftResolution);
    cylinder.setRadius(model.shaftRadius);
    cylinder.setHeight(1.0 - model.tipLength);
    cylinder.setCenter(0, (1.0 - model.tipLength) * 0.5, 0.0);
    var cylinderPD = cylinder.getOutputData();
    var cylinderPts = cylinderPD.getPoints().getData();
    var cylinderNormals = cylinderPD.getPointData().getNormals().getData(); // Apply transformation to the cylinder

    vtkMatrixBuilder.buildFromDegree().rotateZ(-90).apply(cylinderPts).apply(cylinderNormals);
    var cone = vtkConeSource.newInstance();
    cone.setResolution(model.tipResolution);
    cone.setHeight(model.tipLength);
    cone.setRadius(model.tipRadius);
    var conePD = cone.getOutputData();
    var conePts = conePD.getPoints().getData(); // Apply transformation to the cone

    vtkMatrixBuilder.buildFromRadian().translate(1.0 - model.tipLength * 0.5, 0.0, 0.0).apply(conePts);
    var append = vtkAppendPolyData.newInstance();
    append.setInputData(cylinderPD);
    append.addInputData(conePD);
    var appendPD = append.getOutputData();
    var appendPts = appendPD.getPoints().getData(); // Center the arrow about [0, 0, 0]

    vtkMatrixBuilder.buildFromRadian().translate(-0.5 + model.tipLength * 0.5, 0.0, 0.0).apply(appendPts);

    if (model.invert) {
      // Apply transformation to the arrow
      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(-1, -1, -1).apply(appendPts); // Update output

      outData[0] = appendPD;
    } else {
      // Apply transformation to the arrow
      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(1, 1, 1).apply(appendPts); // Update output

      outData[0] = append.getOutputData();
    }
  } // Expose methods


  publicAPI.requestData = requestData;
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  tipResolution: 6,
  tipRadius: 0.1,
  tipLength: 0.35,
  shaftResolution: 6,
  shaftRadius: 0.03,
  invert: false,
  direction: [1.0, 0.0, 0.0],
  pointType: 'Float64Array'
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API

  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['tipResolution', 'tipRadius', 'tipLength', 'shaftResolution', 'shaftRadius', 'invert']);
  macro.setGetArray(publicAPI, model, ['direction'], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkArrowSource(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkArrowSource'); // ----------------------------------------------------------------------------

var vtkArrowSource$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkArrowSource$1 as default, extend, newInstance };
