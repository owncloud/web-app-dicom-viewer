import { vec3, mat4 } from 'gl-matrix';
import macro from '../../macros.js';
import vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';
import vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';
import { r as radiansFromDegrees, j as cross } from '../../Common/Core/Math/index.js';

// vtkMouseCameraAxisRotateManipulator methods
// ----------------------------------------------------------------------------

function vtkMouseCameraAxisRotateManipulator(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkMouseCameraAxisRotateManipulator');
  var negCameraDir = new Float64Array(3);
  var newCamPos = new Float64Array(3);
  var newFp = new Float64Array(3);
  var newViewUp = new Float64Array(3);
  var trans = new Float64Array(16);
  var rotation = new Float64Array(16);
  var v2 = new Float64Array(3);
  var centerNeg = new Float64Array(3);
  var negRotationAxis = new Float64Array(3);

  publicAPI.onButtonDown = function (interactor, renderer, position) {
    model.previousPosition = position;
  };

  publicAPI.onMouseMove = function (interactor, renderer, position) {
    if (!position) {
      return;
    }

    var camera = renderer.getActiveCamera();
    var cameraPos = camera.getPosition();
    var cameraFp = camera.getFocalPoint();
    var cameraViewUp = camera.getViewUp();
    var cameraDirection = camera.getDirectionOfProjection();
    vec3.negate(negCameraDir, cameraDirection);
    mat4.identity(trans);
    mat4.identity(rotation);
    var center = model.center,
        rotationFactor = model.rotationFactor,
        rotationAxis = model.rotationAxis;
    vec3.negate(negRotationAxis, rotationAxis);
    var dx = model.previousPosition.x - position.x;
    var dy = model.previousPosition.y - position.y;
    var size = interactor.getView().getViewportSize(renderer); // Azimuth

    var azimuthDelta = radiansFromDegrees(360.0 * dx / size[0] * rotationFactor);
    mat4.rotate(rotation, rotation, azimuthDelta, rotationAxis); // Elevation

    cross(cameraDirection, cameraViewUp, v2);
    var elevationDelta = radiansFromDegrees(-360.0 * dy / size[1] * rotationFactor); // angle of camera to rotation axis on the positive or negative half,
    // relative to the origin.

    var angleToPosHalf = Math.acos(vec3.dot(negCameraDir, rotationAxis));
    var angleToNegHalf = Math.acos(vec3.dot(negCameraDir, negRotationAxis)); // whether camera is in positive half of the rotation axis or neg half

    var inPosHalf = angleToPosHalf <= angleToNegHalf;
    var elevationToAxis = Math.min(angleToPosHalf, angleToNegHalf);

    if (model.useHalfAxis && !inPosHalf) {
      elevationDelta = Math.PI / 2 - angleToPosHalf;
    } else if (inPosHalf && elevationToAxis + elevationDelta < 0) {
      elevationDelta = -elevationToAxis; // } else if (!inPosHalf && elevationToAxis - elevationDelta < 0) {
    } else if (!inPosHalf && angleToPosHalf + elevationDelta > Math.PI) {
      elevationDelta = elevationToAxis;
    }

    mat4.rotate(rotation, rotation, elevationDelta, v2); // Translate from origin

    mat4.translate(trans, trans, center); // apply rotation

    mat4.multiply(trans, trans, rotation); // Translate to origin

    vec3.negate(centerNeg, center);
    mat4.translate(trans, trans, centerNeg); // Apply transformation to camera position, focal point, and view up

    vec3.transformMat4(newCamPos, cameraPos, trans);
    vec3.transformMat4(newFp, cameraFp, trans);
    vec3.transformMat4(newViewUp, cameraViewUp, rotation);
    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);
    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);
    camera.setViewUp(newViewUp);
    renderer.resetCameraClippingRange();

    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }

    model.previousPosition = position;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  rotationAxis: [0, 0, 1],
  useHalfAxis: true
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['rotationAxis', 'useHalfAxis']);
  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);
  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues); // Object specific methods

  vtkMouseCameraAxisRotateManipulator(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkMouseCameraAxisRotateManipulator'); // ----------------------------------------------------------------------------

var vtkMouseCameraAxisRotateManipulator$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkMouseCameraAxisRotateManipulator$1 as default, extend, newInstance };
