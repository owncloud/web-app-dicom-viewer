import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// vtkTimeStepBasedAnimationHandler methods
// ----------------------------------------------------------------------------

function vtkTimeStepBasedAnimationHandler(publicAPI, model) {
  publicAPI.setCurrentTimeStep = function (time) {
    if (!model.timeSteps || model.timeSteps.length === 0) {
      return;
    }

    if (model.timeSteps.includes(time)) {
      model.currentTimeStep = time;
    } else if (time <= model.timeSteps[0]) {
      model.currentTimeStep = model.timeSteps[0];
    } else {
      model.currentTimeStep = model.timeSteps.find(function (prevTime, index, array) {
        if (index === array.length - 1) {
          return true;
        }

        return time >= prevTime && time < array[index + 1];
      });
    }

    publicAPI.update();
  };

  publicAPI.setData = function (data) {
    model.data = data; // Refresh timesteps

    if (data.timeSteps) {
      model.timeSteps = data.timeSteps.map(function (timeStep) {
        return timeStep.time;
      });
      model.timeRange = [model.timeSteps[0], model.timeSteps[model.timeSteps.length - 1]];
      model.currentTimeStep = model.timeSteps[0];
    }
  };

  publicAPI.setScene = function (scene, originalMetadata, applySettings, renderer) {
    model.scene = scene;
    model.originalMetadata = originalMetadata;
    model.applySettings = applySettings;
    model.renderer = renderer;
  };

  publicAPI.setCameraParameters = function (params) {
    if (model.renderers) {
      model.renderers.forEach(function (renderer) {
        var camera = renderer.getActiveCamera();

        if (camera) {
          camera.set(params);
        }
      });
    }
  };

  publicAPI.setBackground = function (color) {
    if (model.renderers) {
      model.renderers.forEach(function (renderer) {
        renderer.setBackground(color);
      });
    }
  };

  publicAPI.update = function () {
    if (!model.data || !model.scene) {
      return;
    }

    var currentScene = model.data.timeSteps.find(function (scene) {
      return scene.time === model.currentTimeStep;
    });

    if (currentScene.camera) {
      var camera = _objectSpread({}, model.originalMetadata.camera);

      Object.assign(camera, currentScene.camera);
      publicAPI.setCameraParameters(camera);
    }

    if (currentScene.background) {
      publicAPI.setBackground(currentScene.background);
    }

    if (model.scene) {
      model.scene.forEach(function (sceneItem) {
        if (sceneItem.source.setUpdateTimeStep && sceneItem.source.getTimeSteps().includes(model.currentTimeStep)) {
          sceneItem.source.setUpdateTimeStep(model.currentTimeStep);
        }

        var id = sceneItem.id;

        if (currentScene[id]) {
          var settings = _objectSpread({}, sceneItem.defaultSettings);

          Object.assign(settings, currentScene[id]);
          model.applySettings(sceneItem, settings);
        }
      });
    }
  };

  publicAPI.addRenderer = function (renderer) {
    if (renderer && !model.renderers.includes(renderer)) {
      model.renderers.push(renderer);
    }
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  timeSteps: [0.0],
  timeRange: [0.0, 0.0],
  currentTimeStep: 0.0,
  scene: null,
  data: null,
  renderers: [],
  applySettings: null,
  originalMetadata: null
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API

  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ['applySettings', 'currentTimeStep', 'data', 'originalMetada', 'scene', 'timeRange', 'timeSteps']);
  macro.setGet(publicAPI, model, ['renderers']); // Object methods

  vtkTimeStepBasedAnimationHandler(publicAPI, model);
}
var newInstance = macro.newInstance(extend, 'vtkTimeStepBasedAnimationHandler'); // ----------------------------------------------------------------------------

var vtkTimeStepBasedAnimationHandler$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkTimeStepBasedAnimationHandler$1 as default, extend, newInstance };
