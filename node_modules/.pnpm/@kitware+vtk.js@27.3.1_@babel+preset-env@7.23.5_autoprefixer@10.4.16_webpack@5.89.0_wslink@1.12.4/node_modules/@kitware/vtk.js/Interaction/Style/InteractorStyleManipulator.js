import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkInteractorStyle from '../../Rendering/Core/InteractorStyle.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkDebugMacro = macro.vtkDebugMacro;
var States = vtkInteractorStyle.States; // ----------------------------------------------------------------------------
// Event Types
// ----------------------------------------------------------------------------

var START_INTERACTION_EVENT = {
  type: 'StartInteractionEvent'
};
var INTERACTION_EVENT = {
  type: 'InteractionEvent'
};
var END_INTERACTION_EVENT = {
  type: 'EndInteractionEvent'
}; // ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function translateCamera(renderer, rwi, toX, toY, fromX, fromY) {
  var cam = renderer.getActiveCamera();
  var viewFocus = cam.getFocalPoint();
  viewFocus = rwi.getInteractorStyle().computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
  var focalDepth = viewFocus[2];
  var newPickPoint = rwi.getInteractorStyle().computeDisplayToWorld(renderer, toX, toY, focalDepth);
  var oldPickPoint = rwi.getInteractorStyle().computeDisplayToWorld(renderer, fromX, fromY, focalDepth); // camera motion is reversed

  var motionVector = [oldPickPoint[0] - newPickPoint[0], oldPickPoint[1] - newPickPoint[1], oldPickPoint[2] - newPickPoint[2]];
  viewFocus = cam.getFocalPoint();
  var viewPoint = cam.getPosition();
  cam.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
  cam.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
}

function dollyToPosition(fact, position, renderer, rwi) {
  var cam = renderer.getActiveCamera();

  if (cam.getParallelProjection()) {
    // Zoom relatively to the cursor
    var view = rwi.getView();
    var aSize = view.getViewportSize(renderer);
    var viewport = renderer.getViewport();
    var viewSize = view.getSize();
    var w = aSize[0];
    var h = aSize[1];
    var x0 = w / 2;
    var y0 = h / 2;
    var x1 = position.x - viewport[0] * viewSize[0];
    var y1 = position.y - viewport[1] * viewSize[1];
    translateCamera(renderer, rwi, x0, y0, x1, y1);
    cam.setParallelScale(cam.getParallelScale() / fact);
    translateCamera(renderer, rwi, x1, y1, x0, y0);
  } else {
    // Zoom relatively to the cursor position
    // Move focal point to cursor position
    var viewFocus = cam.getFocalPoint();
    var norm = cam.getViewPlaneNormal();
    viewFocus = rwi.getInteractorStyle().computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    var newFp = rwi.getInteractorStyle().computeDisplayToWorld(renderer, position.x, position.y, viewFocus[2]);
    cam.setFocalPoint(newFp[0], newFp[1], newFp[2]); // Move camera in/out along projection direction

    cam.dolly(fact);
    renderer.resetCameraClippingRange(); // Find new focal point

    var newCameraPos = cam.getPosition();
    viewFocus = cam.getFocalPoint();
    var newPoint = [0, 0, 0];
    var t = norm[0] * (viewFocus[0] - newCameraPos[0]) + norm[1] * (viewFocus[1] - newCameraPos[1]) + norm[2] * (viewFocus[2] - newCameraPos[2]);
    t /= Math.pow(norm[0], 2) + Math.pow(norm[1], 2) + Math.pow(norm[2], 2);
    newPoint[0] = newCameraPos[0] + norm[0] * t;
    newPoint[1] = newCameraPos[1] + norm[1] * t;
    newPoint[2] = newCameraPos[2] + norm[2] * t;
    cam.setFocalPoint(newPoint[0], newPoint[1], newPoint[2]);
    renderer.resetCameraClippingRange();
  }
}

function dollyByFactor(interactor, renderer, factor) {
  if (Number.isNaN(factor)) {
    return;
  }

  var camera = renderer.getActiveCamera();

  if (camera.getParallelProjection()) {
    camera.setParallelScale(camera.getParallelScale() / factor);
  } else {
    camera.dolly(factor);
    renderer.resetCameraClippingRange();
  }

  if (interactor.getLightFollowCamera()) {
    renderer.updateLightsGeometryToFollowCamera();
  }
} // ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------


var STATIC = {
  dollyToPosition: dollyToPosition,
  translateCamera: translateCamera,
  dollyByFactor: dollyByFactor
}; // ----------------------------------------------------------------------------
// vtkInteractorStyleManipulator methods
// ----------------------------------------------------------------------------

function vtkInteractorStyleManipulator(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkInteractorStyleManipulator');
  model.mouseManipulators = [];
  model.keyboardManipulators = [];
  model.vrManipulators = [];
  model.gestureManipulators = [];
  model.currentManipulator = null;
  model.currentWheelManipulator = null;
  model.centerOfRotation = [0, 0, 0];
  model.rotationFactor = 1; //-------------------------------------------------------------------------

  publicAPI.removeAllManipulators = function () {
    publicAPI.removeAllMouseManipulators();
    publicAPI.removeAllKeyboardManipulators();
    publicAPI.removeAllVRManipulators();
    publicAPI.removeAllGestureManipulators();
  }; //-------------------------------------------------------------------------


  publicAPI.removeAllMouseManipulators = function () {
    model.mouseManipulators = [];
  }; //-------------------------------------------------------------------------


  publicAPI.removeAllKeyboardManipulators = function () {
    model.keyboardManipulators = [];
  }; //-------------------------------------------------------------------------


  publicAPI.removeAllVRManipulators = function () {
    model.vrManipulators = [];
  }; //-------------------------------------------------------------------------


  publicAPI.removeAllGestureManipulators = function () {
    model.gestureManipulators = [];
  }; //-------------------------------------------------------------------------


  var removeManipulator = function removeManipulator(manipulator, list) {
    var index = list.indexOf(manipulator);

    if (index === -1) {
      return false;
    }

    list.splice(index, 1);
    publicAPI.modified();
    return true;
  }; //-------------------------------------------------------------------------


  publicAPI.removeMouseManipulator = function (manipulator) {
    return removeManipulator(manipulator, model.mouseManipulators);
  }; //-------------------------------------------------------------------------


  publicAPI.removeKeyboardManipulator = function (manipulator) {
    return removeManipulator(manipulator, model.keyboardManipulators);
  }; //-------------------------------------------------------------------------


  publicAPI.removeVRManipulator = function (manipulator) {
    return removeManipulator(manipulator, model.vrManipulators);
  }; //-------------------------------------------------------------------------


  publicAPI.removeGestureManipulator = function (manipulator) {
    return removeManipulator(manipulator, model.gestureManipulators);
  }; //-------------------------------------------------------------------------


  var addManipulator = function addManipulator(manipulator, list) {
    var index = list.indexOf(manipulator);

    if (index !== -1) {
      return false;
    }

    list.push(manipulator);
    publicAPI.modified();
    return true;
  }; //-------------------------------------------------------------------------


  publicAPI.addMouseManipulator = function (manipulator) {
    return addManipulator(manipulator, model.mouseManipulators);
  }; //-------------------------------------------------------------------------


  publicAPI.addKeyboardManipulator = function (manipulator) {
    return addManipulator(manipulator, model.keyboardManipulators);
  }; //-------------------------------------------------------------------------


  publicAPI.addVRManipulator = function (manipulator) {
    return addManipulator(manipulator, model.vrManipulators);
  }; //-------------------------------------------------------------------------


  publicAPI.addGestureManipulator = function (manipulator) {
    return addManipulator(manipulator, model.gestureManipulators);
  }; //-------------------------------------------------------------------------


  publicAPI.getNumberOfMouseManipulators = function () {
    return model.mouseManipulators.length;
  }; //-------------------------------------------------------------------------


  publicAPI.getNumberOfKeyboardManipulators = function () {
    return model.keyboardManipulators.length;
  }; //-------------------------------------------------------------------------


  publicAPI.getNumberOfVRManipulators = function () {
    return model.vrManipulators.length;
  }; //-------------------------------------------------------------------------


  publicAPI.getNumberOfGestureManipulators = function () {
    return model.gestureManipulators.length;
  }; //-------------------------------------------------------------------------


  publicAPI.resetCurrentManipulator = function () {
    model.currentManipulator = null;
    model.currentWheelManipulator = null;
  }; //-------------------------------------------------------------------------
  // Mouse
  //-------------------------------------------------------------------------


  publicAPI.handleLeftButtonPress = function (callData) {
    model.previousPosition = callData.position;
    publicAPI.onButtonDown(1, callData);
  }; //-------------------------------------------------------------------------


  publicAPI.handleMiddleButtonPress = function (callData) {
    model.previousPosition = callData.position;
    publicAPI.onButtonDown(2, callData);
  }; //-------------------------------------------------------------------------


  publicAPI.handleRightButtonPress = function (callData) {
    model.previousPosition = callData.position;
    publicAPI.onButtonDown(3, callData);
  }; //-------------------------------------------------------------------------


  publicAPI.handleButton3D = function (ed) {
    if (!ed) {
      return;
    } // Look for a matching 3D camera interactor.


    model.currentManipulator = publicAPI.findVRManipulator(ed.device, ed.input, ed.pressed);

    if (model.currentManipulator) {
      model.currentManipulator.onButton3D(publicAPI, ed.pokedRenderer, model.state, ed.device, ed.input, ed.pressed);

      if (ed.pressed) {
        publicAPI.startCameraPose();
      } else {
        publicAPI.endCameraPose();
      }
    } else {
      vtkDebugMacro('No manipulator found');
    }
  }; //-------------------------------------------------------------------------


  publicAPI.handleMove3D = function (ed) {
    if (model.currentManipulator && model.state === States.IS_CAMERA_POSE) {
      model.currentManipulator.onMove3D(publicAPI, ed.pokedRenderer, model.state, ed);
    }
  }; //-------------------------------------------------------------------------


  publicAPI.onButtonDown = function (button, callData) {
    // Must not be processing an interaction to start another.
    if (model.currentManipulator) {
      return;
    } // Look for a matching camera interactor.


    model.currentManipulator = publicAPI.findMouseManipulator(button, callData.shiftKey, callData.controlKey, callData.altKey);

    if (model.currentManipulator) {
      if (model.currentManipulator.setCenter) {
        model.currentManipulator.setCenter(model.centerOfRotation);
      }

      if (model.currentManipulator.setRotationFactor) {
        model.currentManipulator.setRotationFactor(model.rotationFactor);
      }

      model.currentManipulator.startInteraction();
      model.currentManipulator.onButtonDown(model._interactor, callData.pokedRenderer, callData.position);

      model._interactor.requestAnimation(publicAPI.onButtonDown);

      publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
    } else {
      vtkDebugMacro('No manipulator found');
    }
  }; //-------------------------------------------------------------------------


  publicAPI.findMouseManipulator = function (button, shift, control, alt) {
    // Look for a matching camera manipulator
    var manipulator = null;
    var count = model.mouseManipulators.length;

    while (count--) {
      var manip = model.mouseManipulators[count];

      if (manip && manip.getButton() === button && manip.getShift() === shift && manip.getControl() === control && manip.getAlt() === alt && manip.isDragEnabled()) {
        manipulator = manip;
      }
    }

    return manipulator;
  }; //-------------------------------------------------------------------------


  publicAPI.findVRManipulator = function (device, input) {
    // Look for a matching camera manipulator
    var manipulator = null;
    var count = model.vrManipulators.length;

    while (count--) {
      var manip = model.vrManipulators[count];

      if (manip && manip.getDevice() === device && manip.getInput() === input) {
        manipulator = manip;
      }
    }

    return manipulator;
  }; //-------------------------------------------------------------------------


  publicAPI.handleLeftButtonRelease = function () {
    publicAPI.onButtonUp(1);
  }; //-------------------------------------------------------------------------


  publicAPI.handleMiddleButtonRelease = function () {
    publicAPI.onButtonUp(2);
  }; //-------------------------------------------------------------------------


  publicAPI.handleRightButtonRelease = function () {
    publicAPI.onButtonUp(3);
  }; //-------------------------------------------------------------------------


  publicAPI.onButtonUp = function (button) {
    if (!model.currentManipulator) {
      return;
    }

    if (model.currentManipulator.getButton && model.currentManipulator.getButton() === button) {
      model.currentManipulator.onButtonUp(model._interactor);
      model.currentManipulator.endInteraction();
      model.currentManipulator = null;

      model._interactor.cancelAnimation(publicAPI.onButtonDown);

      publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
    }
  }; //-------------------------------------------------------------------------


  publicAPI.handleStartMouseWheel = function (callData) {
    // Must not be processing a wheel interaction to start another.
    if (model.currentWheelManipulator) {
      return;
    }

    var manipulator = null;
    var count = model.mouseManipulators.length;

    while (count--) {
      var manip = model.mouseManipulators[count];

      if (manip && manip.isScrollEnabled() && manip.getShift() === callData.shiftKey && manip.getControl() === callData.controlKey && manip.getAlt() === callData.altKey) {
        manipulator = manip;
      }
    }

    if (manipulator) {
      model.currentWheelManipulator = manipulator;
      model.currentWheelManipulator.onStartScroll(model._interactor, callData.pokedRenderer, callData.spinY);
      model.currentWheelManipulator.startInteraction();

      model._interactor.requestAnimation(publicAPI.handleStartMouseWheel);

      publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
    } else {
      vtkDebugMacro('No manipulator found');
    }
  }; //-------------------------------------------------------------------------


  publicAPI.handleEndMouseWheel = function () {
    if (!model.currentWheelManipulator) {
      return;
    }

    if (model.currentWheelManipulator.onEndScroll) {
      model.currentWheelManipulator.onEndScroll(model._interactor);
      model.currentWheelManipulator.endInteraction();
      model.currentWheelManipulator = null;

      model._interactor.cancelAnimation(publicAPI.handleStartMouseWheel);

      publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
    }
  }; //-------------------------------------------------------------------------


  publicAPI.handleMouseWheel = function (callData) {
    if (model.currentWheelManipulator && model.currentWheelManipulator.onScroll) {
      model.currentWheelManipulator.onScroll(model._interactor, callData.pokedRenderer, callData.spinY, model.cachedMousePosition);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  }; //-------------------------------------------------------------------------


  publicAPI.handleMouseMove = function (callData) {
    model.cachedMousePosition = callData.position;

    if (model.currentManipulator && model.currentManipulator.onMouseMove) {
      model.currentManipulator.onMouseMove(model._interactor, callData.pokedRenderer, callData.position);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  }; //-------------------------------------------------------------------------
  // Keyboard
  //-------------------------------------------------------------------------


  publicAPI.handleKeyPress = function (callData) {
    model.keyboardManipulators.filter(function (m) {
      return m.onKeyPress;
    }).forEach(function (manipulator) {
      manipulator.onKeyPress(model._interactor, callData.pokedRenderer, callData.key);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    });
  }; //-------------------------------------------------------------------------


  publicAPI.handleKeyDown = function (callData) {
    model.keyboardManipulators.filter(function (m) {
      return m.onKeyDown;
    }).forEach(function (manipulator) {
      manipulator.onKeyDown(model._interactor, callData.pokedRenderer, callData.key);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    });
  }; //-------------------------------------------------------------------------


  publicAPI.handleKeyUp = function (callData) {
    model.keyboardManipulators.filter(function (m) {
      return m.onKeyUp;
    }).forEach(function (manipulator) {
      manipulator.onKeyUp(model._interactor, callData.pokedRenderer, callData.key);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    });
  }; //-------------------------------------------------------------------------
  // Gesture
  //-------------------------------------------------------------------------


  publicAPI.handleStartPinch = function (callData) {
    publicAPI.startDolly();
    var count = model.gestureManipulators.length;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isPinchEnabled()) {
        manipulator.onStartPinch(model._interactor, callData.scale);
        manipulator.startInteraction();
      }
    }

    model._interactor.requestAnimation(publicAPI.handleStartPinch);

    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
  }; //--------------------------------------------------------------------------


  publicAPI.handleEndPinch = function () {
    publicAPI.endDolly();
    var count = model.gestureManipulators.length;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isPinchEnabled()) {
        manipulator.onEndPinch(model._interactor);
        manipulator.endInteraction();
      }
    }

    model._interactor.cancelAnimation(publicAPI.handleStartPinch);

    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
  }; //----------------------------------------------------------------------------


  publicAPI.handleStartRotate = function (callData) {
    publicAPI.startRotate();
    var count = model.gestureManipulators.length;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isRotateEnabled()) {
        manipulator.onStartRotate(model._interactor, callData.rotation);
        manipulator.startInteraction();
      }
    }

    model._interactor.requestAnimation(publicAPI.handleStartRotate);

    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
  }; //--------------------------------------------------------------------------


  publicAPI.handleEndRotate = function () {
    publicAPI.endRotate();
    var count = model.gestureManipulators.length;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isRotateEnabled()) {
        manipulator.onEndRotate(model._interactor);
        manipulator.endInteraction();
      }
    }

    model._interactor.cancelAnimation(publicAPI.handleStartRotate);

    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
  }; //----------------------------------------------------------------------------


  publicAPI.handleStartPan = function (callData) {
    publicAPI.startPan();
    var count = model.gestureManipulators.length;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isPanEnabled()) {
        manipulator.onStartPan(model._interactor, callData.translation);
        manipulator.startInteraction();
      }
    }

    model._interactor.requestAnimation(publicAPI.handleStartPan);

    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
  }; //--------------------------------------------------------------------------


  publicAPI.handleEndPan = function () {
    publicAPI.endPan();
    var count = model.gestureManipulators.length;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isPanEnabled()) {
        manipulator.onEndPan(model._interactor);
        manipulator.endInteraction();
      }
    }

    model._interactor.cancelAnimation(publicAPI.handleStartPan);

    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
  }; //----------------------------------------------------------------------------


  publicAPI.handlePinch = function (callData) {
    var count = model.gestureManipulators.length;
    var actionCount = 0;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isPinchEnabled()) {
        manipulator.onPinch(model._interactor, callData.pokedRenderer, callData.scale);
        actionCount++;
      }
    }

    if (actionCount) {
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  }; //----------------------------------------------------------------------------


  publicAPI.handlePan = function (callData) {
    var count = model.gestureManipulators.length;
    var actionCount = 0;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isPanEnabled()) {
        manipulator.onPan(model._interactor, callData.pokedRenderer, callData.translation);
        actionCount++;
      }
    }

    if (actionCount) {
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  }; //----------------------------------------------------------------------------


  publicAPI.handleRotate = function (callData) {
    var count = model.gestureManipulators.length;
    var actionCount = 0;

    while (count--) {
      var manipulator = model.gestureManipulators[count];

      if (manipulator && manipulator.isRotateEnabled()) {
        manipulator.onRotate(model._interactor, callData.pokedRenderer, callData.rotation);
        actionCount++;
      }
    }

    if (actionCount) {
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  cachedMousePosition: null,
  currentManipulator: null,
  currentWheelManipulator: null,
  // mouseManipulators: null,
  // keyboardManipulators: null,
  // vrManipulators: null,
  // gestureManipulators: null,
  centerOfRotation: [0, 0, 0],
  rotationFactor: 1
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkInteractorStyle.extend(publicAPI, model, initialValues); // Create get-set macros

  macro.setGet(publicAPI, model, ['rotationFactor']);
  macro.get(publicAPI, model, ['mouseManipulators', 'keyboardManipulators', 'vrManipulators', 'gestureManipulators']);
  macro.setGetArray(publicAPI, model, ['centerOfRotation'], 3); // Object specific methods

  vtkInteractorStyleManipulator(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkInteractorStyleManipulator'); // ----------------------------------------------------------------------------

var vtkInteractorStyleManipulator$1 = _objectSpread({
  newInstance: newInstance,
  extend: extend
}, STATIC);

export { STATIC, vtkInteractorStyleManipulator$1 as default, extend, newInstance };
