import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkInteractorObserver from './InteractorObserver.js';
import vtkInteractorStyleConstants from './InteractorStyle/Constants.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var States = vtkInteractorStyleConstants.States; // ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
// Add module-level functions or api that you want to expose statically via
// the next section...

var stateNames = {
  Rotate: States.IS_ROTATE,
  Pan: States.IS_PAN,
  Spin: States.IS_SPIN,
  Dolly: States.IS_DOLLY,
  CameraPose: States.IS_CAMERA_POSE,
  WindowLevel: States.IS_WINDOW_LEVEL,
  Slice: States.IS_SLICE
}; // ----------------------------------------------------------------------------
// vtkInteractorStyle methods
// ----------------------------------------------------------------------------

function vtkInteractorStyle(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkInteractorStyle'); // Public API methods
  // create bunch of Start/EndState methods

  Object.keys(stateNames).forEach(function (key) {
    macro.event(publicAPI, model, "Start".concat(key, "Event"));

    publicAPI["start".concat(key)] = function () {
      if (model.state !== States.IS_NONE) {
        return;
      }

      model.state = stateNames[key];

      model._interactor.requestAnimation(publicAPI);

      publicAPI.invokeStartInteractionEvent({
        type: 'StartInteractionEvent'
      });
      publicAPI["invokeStart".concat(key, "Event")]({
        type: "Start".concat(key, "Event")
      });
    };

    macro.event(publicAPI, model, "End".concat(key, "Event"));

    publicAPI["end".concat(key)] = function () {
      if (model.state !== stateNames[key]) {
        return;
      }

      model.state = States.IS_NONE;

      model._interactor.cancelAnimation(publicAPI);

      publicAPI.invokeEndInteractionEvent({
        type: 'EndInteractionEvent'
      });
      publicAPI["invokeEnd".concat(key, "Event")]({
        type: "End".concat(key, "Event")
      });

      model._interactor.render();
    };
  }); //----------------------------------------------------------------------------

  publicAPI.handleKeyPress = function (callData) {
    var rwi = model._interactor;
    var ac = null;

    switch (callData.key) {
      case 'r':
      case 'R':
        callData.pokedRenderer.resetCamera();
        rwi.render();
        break;

      case 'w':
      case 'W':
        ac = callData.pokedRenderer.getActors();
        ac.forEach(function (anActor) {
          var prop = anActor.getProperty();

          if (prop.setRepresentationToWireframe) {
            prop.setRepresentationToWireframe();
          }
        });
        rwi.render();
        break;

      case 's':
      case 'S':
        ac = callData.pokedRenderer.getActors();
        ac.forEach(function (anActor) {
          var prop = anActor.getProperty();

          if (prop.setRepresentationToSurface) {
            prop.setRepresentationToSurface();
          }
        });
        rwi.render();
        break;

      case 'v':
      case 'V':
        ac = callData.pokedRenderer.getActors();
        ac.forEach(function (anActor) {
          var prop = anActor.getProperty();

          if (prop.setRepresentationToPoints) {
            prop.setRepresentationToPoints();
          }
        });
        rwi.render();
        break;
    }
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  state: States.IS_NONE,
  handleObservers: 1,
  autoAdjustCameraClippingRange: 1
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkInteractorObserver.extend(publicAPI, model, initialValues); // Object specific methods

  vtkInteractorStyle(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkInteractorStyle'); // ----------------------------------------------------------------------------

var vtkInteractorStyle$1 = _objectSpread({
  newInstance: newInstance,
  extend: extend
}, vtkInteractorStyleConstants);

export { vtkInteractorStyle$1 as default, extend, newInstance };
