import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkAbstractImageMapper from './AbstractImageMapper.js';
import vtkImageMapper from './ImageMapper.js';
import { N as createUninitializedBounds } from '../../Common/Core/Math/index.js';
import { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';
import CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI,
    otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods;
var vtkErrorMacro = macro.vtkErrorMacro,
    vtkWarningMacro = macro.vtkWarningMacro;
var SlicingMode = vtkImageMapper.SlicingMode; // ----------------------------------------------------------------------------
// vtkImageArrayMapper methods
// ----------------------------------------------------------------------------

function vtkImageArrayMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageArrayMapper'); //------------------
  // Private functions

  var _computeSliceToSubSliceMap = function _computeSliceToSubSliceMap() {
    var inputCollection = publicAPI.getInputData();

    if (!inputCollection || inputCollection.empty()) {
      // clear the map
      if (model.sliceToSubSliceMap.length !== 0) {
        model.sliceToSubSliceMap.length = 0;
        publicAPI.modified();
      }

      return;
    }

    if (model.sliceToSubSliceMap.length === 0 || inputCollection.getMTime() > publicAPI.getMTime()) {
      var perImageMap = inputCollection.map(function (image, index) {
        var dim = image.getDimensions();
        var out = new Array(dim[model.slicingMode]);

        for (var i = 0; i < out.length; ++i) {
          out[i] = {
            imageIndex: index,
            subSlice: i
          };
        }

        return out;
      });
      model.sliceToSubSliceMap = perImageMap.flat();
      publicAPI.modified();
    }
  };

  var _superSetInputData = publicAPI.setInputData;
  var _superSetInputConnection = publicAPI.setInputConnection; //------------------
  // Public functions

  publicAPI.setInputData = function (inputData) {
    _superSetInputData(inputData);

    _computeSliceToSubSliceMap();
  };

  publicAPI.setInputConnection = function (outputPort) {
    var port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _superSetInputConnection(outputPort, port);

    _computeSliceToSubSliceMap();
  };

  publicAPI.getImage = function () {
    var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publicAPI.getSlice();
    var inputCollection = publicAPI.getInputData();

    if (!inputCollection) {
      vtkWarningMacro('No input set.');
    } else if (slice < 0 || slice >= publicAPI.getTotalSlices()) {
      vtkWarningMacro('Invalid slice number.');
    } else {
      _computeSliceToSubSliceMap();

      return inputCollection.getItem(model.sliceToSubSliceMap[slice].imageIndex);
    }

    return null;
  };

  publicAPI.getBounds = function () {
    var image = publicAPI.getCurrentImage();

    if (!image) {
      return createUninitializedBounds();
    }

    if (!model.useCustomExtents) {
      return image.getBounds();
    }

    var ex = model.customDisplayExtent.slice(); // use sub-slice of the current image,
    // which is the k-coordinate.

    var nSlice = publicAPI.getSubSlice();
    ex[4] = nSlice;
    ex[5] = nSlice;
    return image.extentToBounds(ex);
  };

  publicAPI.getBoundsForSlice = function () {
    var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publicAPI.getSlice();
    var halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var image = publicAPI.getImage(slice);

    if (!image) {
      return createUninitializedBounds();
    }

    var extent = image.getSpatialExtent();
    var nSlice = publicAPI.getSubSlice(slice);
    extent[4] = nSlice - halfThickness;
    extent[5] = nSlice + halfThickness;
    return image.extentToBounds(extent);
  };

  publicAPI.getClosestIJKAxis = function () {
    return {
      ijkMode: model.slicingMode,
      flip: false
    };
  };

  publicAPI.computeTotalSlices = function () {
    var inputCollection = publicAPI.getInputData();
    var collectionLength = inputCollection.getNumberOfItems();
    var slicesCount = 0;

    for (var i = 0; i < collectionLength; ++i) {
      var image = inputCollection.getItem(i);

      if (image) {
        slicesCount += image.getDimensions()[model.slicingMode];
      }
    }

    return slicesCount;
  };

  publicAPI.getTotalSlices = function () {
    _computeSliceToSubSliceMap();

    return model.sliceToSubSliceMap.length;
  }; // set slice number in terms of imageIndex and subSlice number.


  publicAPI.setSlice = function (slice) {
    var inputCollection = publicAPI.getInputData();

    if (!inputCollection) {
      // No input is set
      vtkWarningMacro('No input set.');
      return;
    }

    var totalSlices = publicAPI.getTotalSlices();

    if (slice >= 0 && slice < totalSlices) {
      model.slice = slice;
      publicAPI.modified();
    } else {
      vtkErrorMacro("Slice number out of range. Acceptable range is: [0, ".concat(totalSlices > 0 ? totalSlices - 1 : 0, "]slice <= totalSlices"));
    }
  };

  publicAPI.computeSlice = function (imageIndex, subSlice) {
    _computeSliceToSubSliceMap();

    return model.sliceToSubSliceMap.findIndex(function (x) {
      return x.imageIndex === imageIndex && x.subSlice === subSlice;
    });
  };

  publicAPI.getImageIndex = function () {
    var _model$sliceToSubSlic;

    var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publicAPI.getSlice();

    _computeSliceToSubSliceMap();

    return (_model$sliceToSubSlic = model.sliceToSubSliceMap[slice]) === null || _model$sliceToSubSlic === void 0 ? void 0 : _model$sliceToSubSlic.imageIndex;
  };

  publicAPI.getSubSlice = function () {
    var _model$sliceToSubSlic2;

    var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publicAPI.getSlice();

    _computeSliceToSubSliceMap();

    return (_model$sliceToSubSlic2 = model.sliceToSubSliceMap[slice]) === null || _model$sliceToSubSlic2 === void 0 ? void 0 : _model$sliceToSubSlic2.subSlice;
  };

  publicAPI.getCurrentImage = function () {
    return publicAPI.getImage(publicAPI.getSlice());
  };

  publicAPI.intersectWithLineForPointPicking = function (p1, p2) {
    return intersectWithLineForPointPicking(p1, p2, publicAPI);
  };

  publicAPI.intersectWithLineForCellPicking = function (p1, p2) {
    return intersectWithLineForCellPicking(p1, p2, publicAPI);
  };
} // ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  slicingMode: SlicingMode.K,
  sliceToSubSliceMap: []
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API

  vtkAbstractImageMapper.extend(publicAPI, model, initialValues); // Build VTK API

  macro.get(publicAPI, model, ['slicingMode']);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods

  vtkImageArrayMapper(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkImageArrayMapper'); // ----------------------------------------------------------------------------

var index = _objectSpread(_objectSpread({
  newInstance: newInstance,
  extend: extend
}, staticOffsetAPI), otherStaticMethods);

export { index as default, extend, newInstance };
