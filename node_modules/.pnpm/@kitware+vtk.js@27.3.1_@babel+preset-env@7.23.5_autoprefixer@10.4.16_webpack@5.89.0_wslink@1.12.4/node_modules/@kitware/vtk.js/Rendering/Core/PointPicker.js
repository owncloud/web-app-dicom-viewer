import macro from '../../macros.js';
import { d as dot } from '../../Common/Core/Math/index.js';
import vtkPicker from './Picker.js';

var vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------
// vtkPointPicker methods
// ----------------------------------------------------------------------------

function vtkPointPicker(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPointPicker');

  publicAPI.intersectWithLine = function (p1, p2, tol, mapper) {
    var tMin = Number.MAX_VALUE;

    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {
      var pickData = mapper.intersectWithLineForPointPicking(p1, p2);

      if (pickData) {
        tMin = pickData.t;
        model.pointIJK = pickData.ijk;
      }
    } else if (mapper.isA('vtkMapper')) {
      tMin = publicAPI.intersectActorWithLine(p1, p2, tol, mapper);
    }

    return tMin;
  };

  publicAPI.intersectActorWithLine = function (p1, p2, tol, mapper) {
    // Get dataset
    var input = mapper.getInputData(); // Determine appropriate info

    var ptId = 0;
    var numPts = input.getPoints().getNumberOfPoints();

    if (numPts <= ptId) {
      return 2.0;
    }

    var ray = [];

    for (var i = 0; i < 3; i++) {
      ray[i] = p2[i] - p1[i];
    }

    var rayFactor = dot(ray, ray);

    if (rayFactor === 0.0) {
      vtkErrorMacro('Cannot process points');
      return 2.0;
    }

    var t;
    var minPtId = -1;
    var tMin = Number.MAX_VALUE;
    var minPtDist = Number.MAX_VALUE;
    var projXYZ = [];
    var x = [];
    var points = input.getPoints();

    if (model.useCells) {
      var cellData = input.getPolys().getData();
      var nbPointsPerCell = cellData[0];
      var nbCells = input.getPolys().getNumberOfCells();

      for (var cellID = 0; cellID < nbCells; cellID++) {
        var firstPointIndex = cellID * nbPointsPerCell + 1;
        var lastPointIndex = firstPointIndex + nbPointsPerCell;

        for (var pointIndex = firstPointIndex; pointIndex < lastPointIndex; pointIndex++) {
          var pointDataIndex = cellData[pointIndex];
          points.getPoint(pointDataIndex, x);
          t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor; // If we find a point closer than we currently have, see whether it
          // lies within the pick tolerance and clipping planes. We keep track
          // of the point closest to the line (use a fudge factor for points
          // nearly the same distance away.)

          if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {
            var maxDist = 0.0;

            for (var _i = 0; _i < 3; _i++) {
              projXYZ[_i] = p1[_i] + t * ray[_i];
              var dist = Math.abs(x[_i] - projXYZ[_i]);

              if (dist > maxDist) {
                maxDist = dist;
              }
            } // end for i


            if (maxDist <= tol && maxDist < minPtDist) {
              // within tolerance
              minPtId = ptId;
              minPtDist = maxDist;
              tMin = t;
            }
          }
        } // end for pointIndex

      } // end for cellID

    } else {
      // end if model.useCells
      for (ptId = 0; ptId < numPts; ptId++) {
        points.getPoint(ptId, x);
        t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor; // If we find a point closer than we currently have, see whether it
        // lies within the pick tolerance and clipping planes. We keep track
        // of the point closest to the line (use a fudge factor for points
        // nearly the same distance away.)

        if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {
          var _maxDist = 0.0;

          for (var _i2 = 0; _i2 < 3; _i2++) {
            projXYZ[_i2] = p1[_i2] + t * ray[_i2];

            var _dist = Math.abs(x[_i2] - projXYZ[_i2]);

            if (_dist > _maxDist) {
              _maxDist = _dist;
            }
          } // end for i


          if (_maxDist <= tol && _maxDist < minPtDist) {
            // within tolerance
            minPtId = ptId;
            minPtDist = _maxDist;
            tMin = t;
          }
        }
      }
    }

    model.pointId = minPtId;
    return tMin;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  pointId: -1,
  pointIJK: [],
  useCells: false
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkPicker.extend(publicAPI, model, initialValues);
  macro.getArray(publicAPI, model, ['pointIJK']);
  macro.get(publicAPI, model, ['pointId']);
  macro.setGet(publicAPI, model, ['useCells']);
  vtkPointPicker(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkPointPicker'); // ----------------------------------------------------------------------------

var vtkPointPicker$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkPointPicker$1 as default, extend, newInstance };
