import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { newInstance as newInstance$1, setGet, vtkErrorMacro as vtkErrorMacro$1 } from '../../../macros.js';
import vtkOpenGLPolyDataMapper from '../PolyDataMapper.js';
import vtkShaderProgram from '../ShaderProgram.js';
import vtkOpenGLSurfaceLICInterface from './SurfaceLICInterface.js';
import vtkSurfaceLICInterface from '../../Core/SurfaceLICInterface.js';
import { registerOverride } from '../ViewNodeFactory.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------
// vtkOpenGLSurfaceLICMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLSurfaceLICMapper(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLSurfaceLICMapper');

  var superClass = _objectSpread({}, publicAPI);

  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {
    return model.rebuildLICShaders || superClass.getNeedToRebuildShaders(cellBO, ren, actor);
  };

  publicAPI.replaceShaderValues = function (shaders, ren, actor) {
    var prevComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity'); // add some code to handle the LIC vectors and mask

    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    var array = model.renderable.getInputArrayToProcess(0);

    if (array && model.canDrawLIC) {
      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Output::Dec', ['//VTK::Output::Dec', 'layout(location = 2) out vec4 vectorTexture;', 'layout(location = 3) out vec4 maskVectorTexture;']).result;
      var arrayName = array.getName();
      var attributeName = "".concat(arrayName, "MC"); // We need normals even with no lighting

      if (prevComplexity === 0) {
        model.lastBoundBO.set({
          lastLightComplexity: 1
        }, true);
      }

      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', ["attribute vec3 ".concat(attributeName, ";"), 'out vec3 licOutput;', '//VTK::TCoord::Dec']).result;
      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', ["licOutput = ".concat(attributeName, ";"), '//VTK::TCoord::Impl']).result; // 0/1, when 1 V is projected to surface for |V| computation.

      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['uniform int uMaskOnSurface;', 'uniform mat3 normalMatrix;', 'in vec3 licOutput;', '//VTK::TCoord::Dec']).result;
      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['// projected vectors', '  vec3 tcoordLIC = normalMatrix * licOutput;', '  vec3 normN = normalize(normalVCVSOutput);', '  float k = dot(tcoordLIC, normN);', '  vec3 projected = (tcoordLIC - k*normN);', '  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);', '// vectors for fragment masking', '  if (uMaskOnSurface == 0)', '    {', '    maskVectorTexture = vec4(licOutput, 1.0);', '    }', '  else', '    {', '    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);', '    }', '//VTK::TCoord::Impl'], false).result;
      shaders.Vertex = VSSource;
    }

    model.rebuildLICShaders = false;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);

    if (prevComplexity > 0) {
      model.lastBoundBO.set({
        lastLightComplexity: prevComplexity
      }, true);
    }
  };

  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {
    superClass.setMapperShaderParameters(cellBO, ren, actor);

    if (model.canDrawLIC) {
      cellBO.getProgram().setUniformi('uMaskOnSurface', model.maskOnSurface);
    }
  };

  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {
    return model.rebuildLICBuffers || superClass.getNeedToRebuildBufferObjects(ren, actor);
  };

  publicAPI.buildBufferObjects = function (ren, actor) {
    if (model.canDrawLIC) {
      var array = model.renderable.getInputArrayToProcess(0);

      if (array && array.getNumberOfComponents() > 1) {
        model.renderable.setCustomShaderAttributes([array.getName()]);
      }
    }

    model.rebuildLICBuffers = false;
    superClass.buildBufferObjects(ren, actor);
  };

  publicAPI.pushState = function (gl) {
    var _model$stateCache;

    model.stateCache = (_model$stateCache = {}, _defineProperty(_model$stateCache, gl.BLEND, gl.isEnabled(gl.BLEND)), _defineProperty(_model$stateCache, gl.DEPTH_TEST, gl.isEnabled(gl.DEPTH_TEST)), _defineProperty(_model$stateCache, gl.SCISSOR_TEST, gl.isEnabled(gl.SCISSOR_TEST)), _defineProperty(_model$stateCache, gl.CULL_FACE, gl.isEnabled(gl.CULL_FACE)), _model$stateCache);
  };

  publicAPI.popState = function (gl) {
    var apply = function apply(param) {
      return model.stateCache[param] ? gl.enable(param) : gl.disable(param);
    };

    apply(gl.BLEND);
    apply(gl.DEPTH_TEST);
    apply(gl.SCISSOR_TEST);
    apply(gl.CULL_FACE);
  };

  publicAPI.renderPiece = function (ren, actor) {
    var canDrawLIC = true; // Check for gl compatibility

    var gl2 = model._openGLRenderWindow.getWebgl2();

    if (!gl2) {
      vtkErrorMacro('SurfaceLICMapper Requires WebGL 2');
      canDrawLIC = false;
    } // Check for required extensions


    if (!model.context.getExtension('EXT_color_buffer_float') || !model.context.getExtension('OES_texture_float_linear')) {
      vtkErrorMacro('SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.');
      canDrawLIC = false;
    } // Check for input


    model.currentInput = model.renderable.getInputData();

    if (!model.currentInput) {
      vtkErrorMacro('No input');
      canDrawLIC = false;
    } // Make sure LIC interfaces are present and configured


    var licInterface = model.renderable.getLicInterface();

    if (!licInterface) {
      licInterface = vtkSurfaceLICInterface.newInstance();
      model.renderable.setLicInterface(licInterface);
    }

    if (!model.openGLLicInterface) {
      model.openGLLicInterface = vtkOpenGLSurfaceLICInterface.newInstance();
    }

    if (licInterface !== model.openGLLicInterface.getLicInterface()) {
      model.openGLLicInterface.setLicInterface(licInterface);
    } // Check for input vectors


    var array = model.renderable.getInputArrayToProcess(0);

    if (licInterface.getEnableLIC() && (!array || array.getNumberOfComponents() < 2)) {
      vtkErrorMacro('No vector input array');
      canDrawLIC = false;
    }

    if (!licInterface.getEnableLIC()) {
      canDrawLIC = false;
    }

    if (model.canDrawLIC !== canDrawLIC) {
      model.rebuildLICShaders = true;
      model.rebuildLICBuffers = true;
    }

    model.canDrawLIC = canDrawLIC; // Necessary conditions are not met. Fallback to polydataMapper

    if (!canDrawLIC || !licInterface.getEnableLIC()) {
      superClass.renderPiece(ren, actor);
      return;
    } // apply faceCulling


    var gl = model.context;
    var backfaceCulling = actor.getProperty().getBackfaceCulling();
    var frontfaceCulling = actor.getProperty().getFrontfaceCulling();

    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();

      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();

      gl.cullFace(gl.BACK);
    }

    var windowSize = model._openGLRenderWindow.getSize();

    var size = windowSize.map(function (i) {
      return Math.round(i * licInterface.getViewPortScale());
    });
    model.openGLLicInterface.setSize(size);
    model.openGLLicInterface.setOpenGLRenderWindow(model._openGLRenderWindow);
    model.openGLLicInterface.setContext(model.context); // Pre-render

    publicAPI.pushState(model.context);
    model.openGLLicInterface.initializeResources();
    model.openGLLicInterface.prepareForGeometry();
    publicAPI.popState(model.context); // Render

    superClass.renderPieceStart(ren, actor);
    superClass.renderPieceDraw(ren, actor);
    superClass.renderPieceFinish(ren, actor); // Post

    publicAPI.pushState(model.context);
    model.VBOBuildTime.modified();
    model.openGLLicInterface.completedGeometry();
    model.context.disable(model.context.CULL_FACE);
    model.openGLLicInterface.applyLIC();
    model.openGLLicInterface.combineColorsAndLIC();
    model.openGLLicInterface.copyToScreen(windowSize);
    publicAPI.popState(model.context);
  };
}

var DEFAULT_VALUES = {
  canDrawLIC: false,
  rebuildLICShaders: false,
  rebuildLICBuffers: false,
  openGLLicInterface: null
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inherit

  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues); // Object methods

  vtkOpenGLSurfaceLICMapper(publicAPI, model);
  setGet(publicAPI, model, ['openGLLicInterface']);
} // ----------------------------------------------------------------------------

var newInstance = newInstance$1(extend, 'vtkOpenGLSurfaceLICMapper'); // ----------------------------------------------------------------------------

var vtkOpenGLSurfaceLICMapper$1 = {
  newInstance: newInstance,
  extend: extend
}; // Register ourself to OpenGL backend if imported

registerOverride('vtkSurfaceLICMapper', newInstance);

export { vtkOpenGLSurfaceLICMapper$1 as default, extend, newInstance };
