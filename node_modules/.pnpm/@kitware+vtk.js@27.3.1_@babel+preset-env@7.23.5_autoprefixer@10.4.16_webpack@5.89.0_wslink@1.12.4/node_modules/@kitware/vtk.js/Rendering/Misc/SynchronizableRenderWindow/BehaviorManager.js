import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import vtkCameraSynchronizer from './BehaviorManager/CameraSynchronizer.js';

var BEHAVIORS = {};

var CameraSync = /*#__PURE__*/function () {
  function CameraSync(ctx, config) {
    _classCallCheck(this, CameraSync);

    this.ctx = ctx;
    this.behavior = vtkCameraSynchronizer.newInstance(this.getProperties(config));
    this.behavior.update();
  }

  _createClass(CameraSync, [{
    key: "getProperties",
    value: function getProperties(_ref) {
      var actorBounds = _ref.actorBounds,
          srcRenderer = _ref.srcRenderer,
          dstRenderer = _ref.dstRenderer;
      var distance = 3.4 * Math.max(actorBounds[1] - actorBounds[0], actorBounds[3] - actorBounds[2], actorBounds[5] - actorBounds[4]);
      var focalPoint = [0.5 * (actorBounds[0] + actorBounds[1]), 0.5 * (actorBounds[2] + actorBounds[3]), 0.5 * (actorBounds[4] + actorBounds[5])];
      var mode = vtkCameraSynchronizer.SynchronizationMode.MODE_ORIENTATION;
      return {
        distance: distance,
        focalPoint: focalPoint,
        mode: mode,
        srcRenderer: this.ctx.getInstance(srcRenderer),
        dstRenderer: this.ctx.getInstance(dstRenderer)
      };
    }
  }, {
    key: "update",
    value: function update(config) {
      this.behavior.set(this.getProperties(config));
      this.behavior.update();
    }
  }, {
    key: "delete",
    value: function _delete() {
      this.behavior.delete();
    }
  }]);

  return CameraSync;
}();

var BEHAVIORS_TYPES = {
  CameraSync: CameraSync
};
function applyBehaviors(renderWindow, state, context) {
  if (!state.behaviors || !renderWindow.getSynchronizedViewId) {
    return;
  } // Apply auto behavior


  var rwId = renderWindow.getSynchronizedViewId();

  if (!BEHAVIORS[rwId]) {
    BEHAVIORS[rwId] = {};
  }

  var localBehaviors = BEHAVIORS[rwId];

  if (state.behaviors.autoOrientation) {
    var renderers = renderWindow.getRenderers();

    if (!localBehaviors.autoOrientationAxes && renderers.length === 2) {
      var srcRenderer = null;
      var dstRenderer = null;

      for (var i = 0; i < renderers.length; i++) {
        var renderer = renderers[i];

        if (renderer.getInteractive()) {
          srcRenderer = renderer;
        } else {
          dstRenderer = renderer;
        }
      }

      if (srcRenderer && dstRenderer) {
        localBehaviors.autoOrientationAxes = vtkCameraSynchronizer.newInstance({
          srcRenderer: srcRenderer,
          dstRenderer: dstRenderer
        });
      }
    }

    if (localBehaviors.autoOrientationAxes && renderers.length !== 2) {
      localBehaviors.autoOrientationAxes.delete();
      delete localBehaviors.autoOrientationAxes;
    }
  }

  var currentSets = Object.keys(state.behaviors);
  var existingSets = Object.keys(localBehaviors);

  for (var _i = 0; _i < currentSets.length; _i++) {
    var key = currentSets[_i];

    if (!localBehaviors[key]) {
      var config = state.behaviors[key];

      if (BEHAVIORS_TYPES[config.type]) {
        localBehaviors[key] = new BEHAVIORS_TYPES[config.type](context, config);
      } else {
        console.log('No mapping for', config);
      }
    } else {
      localBehaviors[key].update(state.behaviors[key]);
    }
  }

  for (var _i2 = 0; _i2 < existingSets.length; _i2++) {
    var _key = currentSets[_i2];

    if (!state.behaviors[_key]) {
      // Need to delete previously created behavior
      localBehaviors[_key].delete();

      delete localBehaviors[_key];
    }
  }
}
var BehaviorManager = {
  applyBehaviors: applyBehaviors
};

export { applyBehaviors, BehaviorManager as default };
