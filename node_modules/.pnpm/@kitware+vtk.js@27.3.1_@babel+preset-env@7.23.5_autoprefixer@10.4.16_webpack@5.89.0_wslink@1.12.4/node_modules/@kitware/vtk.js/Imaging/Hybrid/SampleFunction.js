import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkDataArray from '../../Common/Core/DataArray.js';
import vtkImageData from '../../Common/DataModel/ImageData.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------
// vtkSampleFunction methods
// ----------------------------------------------------------------------------

function vtkSampleFunction(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkSampleFunction'); // Capture "parentClass" api for internal use

  var superClass = _objectSpread({}, publicAPI);

  publicAPI.getMTime = function () {
    if (!(model.implicitFunction && model.implicitFunction.getMTime)) {
      return superClass.getMTime();
    }

    return Math.max(superClass.getMTime(), model.implicitFunction.getMTime());
  };

  publicAPI.requestData = function (inData, outData) {
    // implement requestData
    var imp = model.implicitFunction;

    if (!imp) {
      vtkErrorMacro('An implicit function must be defined');
      return;
    } // Create a volume


    var dims = [model.sampleDimensions[0], model.sampleDimensions[1], model.sampleDimensions[2]];
    var numScalars = dims[0] * dims[1] * dims[2];

    if (numScalars < 1 || dims[1] < 2 || dims[1] < 2 || dims[2] < 2) {
      vtkErrorMacro('Bad volume dimensions');
      return;
    }

    var volume = vtkImageData.newInstance();
    var origin = [model.modelBounds[0], model.modelBounds[2], model.modelBounds[4]];
    var spacing = [(model.modelBounds[1] - model.modelBounds[0]) / (dims[0] - 1), (model.modelBounds[3] - model.modelBounds[2]) / (dims[1] - 1), (model.modelBounds[5] - model.modelBounds[4]) / (dims[2] - 1)];
    var sliceSize = dims[0] * dims[1];
    volume.setDimensions(dims);
    volume.setOrigin(origin);
    volume.setSpacing(spacing); // Create scalars array

    var s = macro.newTypedArray(model.pointType, numScalars);
    var scalars = vtkDataArray.newInstance({
      name: 'Scalars',
      values: s,
      numberOfComponents: 1
    });
    volume.getPointData().setScalars(scalars); // Now loop over volume dimensions and generate scalar values

    var sValue = 0.0;
    var xyz = [0.0, 0.0, 0.0];

    for (var k = 0; k < dims[2]; k++) {
      xyz[2] = origin[2] + k * spacing[2];

      for (var j = 0; j < dims[1]; j++) {
        xyz[1] = origin[1] + j * spacing[1];

        for (var i = 0; i < dims[0]; i++) {
          xyz[0] = origin[0] + i * spacing[0];
          sValue = imp.evaluateFunction(xyz);
          s[i + j * dims[0] + k * sliceSize] = sValue;
        }
      }
    } // Update output


    outData[0] = volume;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  implicitFunction: undefined,
  sampleDimensions: [50, 50, 50],
  modelBounds: [-1.0, 1.0, -1.0, 1.0, -1.0, 1.0],
  pointType: 'Float32Array'
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object

  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output

  macro.algo(publicAPI, model, 1, 1); // Generate macros for properties

  macro.setGetArray(publicAPI, model, ['sampleDimensions'], 3);
  macro.setGetArray(publicAPI, model, ['modelBounds'], 6); // Object specific methods

  vtkSampleFunction(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkSampleFunction'); // ----------------------------------------------------------------------------

var vtkSampleFunction$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkSampleFunction$1 as default, extend, newInstance };
