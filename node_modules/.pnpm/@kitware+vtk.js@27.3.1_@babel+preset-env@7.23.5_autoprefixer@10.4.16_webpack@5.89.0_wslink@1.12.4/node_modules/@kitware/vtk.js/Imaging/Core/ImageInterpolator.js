import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkAbstractImageInterpolator from './AbstractImageInterpolator.js';
import { vtkInterpolationMathRound, vtkInterpolationMathClamp, vtkInterpolationMathMirror, vtkInterpolationMathWrap, vtkInterpolationMathFloor, vtkInterpolationWeights } from './AbstractImageInterpolator/InterpolationInfo.js';
import { InterpolationMode, ImageBorderMode } from './AbstractImageInterpolator/Constants.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// vtkImageInterpolator methods
// ----------------------------------------------------------------------------

function vtkImageInterpolator(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageInterpolator');

  publicAPI.computeSupportSize = function (matrix) {
    var s = 1;

    if (model.interpolationMode === InterpolationMode.LINEAR) {
      s = 2;
    } else if (model.interpolationMode === InterpolationMode.CUBIC) {
      s = 4;
    }

    var size = [s, s, s];

    if (matrix == null) {
      return size;
    } // TODO CHECK MATRIX


    if (matrix[12] !== 0 || matrix[13] !== 0 || matrix[14] !== 0 || matrix[15] !== 1) {
      return size;
    }

    for (var i = 0; i < 3; ++i) {
      var integerRow = true;

      for (var j = 0; j < 3; ++j) {
        integerRow = integerRow && Number.isInteger(matrix[4 * i + j]);
      }

      if (integerRow) {
        size[i] = 1;
      }
    }

    return size;
  };

  publicAPI.internalUpdate = function () {
    model.interpolationInfo.interpolationMode = model.interpolationMode;
  };

  publicAPI.isSeparable = function () {
    return true;
  };

  publicAPI.interpolateNearest = function (interpolationInfo, point, value) {
    var inExt = interpolationInfo.extent;
    var inInc = interpolationInfo.increments;
    var numscalars = interpolationInfo.numberOfComponents;
    var inIdX0 = vtkInterpolationMathRound(point[0]);
    var inIdY0 = vtkInterpolationMathRound(point[1]);
    var inIdZ0 = vtkInterpolationMathRound(point[2]);

    switch (interpolationInfo.borderMode) {
      case ImageBorderMode.REPEAT:
        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);
        break;

      case ImageBorderMode.MIRROR:
        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);
        break;

      default:
        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);
        break;
    }

    var startId = inIdX0 * inInc[0] + inIdY0 * inInc[1] + inIdZ0 * inInc[2];

    for (var i = 0; i < numscalars; ++i) {
      value[i] = interpolationInfo.pointer[startId + i];
    }
  };

  publicAPI.interpolateLinear = function (interpolationInfo, point, value) {
    var inExt = interpolationInfo.extent;
    var inInc = interpolationInfo.increments;
    var numscalars = interpolationInfo.numberOfComponents;
    var floorX = vtkInterpolationMathFloor(point[0]);
    var floorY = vtkInterpolationMathFloor(point[1]);
    var floorZ = vtkInterpolationMathFloor(point[2]);
    var inIdX0 = floorX.floored;
    var inIdY0 = floorY.floored;
    var inIdZ0 = floorZ.floored;
    var fx = floorX.error;
    var fy = floorY.error;
    var fz = floorZ.error;
    var inIdX1 = inIdX0 + (fx !== 0);
    var inIdY1 = inIdY0 + (fy !== 0);
    var inIdZ1 = inIdZ0 + (fz !== 0);

    switch (interpolationInfo.borderMode) {
      case ImageBorderMode.REPEAT:
        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);
        inIdX1 = vtkInterpolationMathWrap(inIdX1, inExt[0], inExt[1]);
        inIdY1 = vtkInterpolationMathWrap(inIdY1, inExt[2], inExt[3]);
        inIdZ1 = vtkInterpolationMathWrap(inIdZ1, inExt[4], inExt[5]);
        break;

      case ImageBorderMode.MIRROR:
        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);
        inIdX1 = vtkInterpolationMathMirror(inIdX1, inExt[0], inExt[1]);
        inIdY1 = vtkInterpolationMathMirror(inIdY1, inExt[2], inExt[3]);
        inIdZ1 = vtkInterpolationMathMirror(inIdZ1, inExt[4], inExt[5]);
        break;

      default:
        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);
        inIdX1 = vtkInterpolationMathClamp(inIdX1, inExt[0], inExt[1]);
        inIdY1 = vtkInterpolationMathClamp(inIdY1, inExt[2], inExt[3]);
        inIdZ1 = vtkInterpolationMathClamp(inIdZ1, inExt[4], inExt[5]);
        break;
    }

    var factX0 = inIdX0 * inInc[0];
    var factX1 = inIdX1 * inInc[0];
    var factY0 = inIdY0 * inInc[1];
    var factY1 = inIdY1 * inInc[1];
    var factZ0 = inIdZ0 * inInc[2];
    var factZ1 = inIdZ1 * inInc[2];
    var i00 = factY0 + factZ0;
    var i01 = factY0 + factZ1;
    var i10 = factY1 + factZ0;
    var i11 = factY1 + factZ1;
    var rx = 1 - fx;
    var ry = 1 - fy;
    var rz = 1 - fz;
    var ryrz = ry * rz;
    var fyrz = fy * rz;
    var ryfz = ry * fz;
    var fyfz = fy * fz;
    var inPtr = interpolationInfo.pointer;

    for (var i = 0; i < numscalars; ++i) {
      value[i] = rx * (ryrz * inPtr[factX0 + i00 + i * 4] + ryfz * inPtr[factX0 + i01 + i * 4] + fyrz * inPtr[factX0 + i10 + i * 4] + fyfz * inPtr[factX0 + i11 + i * 4]) + fx * (ryrz * inPtr[factX1 + i00 + i * 4] + ryfz * inPtr[factX1 + i01 + i * 4] + fyrz * inPtr[factX1 + i10 + i * 4] + fyfz * inPtr[factX1 + i11 + i * 4]);
    }
  };

  publicAPI.interpolatePoint = function (interpolationInfo, point, value) {
    switch (model.interpolationMode) {
      case InterpolationMode.LINEAR:
        publicAPI.interpolateLinear(interpolationInfo, point, value);
        break;

      case InterpolationMode.CUBIC:
        console.log('CUBIC not implemented');
        break;

      case InterpolationMode.NEAREST:
      default:
        publicAPI.interpolateNearest(interpolationInfo, point, value);
        break;
    }
  };

  publicAPI.interpolateRowNearest = function (weights, idX, idY, idZ, outPtr, n) {
    // TODO check pointers
    var iX = weights.positions[0].subarray(idX);
    var iY = weights.positions[1].subarray(idY);
    var iZ = weights.positions[2].subarray(idZ);
    var inPtr0 = weights.pointer.subarray(iY[0] + iZ[0]); // get the number of components per pixel

    var numscalars = weights.numberOfComponents; // This is a hot loop.

    for (var i = 0; i < n; ++i) {
      outPtr.set(inPtr0.subarray(iX[i], numscalars), i * numscalars);
    }
  };

  publicAPI.interpolateRowLinear = function (weights, idX, idY, idZ, outPtr, n) {
    var stepX = weights.kernelSize[0];
    var stepY = weights.kernelSize[1];
    var stepZ = weights.kernelSize[2];
    var idXtemp = idX * stepX;
    var idYtemp = idY * stepY;
    var idZtemp = idZ * stepZ;
    var fX = weights.weights[0].subarray(idXtemp);
    var fY = weights.weights[1].subarray(idYtemp);
    var fZ = weights.weights[2].subarray(idZtemp);
    var iX = weights.positions[0].subarray(idXtemp);
    var iY = weights.positions[1].subarray(idYtemp);
    var iZ = weights.positions[2].subarray(idZtemp);
    var inPtr = weights.pointer; // get the number of components per pixel

    var numscalars = weights.numberOfComponents; // create a 2x2 bilinear kernel in local variables

    var i00 = iY.subarray(iZ[0]);
    var i01 = i00;
    var i10 = i00;
    var i11 = i00;
    var ry = 1;
    var fy = 0;
    var rz = 1;
    var fz = 0;

    if (stepY === 2) {
      i10 = iY[1].subarray(iZ[0]);
      i11 = i10;
      ry = fY[0];
      fy = fY[1];
    }

    if (stepZ === 2) {
      i01 = iY[0].subarray(iZ[1]);
      i11 = i01;
      rz = fZ[0];
      fz = fZ[1];
    }

    if (stepY + stepZ === 4) {
      i11 = iY[1].subarray(iZ[1]);
    }

    var ryrz = ry * rz;
    var ryfz = ry * fz;
    var fyrz = fy * rz;
    var fyfz = fy * fz;

    if (stepX === 1) {
      if (fy === 0 && fz === 0) {
        // no interpolation needed at all
        for (var i = n; i > 0; --i) {
          for (var j = 0; j < numscalars; j++) {
            outPtr[j + n - i] = inPtr[i00 + iX[n - i] + j];
          }
        }
      } else if (fy === 0) {
        // only need linear z interpolation
        for (var _i = n; _i > 0; --_i) {
          for (var _j = 0; _j < numscalars; _j++) {
            outPtr[_j + n - _i] = rz * inPtr[iX[n - _i] + i00 + _j * 4] + fz * inPtr[iX[n - _i] + i01 + _j * 4];
          }
        }
      } else {
        // interpolate in y and z but not in x
        for (var _i2 = n; _i2 > 0; --_i2) {
          for (var _j2 = 0; _j2 < numscalars; _j2++) {
            outPtr[_j2 + n - _i2] = ryrz * inPtr[iX[n - _i2] + i00 + _j2 * 4] + ryfz * inPtr[iX[n - _i2] + i01 + _j2 * 4] + fyrz * inPtr[iX[n - _i2] + i10 + _j2 * 4] + fyfz * inPtr[iX[n - _i2] + i11 + _j2 * 4];
          }
        }
      }
    } else if (fz === 0) {
      var x = 0; // bilinear interpolation in x,y

      for (var _i3 = n; _i3 > 0; --_i3) {
        var rx = fX[0 + 2 * x];
        var fx = fX[1 + 2 * x];
        var t0 = iX[0 + 2 * x];
        var t1 = iX[1 + 2 * x];

        for (var _j3 = 0; _j3 < numscalars; _j3++) {
          outPtr[_j3 + n - _i3] = rx * (ry * inPtr[t0 + i00 + _j3 * 4] + fy * inPtr[t0 + i10 + _j3 * 4]) + fx * (ry * inPtr[t1 + i00 + _j3 * 4] + fy * inPtr[t1 + i10 + _j3 * 4]);
        }

        x++;
      }
    } else {
      var _x = 0; // do full trilinear interpolation

      for (var _i4 = n; _i4 > 0; --_i4) {
        var _rx = fX[0 + 2 * _x];
        var _fx = fX[1 + 2 * _x];
        var _t = iX[0 + 2 * _x];
        var _t2 = iX[1 + 2 * _x];

        for (var _j4 = 0; _j4 < numscalars; _j4++) {
          outPtr[_j4] = _rx * (ryrz * inPtr[_t + i00 + _j4 * 4] + ryfz * inPtr[_t + i01 + _j4 * 4] + fyrz * inPtr[_t + i10 + _j4 * 4] + fyfz * inPtr[_t + i11 + _j4 * 4]) + _fx * (ryrz * inPtr[_t2 + i00 + _j4 * 4] + ryfz * inPtr[_t2 + i01 + _j4 * 4] + fyrz * inPtr[_t2 + i10 + _j4 * 4] + fyfz * inPtr[_t2 + i11 + _j4 * 4]);
        }

        _x++;
      }
    }
  };

  publicAPI.interpolateRow = function (weights, xIdx, yIdx, zIdx, value, n) {
    switch (model.interpolationMode) {
      case InterpolationMode.LINEAR:
        publicAPI.interpolateRowLinear(weights, xIdx, yIdx, zIdx, value, n);
        break;

      case InterpolationMode.CUBIC:
        console.log('CUBIC not implemented');
        break;

      case InterpolationMode.NEAREST:
      default:
        publicAPI.interpolateRowNearest(weights, xIdx, yIdx, zIdx, value, n);
        break;
    }
  };

  publicAPI.vtkTricubicInterpWeights = function (f) {
    var half = 0.5; // cubic interpolation

    var fm1 = f - 1;
    var fd2 = f * half;
    var ft3 = f * 3;
    return [-fd2 * fm1 * fm1, ((ft3 - 2) * fd2 - 1) * fm1, -((ft3 - 4) * f - 1) * fd2, f * fd2 * fm1];
  };

  publicAPI.precomputeWeightsForExtent = function (matrix, outExt, clipExt) {
    var weights = _objectSpread(_objectSpread({}, vtkInterpolationWeights.newInstance()), model.interpolationInfo);

    weights.weightType = 'Float32Array';
    var interpMode = weights.interpolationMode;
    var validClip = true;

    for (var j = 0; j < 3; ++j) {
      // set k to the row for which the element in column j is nonzero
      var k = void 0;

      for (k = 0; k < 3; ++k) {
        if (matrix[4 * j + k] !== 0) {
          break;
        }
      } // get the extents


      clipExt[2 * j] = outExt[2 * j];
      clipExt[2 * j + 1] = outExt[2 * j + 1];
      var minExt = weights.extent[2 * k];
      var maxExt = weights.extent[2 * k + 1];
      var minBounds = model.structuredBounds[2 * k];
      var maxBounds = model.structuredBounds[2 * k + 1]; // the kernel size should not exceed the input dimension

      var step = 1;
      step = interpMode < InterpolationMode.LINEAR ? step : 2;
      step = interpMode < InterpolationMode.CUBIC ? step : 4;
      var inCount = maxExt - minExt + 1;
      step = step < inCount ? step : inCount; // if output pixels lie exactly on top of the input pixels

      if (Number.isInteger(matrix[4 * j + k]) && Number.isInteger(matrix[4 * k + k])) {
        step = 1;
      }

      var size = step * (outExt[2 * j + 1] - outExt[2 * j] + 1); // TODO: check pointers

      var positions = new Int16Array(size); // positions -= step*outExt[2 * j];

      var startPositions = step * outExt[2 * j];
      var constants = null;

      if (interpMode !== InterpolationMode.NEAREST) {
        constants = new Int16Array(size); // constants -= step * outExt[2 * j];
      }

      weights.kernelSize[j] = step;
      weights.weightExtent[2 * j] = outExt[2 * j];
      weights.weightExtent[2 * j + 1] = outExt[2 * j + 1];
      weights.positions[j] = positions; // TODO: check pointers

      weights.weights[j] = constants; // TODO: check pointers

      var region = 0;

      for (var i = outExt[2 * j]; i <= outExt[2 * j + 1]; ++i) {
        var point = matrix[4 * 3 + k] + i * matrix[4 * j + k];
        var lcount = step;
        var inId0 = 0;
        var f = 0;

        if (interpMode === InterpolationMode.NEAREST) {
          inId0 = Math.round(point);
        } else {
          var res = vtkInterpolationMathFloor(point);
          inId0 = res.integer;
          f = res.error;

          if (interpMode === InterpolationMode.CUBIC && step !== 1) {
            inId0--;
            lcount = 4;
          }
        }

        var inId = [0, 0, 0, 0];
        var l = 0;

        switch (weights.borderMode) {
          case ImageBorderMode.REPEAT:
            do {
              inId[l] = vtkInterpolationMathWrap(inId0, minExt, maxExt);
              inId0++;
            } while (++l < lcount);

            break;

          case ImageBorderMode.MIRROR:
            do {
              inId[l] = vtkInterpolationMathMirror(inId0, minExt, maxExt);
              inId0++;
            } while (++l < lcount);

            break;

          default:
            do {
              inId[l] = vtkInterpolationMathClamp(inId0, minExt, maxExt);
              inId0++;
            } while (++l < lcount);

            break;
        } // compute the weights and offsets


        var inInc = weights.increments[k];
        positions[step * i - startPositions] = inId[0] * inInc;

        if (interpMode !== InterpolationMode.NEAREST) {
          constants[step * i - startPositions] = 1;
        }

        if (step > 1) {
          if (interpMode === InterpolationMode.LINEAR) {
            positions[step * i + 1 - startPositions] = inId[1] * inInc;
            constants[step * i - startPositions] = 1.0 - f;
            constants[step * i + 1 - startPositions] = f;
          } else if (interpMode === InterpolationMode.CUBIC) {
            var g = publicAPI.vtkTricubicInterpWeights(f);

            if (step === 4) {
              for (var ll = 0; ll < 4; ll++) {
                positions[step * i + ll - startPositions] = inId[ll] * inInc;
                constants[step * i + ll - startPositions] = g[ll];
              }
            } else {
              // it gets tricky if there are fewer than 4 slices
              var gg = [0, 0, 0, 0];

              for (var _ll = 0; _ll < 4; _ll++) {
                var rIdx = inId[_ll] - minExt;
                gg[rIdx] += g[_ll];
              }

              for (var jj = 0; jj < step; jj++) {
                positions[step * i + jj - startPositions] = minExt + jj;
                constants[step * i + jj - startPositions] = gg[jj];
              }
            }
          }
        }

        if (point >= minBounds && point <= maxBounds) {
          if (region === 0) {
            // entering the input extent
            region = 1;
            clipExt[2 * j] = i;
          }
        } else if (region === 1) {
          // leaving the input extent
          region = 2;
          clipExt[2 * j + 1] = i - 1;
        }
      }

      if (region === 0 || clipExt[2 * j] > clipExt[2 * j + 1]) {
        // never entered input extent!
        validClip = false;
      }
    }

    if (!validClip) {
      // output extent doesn't itersect input extent
      for (var _j5 = 0; _j5 < 3; _j5++) {
        clipExt[2 * _j5] = outExt[2 * _j5];
        clipExt[2 * _j5 + 1] = outExt[2 * _j5] - 1;
      }
    }
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  interpolationMode: InterpolationMode.NEAREST
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkAbstractImageInterpolator.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ['interpolationMode']); // Object specific methods

  vtkImageInterpolator(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkImageInterpolator'); // ----------------------------------------------------------------------------

var vtkImageInterpolator$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkImageInterpolator$1 as default, extend, newInstance };
