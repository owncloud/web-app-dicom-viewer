import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import Constants from './ImplicitBoolean/Constants.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var Operation = Constants.Operation; // ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// vtkImplicitBoolean methods
// ----------------------------------------------------------------------------

function vtkImplicitBoolean(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImplicitBoolean'); // Capture "parentClass" api for internal use

  var superClass = _objectSpread({}, publicAPI);

  publicAPI.getMTime = function () {
    var mTime = superClass.getMTime();

    if (!model.functions || model.functions.length <= 0) {
      return mTime;
    }

    for (var i = 0; i < model.functions.length; ++i) {
      mTime = Math.max(mTime, model.functions[i].getMTime());
    }

    return mTime;
  };

  publicAPI.getOperationAsString = function () {
    return macro.enumToString(Operation, model.operation);
  };

  publicAPI.setOperationToUnion = function () {
    return publicAPI.setOperation(0);
  };

  publicAPI.setOperationToIntersection = function () {
    return publicAPI.setOperation(1);
  };

  publicAPI.setOperationToDifference = function () {
    return publicAPI.setOperation(2);
  };

  publicAPI.getFunctions = function () {
    return model.functions;
  };

  publicAPI.hasFunction = function (f) {
    return !!model.functions.filter(function (item) {
      return item === f;
    }).length;
  };

  publicAPI.addFunction = function (f) {
    if (f && !publicAPI.hasFunction(f)) {
      model.functions = model.functions.concat(f);
    }
  };

  publicAPI.removeFunction = function (f) {
    var newFunctionList = model.functions.filter(function (item) {
      return item !== f;
    });

    if (model.functions.length !== newFunctionList.length) {
      model.functions = newFunctionList;
    }
  };

  publicAPI.removeAllFunctions = function () {
    model.functions = [];
  };

  publicAPI.evaluateFunction = function (xyz) {
    var value = 0.0;

    if (model.functions.length <= 0) {
      return value;
    }

    if (model.operation === Operation.UNION) {
      value = Number.MAX_VALUE;

      for (var i = 0; i < model.functions.length; ++i) {
        var f = model.functions[i];
        var v = f.evaluateFunction(xyz);

        if (v < value) {
          value = v;
        }
      }
    } else if (model.operation === Operation.INTERSECTION) {
      value = -Number.MAX_VALUE;

      for (var _i = 0; _i < model.functions.length; ++_i) {
        var _f = model.functions[_i];

        var _v = _f.evaluateFunction(xyz);

        if (_v > value) {
          value = _v;
        }
      }
    } else {
      var firstF = model.functions[0];
      value = firstF.evaluateFunction(xyz);

      for (var _i2 = 1; _i2 < model.functions.length; ++_i2) {
        var _f2 = model.functions[_i2];

        var _v2 = -1.0 * _f2.evaluateFunction(xyz);

        if (_v2 > value) {
          value = _v2;
        }
      }
    }

    return value;
  };

  publicAPI.evaluateGradient = function (xyz) {
    var t = model.axis[0] * (xyz[0] - model.center[0]) + model.axis[1] * (xyz[1] - model.center[1]) + model.axis[2] * (xyz[2] - model.center[2]);
    var cp = new Float32Array(3);
    cp[0] = model.center[0] + t * model.axis[0];
    cp[1] = model.center[1] + t * model.axis[1];
    cp[2] = model.center[2] + t * model.axis[2];
    var retVal = [2.0 * (xyz[0] - cp[0]), 2.0 * (xyz[1] - cp[1]), 2.0 * (xyz[2] - cp[2])];
    return retVal;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  operation: 0,
  functions: []
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods

  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['operation']);
  vtkImplicitBoolean(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkImplicitBoolean'); // ----------------------------------------------------------------------------

var vtkImplicitBoolean$1 = _objectSpread({
  newInstance: newInstance,
  extend: extend
}, Constants);

export { vtkImplicitBoolean$1 as default, extend, newInstance };
