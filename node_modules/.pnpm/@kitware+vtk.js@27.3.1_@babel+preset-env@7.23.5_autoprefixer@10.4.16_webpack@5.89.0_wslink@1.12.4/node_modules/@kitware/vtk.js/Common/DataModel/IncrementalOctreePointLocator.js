import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import macro from '../../macros.js';
import { f as vtkMath } from '../Core/Math/index.js';
import vtkBoundingBox from './BoundingBox.js';
import vtkIncrementalOctreeNode from './IncrementalOctreeNode.js';
import vtkAbstractPointLocator from './AbstractPointLocator.js';
import { VtkDataTypes } from '../Core/DataArray/Constants.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkErrorMacro = macro.vtkErrorMacro;

function vtkIncrementalOctreePointLocator(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkIncrementalOctreePointLocator');

  function getLeafContainer(node, pnt) {
    return node.isLeaf() ? node : getLeafContainer(node.getChild(node.getChildIndex(pnt)), pnt);
  } //------------------------------------------------------------------------------


  publicAPI.freeSearchStructure = function () {
    model.octreeRootNode = null;
    model.numberOfNodes = 0;
    model.locatorPoints = null;
  }; //------------------------------------------------------------------------------


  publicAPI.findClosestPointInLeafNode = function (leafNode, point) {
    // NOTE: dist2 MUST be initiated with a very huge value below, but instead of
    // model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, because the point
    // under check may be outside the octree and hence the squared distance can
    // be greater than the latter or other similar octree-based specific values.
    var dist2 = Number.MAX_VALUE;

    if (leafNode.getPointIdSet() == null) {
      return [-1, dist2];
    }

    var numPts = 0;
    var tmpDst = 0.0;
    var tmpPnt = [];
    var tmpIdx = -1;
    var pntIdx = -1;
    var idList = leafNode.getPointIdSet();
    numPts = idList.length;

    for (var i = 0; i < numPts; i++) {
      tmpIdx = idList[i];
      model.locatorPoints.getPoint(tmpIdx, tmpPnt);
      tmpDst = vtkMath.distance2BetweenPoints(tmpPnt, point);

      if (tmpDst < dist2) {
        dist2 = tmpDst;
        pntIdx = tmpIdx;
      }

      if (dist2 === 0.0) {
        break;
      }
    }

    idList = null;
    return [pntIdx, dist2];
  };

  publicAPI.findClosestPointInSphere = function (point, radius2, maskNode, refDist2) {
    var pointIndx = -1;
    var minDist2 = Number.MAX_VALUE;
    var nodesBase = [];
    nodesBase.push(model.octreeRootNode);
    var checkNode;
    var childNode;
    var distToData;
    var tempDist2;
    var tempPntId;

    while (!nodesBase.length === 0 && minDist2 > 0.0) {
      checkNode = nodesBase.top();
      nodesBase.pop();

      if (!checkNode.isLeaf()) {
        for (var i = 0; i < 8; i++) {
          childNode = checkNode.getChild(i); // use ( radius2 + radius2 ) to skip empty nodes

          distToData = childNode.getNumberOfPoints() ? childNode.getDistance2ToBoundary(point, model.octreeRootNode, 1) : radius2 + radius2; // If a child node is not the mask node AND its distance, specifically
          // the data bounding box (determined by the points inside or under) to
          // the point, is less than the threshold radius (one exception is the
          // point's container nodes), it is pushed to the stack as a suspect.

          if (childNode !== maskNode && (distToData <= refDist2 || childNode.containsPoint(point) === 1)) {
            nodesBase.push(childNode);
          }

          childNode = null;
        }
      } else {
        // now that the node under check is a leaf, let's find the closest
        // point therein and the minimum distance
        var _publicAPI$findCloses = publicAPI.findClosestPointInLeafNode(checkNode, point);

        var _publicAPI$findCloses2 = _slicedToArray(_publicAPI$findCloses, 2);

        tempPntId = _publicAPI$findCloses2[0];
        tempDist2 = _publicAPI$findCloses2[1];

        if (tempDist2 < minDist2) {
          minDist2 = tempDist2;
          pointIndx = tempPntId;
        }
      }

      checkNode = null;
    }

    return [minDist2 <= radius2 ? pointIndx : -1, minDist2];
  }; //------------------------------------------------------------------------------


  publicAPI.initPointInsertion = function (points, bounds) {
    var _model$octreeRootNode;
    var i = 0;
    var bbIndex = 0;

    if (points == null) {
      vtkErrorMacro('a valid vtkPoints object required for point insertion');
      return false;
    } // destroy the existing octree, if any


    publicAPI.freeSearchStructure();
    model.locatorPoints = points; // obtain the threshold squared distance

    model.insertTolerance2 = model.tolerance * model.tolerance; // Fix bounds
    // (1) push out a little bit if the original volume is too flat --- a slab
    // (2) pull back the x, y, and z's lower bounds a little bit such that
    //     points are clearly "inside" the spatial region.  Point p is taken as
    //     "inside" range r = [r1, r2] if and only if r1 < p <= r2.

    model.octreeMaxDimSize = 0.0;

    var tmpBbox = _toConsumableArray(bounds);

    var dimDiff = vtkBoundingBox.getLengths(bounds);
    model.octreeMaxDimSize = Math.max.apply(Math, _toConsumableArray(dimDiff));

    if (model.buildCubicOctree) {
      // make the bounding box a cube and hence descendant octants cubes too
      for (i = 0; i < 3; i++) {
        if (dimDiff[i] !== model.octreeMaxDimSize) {
          var delta = model.octreeMaxDimSize - dimDiff[i];
          tmpBbox[2 * i] -= 0.5 * delta;
          tmpBbox[2 * i + 1] += 0.5 * delta;
          dimDiff[i] = model.octreeMaxDimSize;
        }
      }
    }

    model.fudgeFactor = model.octreeMaxDimSize * 10e-6;
    var minSideSize = model.octreeMaxDimSize * 10e-2;

    for (i = 0; i < 3; i++) {
      if (dimDiff[i] < minSideSize) {
        // case (1) above
        bbIndex = 2 * i;
        var tempVal = tmpBbox[bbIndex];
        tmpBbox[bbIndex] = tmpBbox[bbIndex + 1] - minSideSize;
        tmpBbox[bbIndex + 1] = tempVal + minSideSize;
      } else {
        // case (2) above
        tmpBbox[2 * i] -= model.fudgeFactor;
      }
    } // init the octree with an empty leaf node


    model.octreeRootNode = vtkIncrementalOctreeNode.newInstance();
    ++model.numberOfNodes; // this call internally inits the middle (center) and data range, too

    (_model$octreeRootNode = model.octreeRootNode).setBounds.apply(_model$octreeRootNode, _toConsumableArray(tmpBbox));

    return true;
  };

  publicAPI.findClosestPointInSphereWithTolerance = function (point, radius2, maskNode) {
    return publicAPI.findClosestPointInSphere(point, radius2, maskNode, model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, radius2);
  }; //------------------------------------------------------------------------------


  publicAPI.findDuplicateFloatTypePointInVisitedLeafNode = function (leafNode, point) {
    var tmpPnt;
    var tmpIdx = -1;
    var pntIdx = -1; // float thePnt[3]; // TODO
    // thePnt[0] = static_cast<float>(point[0]);
    // thePnt[1] = static_cast<float>(point[1]);
    // thePnt[2] = static_cast<float>(point[2]);

    var idList = leafNode.getPointIdSet(); // float* pFloat = (static_cast<vtkFloatArray*>(model.locatorPoints.getData())).getPointer(0);

    var values = model.locatorPoints.getData();

    for (var i = 0; i < idList.length; i++) {
      tmpIdx = idList[i]; // eslint-disable-next-line no-bitwise

      tmpPnt = (tmpIdx << 1) + tmpIdx;

      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {
        pntIdx = tmpIdx;
        break;
      }
    }

    return pntIdx;
  }; //------------------------------------------------------------------------------


  publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode = function (leafNode, point) {
    var tmpPnt;
    var tmpIdx = -1;
    var pntIdx = -1;
    var idList = leafNode.getPointIdSet();
    var values = model.locatorPoints.getData();

    for (var i = 0; i < idList.length; i++) {
      tmpIdx = idList[i]; // eslint-disable-next-line no-bitwise

      tmpPnt = (tmpIdx << 1) + tmpIdx;

      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {
        pntIdx = tmpIdx;
        break;
      }
    }

    return pntIdx;
  }; //------------------------------------------------------------------------------


  publicAPI.findDuplicatePointInLeafNode = function (leafNode, point) {
    if (leafNode.getPointIdSet() == null) {
      return -1;
    }

    return model.locatorPoints.getDataType() === VtkDataTypes.FLOAT ? publicAPI.findDuplicateFloatTypePointInVisitedLeafNode(leafNode, point) : publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode(leafNode, point);
  }; //------------------------------------------------------------------------------


  publicAPI.insertPoint = function (ptId, x) {
    var leafcontainer = getLeafContainer(model.octreeRootNode, x);

    var _leafcontainer$insert = leafcontainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, ptId, 1, model.numberOfNodes);

    model.numberOfNodes = _leafcontainer$insert.numberOfNodes;
  }; //------------------------------------------------------------------------------


  publicAPI.insertUniquePoint = function (point) {
    // TODO: We have a mix of let and const here.
    // eslint-disable-next-line prefer-const
    var _publicAPI$isInserted = publicAPI.isInsertedPoint(point),
        pointIdx = _publicAPI$isInserted.pointIdx,
        leafContainer = _publicAPI$isInserted.leafContainer;

    if (pointIdx > -1) {
      return {
        success: false,
        idx: pointIdx
      };
    } // TODO: pointIdx


    var numberOfNodes; // eslint-disable-next-line prefer-const

    var _leafContainer$insert = leafContainer.insertPoint(model.locatorPoints, point, model.maxPointsPerLeaf, pointIdx, 2, model.numberOfNodes);

    numberOfNodes = _leafContainer$insert.numberOfNodes;
    pointIdx = _leafContainer$insert.pointIdx;
    model.numberOfNodes = numberOfNodes;
    return {
      success: true,
      idx: pointIdx
    };
  }; //------------------------------------------------------------------------------


  publicAPI.insertNextPoint = function (x) {
    var leafContainer = getLeafContainer(model.octreeRootNode, x);

    var _leafContainer$insert2 = leafContainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, -1, 2, model.numberOfNodes),
        numberOfNodes = _leafContainer$insert2.numberOfNodes,
        pointIdx = _leafContainer$insert2.pointIdx;

    model.numberOfNodes = numberOfNodes;
    return pointIdx;
  }; //------------------------------------------------------------------------------


  publicAPI.isInsertedPointForZeroTolerance = function (x) {
    // the target leaf node always exists there since the root node of the
    // octree has been initialized to cover all possible points to be inserted
    // and therefore we do not need to check it here
    var leafContainer = getLeafContainer(model.octreeRootNode, x);
    var pointIdx = publicAPI.findDuplicatePointInLeafNode(leafContainer, x);
    return {
      pointIdx: pointIdx,
      leafContainer: leafContainer
    };
  }; //------------------------------------------------------------------------------


  publicAPI.isInsertedPointForNonZeroTolerance = function (x) {
    // minDist2 // min distance to ALL existing points
    // elseDst2 // min distance to other nodes (inner boundaries)
    var dist2Ext; // min distance to an EXTended set of nodes

    var pntIdExt; // the target leaf node always exists there since the root node of the
    // octree has been initialized to cover all possible points to be inserted
    // and therefore we do not need to check it here

    var leafContainer = getLeafContainer(model.octreeRootNode, x);

    var _publicAPI$findCloses3 = publicAPI.findClosestPointInLeafNode(leafContainer, x),
        _publicAPI$findCloses4 = _slicedToArray(_publicAPI$findCloses3, 2),
        pointIdx = _publicAPI$findCloses4[0],
        minDist2 = _publicAPI$findCloses4[1];

    if (minDist2 === 0.0) {
      return {
        pointIdx: pointIdx,
        leafContainer: leafContainer
      };
    } // As no any 'duplicate' point exists in this leaf node, we need to expand
    // the search scope to capture possible closer points in other nodes.


    var elseDst2 = leafContainer.getDistance2ToInnerBoundary(x, model.octreeRootNode);

    if (elseDst2 < model.insertTolerance2) {
      // one or multiple closer points might exist in the neighboring nodes
      // TODO: dist2Ext
      pntIdExt = publicAPI.findClosestPointInSphereWithTolerance(x, model.insertTolerance2, leafContainer, dist2Ext);

      if (dist2Ext < minDist2) {
        minDist2 = dist2Ext;
        pointIdx = pntIdExt;
      }
    }

    pointIdx = minDist2 <= model.insertTolerance2 ? pointIdx : -1;
    return {
      pointIdx: pointIdx,
      leafContainer: leafContainer
    };
  }; //------------------------------------------------------------------------------


  publicAPI.isInsertedPoint = function (x, leafContainer) {
    return model.insertTolerance2 === 0.0 ? publicAPI.isInsertedPointForZeroTolerance(x, leafContainer) : publicAPI.isInsertedPointForNonZeroTolerance(x, leafContainer);
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


function defaultValues(initialValues) {
  return _objectSpread({
    fudgeFactor: 0,
    octreeMaxDimSize: 0,
    buildCubicOctree: false,
    maxPointsPerLeaf: 128,
    insertTolerance2: 0.000001,
    locatorPoints: null,
    octreeRootNode: null,
    numberOfNodes: 0
  }, initialValues);
} // ----------------------------------------------------------------------------


function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  vtkAbstractPointLocator.extend(publicAPI, model, defaultValues(initialValues)); // Make this a VTK object

  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['fudgeFactor', 'octreeMaxDimSize', 'buildCubicOctree', 'maxPointsPerLeaf', 'insertTolerance2', 'locatorPoints', 'octreeRootNode', 'numberOfNodes']); // Object specific methods

  vtkIncrementalOctreePointLocator(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkIncrementalOctreePointLocator'); // ----------------------------------------------------------------------------

var vtkIncrementalOctreePointLocator$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkIncrementalOctreePointLocator$1 as default, extend, newInstance };
