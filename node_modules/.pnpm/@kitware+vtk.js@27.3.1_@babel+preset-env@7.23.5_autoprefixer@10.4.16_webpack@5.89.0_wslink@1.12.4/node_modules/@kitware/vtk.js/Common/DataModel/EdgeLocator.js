import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';

var EdgeLocator = /*#__PURE__*/function () {
  function EdgeLocator() {
    var oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck(this, EdgeLocator);

    this.oriented = oriented;
    this.edgeMap = new Map();
  }

  _createClass(EdgeLocator, [{
    key: "initialize",
    value: function initialize() {
      this.edgeMap.clear();
    }
  }, {
    key: "computeEdgeKey",
    value: function computeEdgeKey(pointId0, pointId1) {
      return this.oriented || pointId0 < pointId1 ? // Cantor pairing function:
      0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;
    }
  }, {
    key: "insertUniqueEdge",
    value: function insertUniqueEdge(pointId0, pointId1, newEdgeValue) {
      // Generate a unique key
      var key = this.computeEdgeKey(pointId0, pointId1);
      var node = this.edgeMap.get(key);

      if (!node) {
        // Didn't find key, so add a new edge entry
        node = {
          key: key,
          edgeId: this.edgeMap.size,
          value: newEdgeValue
        };
        this.edgeMap.set(key, node);
      }

      return node;
    }
  }, {
    key: "insertEdge",
    value: function insertEdge(pointId0, pointId1, newEdgeValue) {
      // Generate a unique key
      var key = this.computeEdgeKey(pointId0, pointId1);
      var node = {
        key: key,
        edgeId: this.edgeMap.size,
        value: newEdgeValue
      };
      this.edgeMap.set(key, node);
      return node;
    }
  }, {
    key: "isInsertedEdge",
    value: function isInsertedEdge(pointId0, pointId1) {
      var key = this.computeEdgeKey(pointId0, pointId1);
      return this.edgeMap.get(key);
    }
  }], [{
    key: "getEdgePointIds",
    value: function getEdgePointIds(node) {
      var n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));
      var pointId0 = node.key - 0.5 * (n + 1) * n;
      var pointId1 = n - pointId0;
      return [pointId0, pointId1];
    }
  }]);

  return EdgeLocator;
}();

function newInstance() {
  var initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new EdgeLocator(initialValues.oriented);
}

var vtkEdgeLocator = {
  newInstance: newInstance
};

export { vtkEdgeLocator as default };
