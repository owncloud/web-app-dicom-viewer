import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';
import vtkCell from './Cell.js';
import { e as distance2BetweenPoints } from '../Core/Math/index.js';
import { CellType } from './CellTypes/Constants.js';
import vtkTriangle from './Triangle.js';
import vtkPoints from '../Core/Points.js';

function intersectionStruct() {
  return {
    intersected: false,
    subId: -1,
    x: [0.0, 0.0, 0.0],
    pCoords: [0.0, 0.0, 0.0],
    t: -1
  };
}

function vtkQuad(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkQuad');

  publicAPI.getCellDimension = function () {
    return 2;
  };

  publicAPI.getCellType = function () {
    return CellType.VTK_QUAD;
  };

  publicAPI.getNumberOfEdges = function () {
    return 4;
  };

  publicAPI.getNumberOfFaces = function () {
    return 0;
  };

  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {
    var _points, _points2, _points3, _points4, _points5, _points6, _points7, _points8, _points9, _points10, _points11, _points12;

    var outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    var diagonalCase;
    var point0 = model.points.getPoint(0, []);
    var point1 = model.points.getPoint(1, []);
    var point2 = model.points.getPoint(2, []);
    var point3 = model.points.getPoint(3, []);
    var d1 = distance2BetweenPoints(point0, point2);
    var d2 = distance2BetweenPoints(point1, point3);
    /* Figure out how to uniquely tessellate the quad. Watch out for
     * equivalent triangulations (i.e., the triangulation is equivalent
     * no matter where the diagonal). In this case use the point ids as
     * a tie breaker to ensure unique triangulation across the quad.
     */
    // rare case; discriminate based on point id

    if (d1 === d2) {
      // find the maximum id
      var id;
      var maxId = 0;
      var maxIdx = 0;

      for (var i = 0; i < 4; i++) {
        id = model.pointsIds[i];

        if (id > maxId) {
          maxId = id;
          maxIdx = i;
        }
      }

      if (maxIdx === 0 || maxIdx === 2) {
        diagonalCase = 0;
      } else {
        diagonalCase = 1;
      }
    } else if (d1 < d2) {
      diagonalCase = 0;
    } else {
      diagonalCase = 1;
    }

    var points = null;

    if (!model.triangle) {
      model.triangle = vtkTriangle.newInstance();
      points = vtkPoints.newInstance();
      points.setNumberOfPoints(3);
      model.triangle.initialize(points);
    } else {
      points = model.triangle.getPoints();
    }

    var firstIntersect;
    var firstIntersectTmpObj = intersectionStruct();
    var secondIntersect;
    var secondIntersectTmpObj = intersectionStruct();
    var useFirstIntersection;
    var useSecondIntersection;

    switch (diagonalCase) {
      case 0:
        (_points = points).setPoint.apply(_points, [0].concat(_toConsumableArray(point0)));

        (_points2 = points).setPoint.apply(_points2, [1].concat(_toConsumableArray(point1)));

        (_points3 = points).setPoint.apply(_points3, [2].concat(_toConsumableArray(point2)));

        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);

        (_points4 = points).setPoint.apply(_points4, [0].concat(_toConsumableArray(point2)));

        (_points5 = points).setPoint.apply(_points5, [1].concat(_toConsumableArray(point3)));

        (_points6 = points).setPoint.apply(_points6, [2].concat(_toConsumableArray(point0)));

        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;

        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1.0 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }

        break;

      case 1:
        (_points7 = points).setPoint.apply(_points7, [0].concat(_toConsumableArray(point0)));

        (_points8 = points).setPoint.apply(_points8, [1].concat(_toConsumableArray(point1)));

        (_points9 = points).setPoint.apply(_points9, [2].concat(_toConsumableArray(point3)));

        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);

        (_points10 = points).setPoint.apply(_points10, [0].concat(_toConsumableArray(point2)));

        (_points11 = points).setPoint.apply(_points11, [1].concat(_toConsumableArray(point3)));

        (_points12 = points).setPoint.apply(_points12, [2].concat(_toConsumableArray(point1)));

        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;

        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }

        break;
    }

    return outObj;
  };

  publicAPI.interpolationFunctions = function (pcoords, weights) {
    var rm = 1 - pcoords[0];
    var sm = 1 - pcoords[1];
    weights[0] = rm * sm;
    weights[1] = pcoords[0] * sm;
    weights[2] = pcoords[0] * pcoords[1];
    weights[3] = rm * pcoords[1];
  };

  publicAPI.evaluateLocation = function (pcoords, x, weights) {
    var point = []; // Calculate the weights

    publicAPI.interpolationFunctions(pcoords, weights);
    x[0] = 0.0;
    x[1] = 0.0;
    x[2] = 0.0;

    for (var i = 0; i < 4; i++) {
      model.points.getPoint(i, point);

      for (var j = 0; j < 3; j++) {
        x[j] += point[j] * weights[i];
      }
    }
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkCell.extend(publicAPI, model, initialValues);
  vtkQuad(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkQuad'); // ----------------------------------------------------------------------------

var vtkQuad$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkQuad$1 as default, extend, newInstance };
