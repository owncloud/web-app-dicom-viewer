import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkCell from './Cell.js';
import vtkLine from './Line.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function vtkPolyLine(publicAPI, model) {
  model.classHierarchy.push('vtkPolyLine');

  var superClass = _objectSpread({}, publicAPI);

  var line = vtkLine.newInstance();
  line.getPoints().setNumberOfPoints(2);

  publicAPI.getCellDimension = function () {
    return 1;
  };

  publicAPI.intersectWithLine = function (t1, t2, p1, p2, tol, x, pcoords) {
    var outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    var numLines = superClass.getPoints().getNumberOfPoints() - 1;
    var pDistMin = Number.MAX_VALUE;

    for (var subId = 0; subId < numLines; subId++) {
      var pCoords = [0, 0, 0];
      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
      var lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);

      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {
        outObj.intersect = 1;
        var pDist = line.getParametricDistance(pCoords);

        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {
          outObj.subId = subId;
          outObj.t = lineIntersected.t;
          pDistMin = pDist;
        }
      }
    }

    return outObj;
  };

  publicAPI.evaluateLocation = function (subId, pcoords, x, weights) {
    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
    return line.evaluateLocation(pcoords, x, weights);
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkCell.extend(publicAPI, model, initialValues);
  vtkPolyLine(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkPolyLine'); // ----------------------------------------------------------------------------

var vtkPolyLine$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkPolyLine$1 as default, extend, newInstance };
