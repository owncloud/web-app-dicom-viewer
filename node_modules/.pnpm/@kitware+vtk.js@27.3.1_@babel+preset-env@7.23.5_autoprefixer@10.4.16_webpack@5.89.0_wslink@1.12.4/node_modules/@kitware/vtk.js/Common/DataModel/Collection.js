import macro from '../../macros.js';

var vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------
// vtkCollection methods
// ----------------------------------------------------------------------------

function vtkCollection(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCollection');

  publicAPI.addItem = function (item) {
    model.collection.push(item);
    publicAPI.modified();
  };

  publicAPI.insertItem = function (idx, item) {
    if (idx < 0 || model.collection.length < idx) {
      vtkErrorMacro('idx out of bounds for insertion.');
    }

    model.collection.splice(idx, 0, item);
    publicAPI.modified();
  };

  publicAPI.replaceItem = function (idx, item) {
    model.collection.splice(idx, 1, item);
    publicAPI.modified();
  };

  publicAPI.removeItem = function (inValue) {
    var idx = typeof inValue === 'number' ? inValue : model.collection.indexOf(inValue);

    if (idx >= 0 && idx < model.collection.length) {
      model.collection.splice(idx, 1);
      publicAPI.modified();
    } else {
      vtkErrorMacro('idx out of bounds for removeItem.');
    }
  };

  publicAPI.removeAllItems = function () {
    model.collection = [];
    publicAPI.modified();
  };

  publicAPI.isItemPresent = function (item) {
    return model.collection.includes(item);
  };

  publicAPI.getNumberOfItems = function () {
    return model.collection.length;
  };

  publicAPI.empty = function () {
    return model.collection.length === 0;
  };

  publicAPI.getItem = function (idx) {
    return model.collection[idx];
  };

  publicAPI.forEach = function (ftor) {
    model.collection.forEach(ftor); // Call modified() for the collection, since ftor could have modified the elements.

    publicAPI.updateMTimeWithElements();
  };

  publicAPI.reduce = function (ftor, initialValue) {
    return model.collection.reduce(ftor, initialValue);
  };

  publicAPI.map = function (ftor) {
    return model.collection.map(ftor);
  };

  publicAPI.updateMTimeWithElements = function () {
    var maxMTimeOfItems = 0; // we expect time values to be positive numbers

    for (var i = 0; i < model.collection.length; ++i) {
      var elem = model.collection[i];
      maxMTimeOfItems = Math.max(maxMTimeOfItems, elem.getMTime());
    }

    if (maxMTimeOfItems > publicAPI.getMTime()) {
      publicAPI.modified();
    }
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  collection: []
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods

  macro.obj(publicAPI, model); // Object specific methods

  vtkCollection(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkCollection'); // ----------------------------------------------------------------------------

var index = {
  newInstance: newInstance,
  extend: extend
};

export { index as default, extend, newInstance };
