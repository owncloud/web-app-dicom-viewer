import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';

// vtkStringArray methods
// ----------------------------------------------------------------------------

function vtkStringArray(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkStringArray'); // Description:
  // Return the data component at the location specified by tupleIdx and
  // compIdx.

  publicAPI.getComponent = function (tupleIdx) {
    var compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  }; // Description:
  // Set the data component at the location specified by tupleIdx and compIdx
  // to value.
  // Note that i is less than NumberOfTuples and j is less than
  //  NumberOfComponents. Make sure enough memory has been allocated
  // (use SetNumberOfTuples() and SetNumberOfComponents()).


  publicAPI.setComponent = function (tupleIdx, compIdx, value) {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.modified();
    }
  };

  publicAPI.getData = function () {
    return model.values;
  };

  publicAPI.getTuple = function (idx) {
    var tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var numberOfComponents = model.numberOfComponents || 1;

    if (tupleToFill.length) {
      tupleToFill.length = numberOfComponents;
    }

    var offset = idx * numberOfComponents;

    for (var i = 0; i < numberOfComponents; i++) {
      tupleToFill[i] = model.values[offset + i];
    }

    return tupleToFill;
  };

  publicAPI.getTupleLocation = function () {
    var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };

  publicAPI.getNumberOfComponents = function () {
    return model.numberOfComponents;
  };

  publicAPI.getNumberOfValues = function () {
    return model.values.length;
  };

  publicAPI.getNumberOfTuples = function () {
    return model.values.length / model.numberOfComponents;
  };

  publicAPI.getDataType = function () {
    return model.dataType;
  };
  /* eslint-disable no-use-before-define */


  publicAPI.newClone = function () {
    return newInstance({
      name: model.name,
      numberOfComponents: model.numberOfComponents
    });
  };
  /* eslint-enable no-use-before-define */


  publicAPI.getName = function () {
    if (!model.name) {
      publicAPI.modified();
      model.name = "vtkStringArray".concat(publicAPI.getMTime());
    }

    return model.name;
  };

  publicAPI.setData = function (array, numberOfComponents) {
    model.values = array;
    model.size = array.length;

    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }

    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }

    publicAPI.modified();
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  name: '',
  numberOfComponents: 1,
  size: 0,
  // values: null,
  dataType: 'string'
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  if (!model.empty && !model.values && !model.size) {
    throw new TypeError('Cannot create vtkStringArray object without: size > 0, values');
  }

  if (!model.values) {
    model.values = [];
  } else if (Array.isArray(model.values)) {
    model.values = _toConsumableArray(model.values);
  }

  if (model.values) {
    model.size = model.values.length;
  } // Object methods


  macro.obj(publicAPI, model);
  macro.set(publicAPI, model, ['name']); // Object specific methods

  vtkStringArray(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkStringArray'); // ----------------------------------------------------------------------------

var vtkStringArray$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkStringArray$1 as default, extend, newInstance };
