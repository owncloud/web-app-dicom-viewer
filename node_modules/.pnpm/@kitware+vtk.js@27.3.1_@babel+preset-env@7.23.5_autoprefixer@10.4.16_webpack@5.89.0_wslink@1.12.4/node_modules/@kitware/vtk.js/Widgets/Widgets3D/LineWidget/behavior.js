import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import Constants from './Constants.js';
import macro from '../../../macros.js';
import { s as subtract, k as add, l as normalize } from '../../../Common/Core/Math/index.js';
import { getNumberOfPlacedHandles, isHandlePlaced, calculateTextPosition, updateTextPosition, getPoint } from './helpers.js';

var ShapeType = Constants.ShapeType; // Total number of points to place

var MAX_POINTS = 2;
var handleGetters = ['getHandle1', 'getHandle2', 'getMoveHandle'];
function widgetBehavior(publicAPI, model) {
  model.classHierarchy.push('vtkLineWidgetProp');
  model._isDragging = false;
  /**
   * Returns the handle at the handleIndex'th index.
   * @param {number} handleIndex 0, 1 or 2
   */

  publicAPI.getHandle = function (handleIndex) {
    return model.widgetState[handleGetters[handleIndex]]();
  };
  /**
   * Return the index in the of tbe handle in `representations` array,
   * or -1 if the handle is not present in the widget state.
   */


  publicAPI.getHandleIndex = function (handle) {
    switch (handle) {
      case model.widgetState.getHandle1():
        return 0;

      case model.widgetState.getHandle2():
        return 1;

      case model.widgetState.getMoveHandle():
        return 2;

      default:
        return -1;
    }
  };

  publicAPI.isPlaced = function () {
    return getNumberOfPlacedHandles(model.widgetState) === MAX_POINTS;
  }; // --------------------------------------------------------------------------
  // Interactor event
  // --------------------------------------------------------------------------


  function ignoreKey(e) {
    return e.altKey || e.controlKey || e.shiftKey;
  }

  function updateCursor(callData) {
    var _model$activeState$ge, _model$activeState, _model$activeState$ge2;

    model._isDragging = true;
    var manipulator = (_model$activeState$ge = (_model$activeState = model.activeState) === null || _model$activeState === void 0 ? void 0 : (_model$activeState$ge2 = _model$activeState.getManipulator) === null || _model$activeState$ge2 === void 0 ? void 0 : _model$activeState$ge2.call(_model$activeState)) !== null && _model$activeState$ge !== void 0 ? _model$activeState$ge : model.manipulator;
    model.previousPosition = _toConsumableArray(manipulator.handleEvent(callData, model._apiSpecificRenderWindow));

    model._apiSpecificRenderWindow.setCursor('grabbing');

    model._interactor.requestAnimation(publicAPI);
  } // --------------------------------------------------------------------------
  // Text methods
  // --------------------------------------------------------------------------


  publicAPI.setText = function (text) {
    model.widgetState.getText().setText(text);

    model._interactor.render();
  }; // --------------------------------------------------------------------------
  // Handle positioning methods
  // --------------------------------------------------------------------------
  // Handle utilities ---------------------------------------------------------


  function getLineDirection(p1, p2) {
    var dir = subtract(p1, p2, []);
    normalize(dir);
    return dir;
  } // Handle orientation & rotation ---------------------------------------------------------


  function computeMousePosition(p1, callData) {
    var displayMousePos = publicAPI.computeWorldToDisplay.apply(publicAPI, [model._renderer].concat(_toConsumableArray(p1)));
    var worldMousePos = publicAPI.computeDisplayToWorld(model._renderer, callData.position.x, callData.position.y, displayMousePos[2]);
    return worldMousePos;
  }
  /**
   * Returns the  handle orientation to match the direction vector of the polyLine from one tip to another
   * @param {number} handleIndex 0 for handle1, 1 for handle2
   * @param {object} callData if specified, uses mouse position as 2nd point
   */


  function getHandleOrientation(handleIndex) {
    var callData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var point1 = getPoint(handleIndex, model.widgetState);
    var point2 = callData ? computeMousePosition(point1, callData) : getPoint(1 - handleIndex, model.widgetState);
    return point1 && point2 ? getLineDirection(point1, point2) : null;
  }
  /**
   * Orient handle
   * @param {number} handleIndex 0, 1 or 2
   * @param {object} callData optional, see getHandleOrientation for details.
   */


  function updateHandleOrientation(handleIndex) {
    var orientation = getHandleOrientation(Math.min(1, handleIndex));
    model.representations[handleIndex].setOrientation(orientation);
  }

  publicAPI.updateHandleOrientations = function () {
    updateHandleOrientation(0);
    updateHandleOrientation(1);
    updateHandleOrientation(2);
  };

  publicAPI.rotateHandlesToFaceCamera = function () {
    model.representations[0].setViewMatrix(Array.from(model._camera.getViewMatrix()));
    model.representations[1].setViewMatrix(Array.from(model._camera.getViewMatrix()));
  }; // Handles visibility ---------------------------------------------------------

  /**
   * Set actor visibility to true unless it is a NONE handle
   * and uses state visibility variable for the displayActor visibility to
   * allow pickable handles even when they are not displayed on screen
   * @param handle : the handle state object
   * @param handleNb : the handle number according to its label in widget state
   */


  publicAPI.updateHandleVisibility = function (handleIndex) {
    var handle = publicAPI.getHandle(handleIndex);
    var visibility = handle.getVisible() && isHandlePlaced(handleIndex, model.widgetState);
    model.representations[handleIndex].setVisibilityFlagArray([visibility, visibility && handle.getShape() !== ShapeType.NONE]);
    model.representations[handleIndex].updateActorVisibility();

    model._interactor.render();
  };
  /**
   * Called when placing a point from the first time.
   * @param {number} handleIndex
   */


  publicAPI.placeHandle = function (handleIndex) {
    var handle = publicAPI.getHandle(handleIndex);
    handle.setOrigin.apply(handle, _toConsumableArray(model.widgetState.getMoveHandle().getOrigin()));
    publicAPI.updateHandleOrientations();
    publicAPI.rotateHandlesToFaceCamera();
    model.widgetState.getText().setOrigin(calculateTextPosition(model));
    publicAPI.updateHandleVisibility(handleIndex);

    if (handleIndex === 0) {
      var _publicAPI$getHandle;

      // For the line (handle1, handle2, moveHandle) to be displayed
      // correctly, handle2 origin must be valid.
      (_publicAPI$getHandle = publicAPI.getHandle(1)).setOrigin.apply(_publicAPI$getHandle, _toConsumableArray(model.widgetState.getMoveHandle().getOrigin())); // Now that handle2 has a valid origin, hide it


      publicAPI.updateHandleVisibility(1);
      model.widgetState.getMoveHandle().setShape(publicAPI.getHandle(1).getShape());
    }

    if (handleIndex === 1) {
      publicAPI.loseFocus();
    }
  }; // --------------------------------------------------------------------------
  // Left press: Select handle to drag
  // --------------------------------------------------------------------------


  publicAPI.handleLeftButtonPress = function (e) {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable || ignoreKey(e)) {
      return macro.VOID;
    }

    if (model.activeState === model.widgetState.getMoveHandle() && getNumberOfPlacedHandles(model.widgetState) === 0) {
      publicAPI.placeHandle(0);
    } else if (model.widgetState.getMoveHandle().getActive() && getNumberOfPlacedHandles(model.widgetState) === 1) {
      publicAPI.placeHandle(1);
    } else if (model.dragable && !model.widgetState.getText().getActive()) {
      // Grab handle1, handle2 or whole widget
      updateCursor(e);
    }

    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  }; // --------------------------------------------------------------------------
  // Mouse move: Drag selected handle / Handle follow the mouse
  // --------------------------------------------------------------------------


  publicAPI.handleMouseMove = function (callData) {
    var _model$activeState$ge3, _model$activeState2, _model$activeState2$g;

    var manipulator = (_model$activeState$ge3 = (_model$activeState2 = model.activeState) === null || _model$activeState2 === void 0 ? void 0 : (_model$activeState2$g = _model$activeState2.getManipulator) === null || _model$activeState2$g === void 0 ? void 0 : _model$activeState2$g.call(_model$activeState2)) !== null && _model$activeState$ge3 !== void 0 ? _model$activeState$ge3 : model.manipulator;

    if (manipulator && model.pickable && model.dragable && model.activeState && model.activeState.getActive() && !ignoreKey(callData)) {
      var worldCoords = manipulator.handleEvent(callData, model._apiSpecificRenderWindow);
      var translation = model.previousPosition ? subtract(worldCoords, model.previousPosition, []) : [0, 0, 0];
      model.previousPosition = worldCoords;

      if ( // is placing first or second handle
      model.activeState === model.widgetState.getMoveHandle() || // is dragging already placed first or second handle
      model._isDragging) {
        if (model.activeState.setOrigin) {
          model.activeState.setOrigin(worldCoords);
          publicAPI.updateHandleVisibility(publicAPI.getHandleIndex(model.activeState));
        } else {
          // Dragging line
          publicAPI.getHandle(0).setOrigin(add(publicAPI.getHandle(0).getOrigin(), translation, []));
          publicAPI.getHandle(1).setOrigin(add(publicAPI.getHandle(1).getOrigin(), translation, []));
        }

        publicAPI.updateHandleOrientations();
        updateTextPosition(model);
        publicAPI.invokeInteractionEvent();
        return macro.EVENT_ABORT;
      }
    }

    return macro.VOID;
  }; // --------------------------------------------------------------------------
  // Left release: Finish drag
  // --------------------------------------------------------------------------


  publicAPI.handleLeftButtonRelease = function () {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      publicAPI.rotateHandlesToFaceCamera();
      return macro.VOID;
    }

    if (model.hasFocus && publicAPI.isPlaced()) {
      publicAPI.loseFocus();
      return macro.VOID;
    }

    if (model._isDragging && publicAPI.isPlaced()) {
      var wasTextActive = model.widgetState.getText().getActive(); // Recompute offsets

      model.widgetState.deactivate();
      model.activeState = null;

      if (!wasTextActive) {
        model._interactor.cancelAnimation(publicAPI);
      }

      model._apiSpecificRenderWindow.setCursor('pointer');

      model.hasFocus = false;
      model._isDragging = false;
    } else if (model.activeState !== model.widgetState.getMoveHandle()) {
      model.widgetState.deactivate();
    }

    if (model.hasFocus && !model.activeState || model.activeState && !model.activeState.getActive()) {
      model._widgetManager.enablePicking();

      model._interactor.render();
    }

    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  }; // --------------------------------------------------------------------------
  // Focus API - moveHandle follow mouse when widget has focus
  // --------------------------------------------------------------------------


  publicAPI.grabFocus = function () {
    if (!model.hasFocus && !publicAPI.isPlaced()) {
      model.activeState = model.widgetState.getMoveHandle();
      model.activeState.setShape(publicAPI.getHandle(0).getShape());
      model.activeState.activate();

      model._interactor.requestAnimation(publicAPI);

      publicAPI.invokeStartInteractionEvent();
    }

    model.hasFocus = true;
  }; // --------------------------------------------------------------------------


  publicAPI.loseFocus = function () {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);

      publicAPI.invokeEndInteractionEvent();
    }

    model.widgetState.deactivate();
    model.widgetState.getMoveHandle().deactivate();
    model.widgetState.getMoveHandle().setOrigin(null);
    model.activeState = null;
    model.hasFocus = false;

    model._widgetManager.enablePicking();

    model._interactor.render();
  };

  publicAPI.reset = function () {
    model.widgetState.deactivate();
    model.widgetState.getMoveHandle().deactivate();
    model.widgetState.getHandle1().setOrigin(null);
    model.widgetState.getHandle2().setOrigin(null);
    model.widgetState.getMoveHandle().setOrigin(null);
    model.widgetState.getText().setOrigin(null);
    model.widgetState.getText().setText('');
    model.activeState = null;
  };
}

export { widgetBehavior as default };
