import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import vtkBoundingBox, { STATIC } from '../../../Common/DataModel/BoundingBox.js';
import vtkCubeSource from '../../../Filters/Sources/CubeSource.js';
import vtkCutter from '../../../Filters/Core/Cutter.js';
import vtkPlane from '../../../Common/DataModel/Plane.js';
import { s as subtract, l as normalize, j as cross, w as multiplyScalar, m as multiplyAccumulate, S as signedAngleBetweenVectors } from '../../../Common/Core/Math/index.js';
import vtkMatrixBuilder from '../../../Common/Core/MatrixBuilder.js';
import { ViewTypes } from '../../Core/WidgetManager/Constants.js';
import { planeNames, lineNames, planeNameToViewType } from './Constants.js';

var EPSILON = 10e-7;
/**
 * Fit the plane defined by origin, p1, p2 onto the bounds.
 * Plane is untouched if does not intersect bounds.
 * @param {Array} bounds
 * @param {Array} origin
 * @param {Array} p1
 * @param {Array} p2
 * @return {Boolean} false if no bounds have been found, else true
 */

function boundPlane(bounds, origin, p1, p2) {
  var v1 = [];
  subtract(p1, origin, v1);
  normalize(v1);
  var v2 = [];
  subtract(p2, origin, v2);
  normalize(v2);
  var n = [0, 0, 1];
  cross(v1, v2, n);
  normalize(n); // Inflate bounds in order to avoid precision error when cutting cubesource

  var inflatedBounds = _toConsumableArray(bounds);

  var eps = [].concat(n);
  multiplyScalar(eps, EPSILON);
  vtkBoundingBox.addBounds(inflatedBounds, bounds[0] + eps[0], bounds[1] + eps[0], bounds[2] + eps[1], bounds[3] + eps[1], bounds[4] + eps[2], bounds[5] + eps[2]);
  vtkBoundingBox.addBounds(inflatedBounds, bounds[0] - eps[0], bounds[1] - eps[0], bounds[2] - eps[1], bounds[3] - eps[1], bounds[4] - eps[2], bounds[5] - eps[2]);
  var plane = vtkPlane.newInstance();
  plane.setOrigin.apply(plane, _toConsumableArray(origin));
  plane.setNormal.apply(plane, n);
  var cubeSource = vtkCubeSource.newInstance();
  cubeSource.setBounds(inflatedBounds);
  var cutter = vtkCutter.newInstance();
  cutter.setCutFunction(plane);
  cutter.setInputConnection(cubeSource.getOutputPort());
  var cutBounds = cutter.getOutputData();

  if (cutBounds.getNumberOfPoints() === 0) {
    return false;
  }

  var localBounds = STATIC.computeLocalBounds(cutBounds.getPoints(), v1, v2, n);

  for (var i = 0; i < 3; i += 1) {
    origin[i] = localBounds[0] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];
    p1[i] = localBounds[1] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];
    p2[i] = localBounds[0] * v1[i] + localBounds[3] * v2[i] + localBounds[4] * n[i];
  }

  return true;
} // Project point (inPoint) to the bounds of the image according to a plane
// defined by two vectors (v1, v2)

function boundPoint(inPoint, v1, v2, bounds) {
  var absT1 = v1.map(function (val) {
    return Math.abs(val);
  });
  var absT2 = v2.map(function (val) {
    return Math.abs(val);
  });
  var o1 = 0.0;
  var o2 = 0.0;

  for (var i = 0; i < 3; i++) {
    var axisOffset = 0;
    var useT1 = absT1[i] > absT2[i];
    var t = useT1 ? v1 : v2;
    var absT = useT1 ? absT1 : absT2;

    if (inPoint[i] < bounds[i * 2]) {
      axisOffset = absT[i] > EPSILON ? (bounds[2 * i] - inPoint[i]) / t[i] : 0;
    } else if (inPoint[i] > bounds[2 * i + 1]) {
      axisOffset = absT[i] > EPSILON ? (bounds[2 * i + 1] - inPoint[i]) / t[i] : 0;
    }

    if (useT1) {
      if (Math.abs(axisOffset) > Math.abs(o1)) {
        o1 = axisOffset;
      }
    } else if (Math.abs(axisOffset) > Math.abs(o2)) {
      o2 = axisOffset;
    }
  }

  var outPoint = [inPoint[0], inPoint[1], inPoint[2]];

  if (o1 !== 0.0) {
    multiplyAccumulate(outPoint, v1, o1, outPoint);
  }

  if (o2 !== 0.0) {
    multiplyAccumulate(outPoint, v2, o2, outPoint);
  }

  return outPoint;
} // Compute the intersection between p1 and p2 on bounds

function boundPointOnPlane(p1, p2, bounds) {
  var dir12 = [0, 0, 0];
  subtract(p2, p1, dir12);
  var out = [0, 0, 0];
  var tolerance = [0, 0, 0];
  vtkBoundingBox.intersectBox(bounds, p1, dir12, out, tolerance);
  return out;
}
/**
 * Rotates a vector around another.
 * @param {vec3} vectorToBeRotated Vector to rate
 * @param {vec3} axis Axis to rotate around
 * @param {Number} angle Angle in radian
 * @returns The rotated vector
 */

function rotateVector(vectorToBeRotated, axis, angle) {
  var rotatedVector = _toConsumableArray(vectorToBeRotated);

  vtkMatrixBuilder.buildFromRadian().rotate(angle, axis).apply(rotatedVector);
  return rotatedVector;
}
/**
 * Return X if lineName == XinY|XinZ, Y if lineName == YinX|YinZ and Z otherwise
 * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)
 */

function getLinePlaneName(lineName) {
  return lineName[0];
}
/**
 * Return X if lineName == YinX|ZinX, Y if lineName == XinY|ZinY and Z otherwise
 * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)
 */

function getLineInPlaneName(lineName) {
  return lineName[3];
}
/**
 * Return ZinX if lineName == YinX, YinX if lineName == ZinX, ZinY if lineName == XinY...
 * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)
 */

function getOtherLineName(lineName) {
  var linePlaneName = getLinePlaneName(lineName);
  var lineInPlaneName = getLineInPlaneName(lineName);
  var otherLineName = planeNames.find(function (planeName) {
    return planeName !== linePlaneName && planeName !== lineInPlaneName;
  });
  return "".concat(otherLineName, "in").concat(lineInPlaneName);
} // Compute the offset of the rotation handle origin

function computeRotationHandleOriginOffset(axis, rotationHandlePosition, volumeDiagonalLength, scaleInPixels) {
  // FIXME: p1 and p2 could be placed on the exact boundaries of the volume.
  return multiplyScalar(_toConsumableArray(axis), rotationHandlePosition * (scaleInPixels ? 1 : volumeDiagonalLength) / 2);
} // Update the reslice cursor state according to the three planes normals and the origin


function updateState(widgetState, scaleInPixels, rotationHandlePosition) {
  // Compute line axis
  var xNormal = widgetState.getPlanes()[ViewTypes.YZ_PLANE].normal;
  var yNormal = widgetState.getPlanes()[ViewTypes.XZ_PLANE].normal;
  var zNormal = widgetState.getPlanes()[ViewTypes.XY_PLANE].normal;
  var axes = {
    XY: cross(xNormal, yNormal, []),
    YZ: cross(yNormal, zNormal, []),
    XZ: cross(zNormal, xNormal, [])
  };
  axes.YX = axes.XY;
  axes.ZY = axes.YZ;
  axes.ZX = axes.XZ;
  var bounds = widgetState.getImage().getBounds();
  var center = widgetState.getCenter(); // Length of the principal diagonal.

  var pdLength = vtkBoundingBox.getDiagonalLength(bounds);
  widgetState.getCenterHandle().setOrigin(center);
  lineNames.forEach(function (lineName) {
    var planeName = getLinePlaneName(lineName);
    var inPlaneName = getLineInPlaneName(lineName);
    var direction = axes["".concat(planeName).concat(inPlaneName)];
    widgetState["getRotationHandle".concat(lineName, "0")]().setOrigin(center);
    widgetState["getRotationHandle".concat(lineName, "0")]().setOffset(computeRotationHandleOriginOffset(direction, rotationHandlePosition, pdLength, scaleInPixels));
    widgetState["getRotationHandle".concat(lineName, "1")]().setOrigin(center);
    widgetState["getRotationHandle".concat(lineName, "1")]().setOffset(computeRotationHandleOriginOffset(direction, -rotationHandlePosition, pdLength, scaleInPixels));
    var lineHandle = widgetState["getAxis".concat(lineName)]();
    lineHandle.setOrigin(center);
    var scale = normalize(direction);
    var scale3 = lineHandle.getScale3();
    scale3[2] = 2 * scale;
    lineHandle.setScale3(scale3);
    var right = widgetState.getPlanes()[planeNameToViewType[inPlaneName]].normal;
    var up = cross(direction, right, []);
    lineHandle.setRight(right);
    lineHandle.setUp(up);
    lineHandle.setDirection(direction);
  });
}
/**
 * First rotate planeToTransform to match targetPlane normal.
 * Then rotate around targetNormal to enforce targetViewUp "up" vector (i.e. Origin->p2 ).
 * There is an infinite number of options to rotate a plane normal to another. Here we attempt to
 * preserve Origin, P1 and P2 when rotating around targetPlane.
 * @param {vtkPlaneSource} planeToTransform
 * @param {vec3} targetOrigin Center of the plane
 * @param {vec3} targetNormal Normal to state to the plane
 * @param {vec3} viewType Vector that enforces view up
 */

function transformPlane(planeToTransform, targetCenter, targetNormal, targetViewUp) {
  planeToTransform.setNormal(targetNormal);
  var viewUp = subtract(planeToTransform.getPoint2(), planeToTransform.getOrigin(), []);
  var angle = signedAngleBetweenVectors(viewUp, targetViewUp, targetNormal);
  planeToTransform.rotate(angle, targetNormal);
  planeToTransform.setCenter(targetCenter);
}

export { boundPlane, boundPoint, boundPointOnPlane, getLineInPlaneName, getLinePlaneName, getOtherLineName, rotateVector, transformPlane, updateState };
