import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../../macros.js';
import { vec3 } from 'gl-matrix';

function widgetBehavior(publicAPI, model) {
  var state = model.widgetState;
  var moveHandle = state.getMoveHandle();
  var centerHandle = state.getCenterHandle();
  var borderHandle = state.getBorderHandle();
  var shapeHandle = state.getSphereHandle(); // Set while moving the center or border handle.

  model._isDragging = false; // The last world coordinate of the mouse cursor during dragging.

  model.previousPosition = null;
  model.classHierarchy.push('vtkSphereWidgetProp');
  moveHandle.setVisible(true);
  centerHandle.setVisible(false);
  borderHandle.setVisible(false);
  shapeHandle.setVisible(true);

  function isValidHandle(handle) {
    return handle === centerHandle || handle === borderHandle || handle === moveHandle;
  }

  function isPlaced() {
    return !!centerHandle.getOrigin() && !!borderHandle.getOrigin();
  } // Update the sphereHandle parameters from {center,border}Handle.


  function updateSphere() {
    var center = centerHandle.getOrigin();
    if (!center) return;
    centerHandle.setVisible(true);
    var border = borderHandle.getOrigin();

    if (border) {
      borderHandle.setVisible(true);
    } else {
      border = moveHandle.getOrigin();
      if (!border) return;
    }

    if (isPlaced()) {
      moveHandle.setVisible(false);
    }

    var radius = vec3.distance(center, border);
    shapeHandle.setVisible(true);
    shapeHandle.setOrigin(center);
    shapeHandle.setScale1(radius * 2);

    model._interactor.render();
  }

  function currentWorldCoords(e) {
    var _model$activeState$ge, _model$activeState, _model$activeState$ge2;

    var manipulator = (_model$activeState$ge = (_model$activeState = model.activeState) === null || _model$activeState === void 0 ? void 0 : (_model$activeState$ge2 = _model$activeState.getManipulator) === null || _model$activeState$ge2 === void 0 ? void 0 : _model$activeState$ge2.call(_model$activeState)) !== null && _model$activeState$ge !== void 0 ? _model$activeState$ge : model.manipulator;
    return manipulator.handleEvent(e, model._apiSpecificRenderWindow);
  } // Update the sphere's center and radius.  Example:
  // handle.setCenterAndRadius([1,2,3], 10);


  publicAPI.setCenterAndRadius = function (newCenter, newRadius) {
    var oldCenter = centerHandle.getOrigin();
    var oldBorder = borderHandle.getOrigin();
    var newBorder = [newCenter[0] + newRadius, newCenter[1], newCenter[2]];

    if (oldBorder) {
      // Move the boundary handle to reflect the new radius, while preserving
      // its direction relative to the center.
      var direction = vec3.sub(vec3.create(), oldBorder, oldCenter);
      var oldRadius = vec3.length(direction);

      if (oldRadius > 1e-10) {
        newBorder = vec3.add(vec3.create(), newCenter, vec3.scale(vec3.create(), direction, newRadius / oldRadius));
      }
    }

    centerHandle.setOrigin(newCenter);
    borderHandle.setOrigin(newBorder);
    updateSphere();

    model._widgetManager.enablePicking();
  };

  publicAPI.handleLeftButtonPress = function (e) {
    if (!isValidHandle(model.activeState)) {
      model.activeState = null;
      return macro.VOID;
    }

    var worldCoords = currentWorldCoords(e);

    if (model.activeState === moveHandle) {
      // Initial sphere placement.
      if (!centerHandle.getOrigin()) {
        centerHandle.setOrigin(worldCoords);
      } else if (!borderHandle.getOrigin()) {
        borderHandle.setOrigin(worldCoords);
      }

      updateSphere();
    }

    model._isDragging = true;

    model._apiSpecificRenderWindow.setCursor('grabbing');

    model.previousPosition = _toConsumableArray(currentWorldCoords(e));
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };

  publicAPI.handleLeftButtonRelease = function (e) {
    if (!model._isDragging) {
      model.activeState = null;
      return macro.VOID;
    }

    if (isPlaced()) {
      model.previousPosition = null;

      model._widgetManager.enablePicking();

      model._apiSpecificRenderWindow.setCursor('pointer');

      model._isDragging = false;
      model.activeState = null;
      state.deactivate();
    }

    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };

  publicAPI.handleMouseMove = function (e) {
    if (!model._isDragging) {
      model.activeState = null;
      return macro.VOID;
    }

    if (!model.activeState) throw Error('no activestate');
    var worldCoords = currentWorldCoords(e);
    model.activeState.setOrigin(worldCoords);

    if (model.activeState === centerHandle) {
      // When the sphere is fully placed, and the user is moving the
      // center, we move the whole sphere.
      if (borderHandle.getOrigin()) {
        if (!model.previousPosition) {
          // !previousPosition here happens only immediately
          // after grabFocus, but grabFocus resets
          // borderHandle.origin.
          throw Error("no pos ".concat(model.activeState, " ").concat(model.previousPosition));
        }

        var translation = vec3.sub(vec3.create(), worldCoords, model.previousPosition);
        borderHandle.setOrigin(vec3.add(vec3.create(), borderHandle.getOrigin(), translation));
      }
    }

    model.previousPosition = worldCoords;
    updateSphere();
    return macro.VOID;
  };

  publicAPI.grabFocus = function () {
    moveHandle.setVisible(true);
    centerHandle.setVisible(false);
    borderHandle.setVisible(false);
    centerHandle.setOrigin(null);
    borderHandle.setOrigin(null);
    model._isDragging = true;
    model.activeState = moveHandle;

    model._interactor.render();
  };

  publicAPI.loseFocus = function () {
    model._isDragging = false;
    model.activeState = null;
  };
}

export { widgetBehavior as default };
