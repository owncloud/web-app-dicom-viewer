import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../../macros.js';
import vtkBoundingBox from '../../../Common/DataModel/BoundingBox.js';
import vtkLine from '../../../Common/DataModel/Line.js';
import vtkPlanePointManipulator from '../../Manipulators/PlaneManipulator.js';
import { k as add, l as normalize, d as dot, j as cross, s as subtract, m as multiplyAccumulate, w as multiplyScalar, S as signedAngleBetweenVectors } from '../../../Common/Core/Math/index.js';
import { getOtherLineName, updateState, boundPointOnPlane, getLinePlaneName, getLineInPlaneName, rotateVector } from './helpers.js';
import { InteractionMethodsName, lineNames, ScrollingMethods, planeNameToViewType } from './Constants.js';

function widgetBehavior(publicAPI, model) {
  model._isDragging = false;
  var isScrolling = false;
  var previousPosition;
  macro.setGet(publicAPI, model, ['keepOrthogonality']);

  publicAPI.setEnableTranslation = function (enable) {
    model.representations[0].setPickable(enable); // line handle

    model.representations[2].setPickable(enable); // center handle
  };

  publicAPI.setEnableRotation = function (enable) {
    model.representations[1].setPickable(enable); // rotation handle
  }; // FIXME: label information should be accessible from activeState instead of parent state.


  publicAPI.getActiveInteraction = function () {
    if (model.widgetState.getStatesWithLabel('rotation').includes(model.activeState)) {
      return InteractionMethodsName.RotateLine;
    }

    if (model.widgetState.getStatesWithLabel('line').includes(model.activeState)) {
      return InteractionMethodsName.TranslateAxis;
    }

    if (model.widgetState.getStatesWithLabel('center').includes(model.activeState)) {
      return InteractionMethodsName.TranslateCenter;
    }

    return null;
  };
  /**
   * ActiveState can be RotationHandle or a LineHandle
   * @returns 'YinX', 'ZinX', 'XinY', 'ZinY', 'XinZ' or 'YinZ'
   */


  publicAPI.getActiveLineName = function () {
    return lineNames.find(function (lineName) {
      return model.widgetState.getStatesWithLabel(lineName).includes(model.activeState);
    });
  }; // FIXME: label information should be accessible from activeState instead of parent state.


  publicAPI.getActiveLineHandle = function () {
    var _model$widgetState$, _model$widgetState;

    return (_model$widgetState$ = (_model$widgetState = model.widgetState)["getAxis".concat(publicAPI.getActiveLineName())]) === null || _model$widgetState$ === void 0 ? void 0 : _model$widgetState$.call(_model$widgetState);
  };
  /**
   * Return the line handle of the other line in the same view.
   * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)
   * @returns ZinX if lineName == YinX, YinX if lineName == ZinX, ZinY if lineName == XinY...
   */


  publicAPI.getOtherLineHandle = function (lineName) {
    var _model$widgetState$2, _model$widgetState2;

    return (_model$widgetState$2 = (_model$widgetState2 = model.widgetState)["getAxis".concat(getOtherLineName(lineName))]) === null || _model$widgetState$2 === void 0 ? void 0 : _model$widgetState$2.call(_model$widgetState2);
  }; // FIXME: label information should be accessible from activeState instead of parent state.

  /**
   * There are 2 rotation handles per axis: 'point0' and 'point1'.
   * This function returns which rotation handle (point0 or point1) is currently active.
   * ActiveState must be a RotationHandle.
   * @returns 'point0' or 'point1'
   */


  publicAPI.getActiveRotationPointName = function () {
    return model.widgetState.getStatesWithLabel('point0').includes(model.activeState) ? 'point0' : 'point1';
  };

  publicAPI.startScrolling = function (newPosition) {
    if (newPosition) {
      previousPosition = newPosition;
    }

    isScrolling = true;
    publicAPI.startInteraction();
  };

  publicAPI.endScrolling = function () {
    isScrolling = false;
    publicAPI.endInteraction();
  };

  publicAPI.updateCursor = function () {
    switch (publicAPI.getActiveInteraction()) {
      case InteractionMethodsName.TranslateCenter:
        model._apiSpecificRenderWindow.setCursor('move');

        break;

      case InteractionMethodsName.RotateLine:
        model._apiSpecificRenderWindow.setCursor('alias');

        break;

      case InteractionMethodsName.TranslateAxis:
        model._apiSpecificRenderWindow.setCursor('pointer');

        break;

      default:
        model._apiSpecificRenderWindow.setCursor('default');

        break;
    }
  };

  publicAPI.handleLeftButtonPress = function (callData) {
    if (model.activeState && model.activeState.getActive()) {
      model._isDragging = true;
      var viewType = model.viewType;
      var currentPlaneNormal = model.widgetState.getPlanes()[viewType].normal;
      model.planeManipulator.setWidgetOrigin(model.widgetState.getCenter());
      model.planeManipulator.setWidgetNormal(currentPlaneNormal);
      var worldCoords = model.planeManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
      previousPosition = worldCoords;
      publicAPI.startInteraction();
    } else if (model.widgetState.getScrollingMethod() === ScrollingMethods.LEFT_MOUSE_BUTTON) {
      publicAPI.startScrolling(callData.position);
    } else {
      return macro.VOID;
    }

    return macro.EVENT_ABORT;
  };

  publicAPI.handleMouseMove = function (callData) {
    if (model._isDragging) {
      return publicAPI.handleEvent(callData);
    }

    if (isScrolling) {
      if (previousPosition.y !== callData.position.y) {
        var step = previousPosition.y - callData.position.y;
        publicAPI.translateCenterOnPlaneDirection(step);
        previousPosition = callData.position;
        publicAPI.invokeInternalInteractionEvent();
      }
    }

    return macro.VOID;
  };

  publicAPI.handleLeftButtonRelease = function () {
    if (model._isDragging || isScrolling) {
      publicAPI.endScrolling();
    }

    model._isDragging = false;
    model.widgetState.deactivate();
  };

  publicAPI.handleRightButtonPress = function (calldata) {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.RIGHT_MOUSE_BUTTON) {
      publicAPI.startScrolling(calldata.position);
    }
  };

  publicAPI.handleRightButtonRelease = function () {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.RIGHT_MOUSE_BUTTON) {
      publicAPI.endScrolling();
    }
  };

  publicAPI.handleStartMouseWheel = function () {
    publicAPI.startInteraction();
  };

  publicAPI.handleMouseWheel = function (calldata) {
    var step = calldata.spinY;
    isScrolling = true;
    publicAPI.translateCenterOnPlaneDirection(step);
    publicAPI.invokeInternalInteractionEvent();
    isScrolling = false;
    return macro.EVENT_ABORT;
  };

  publicAPI.handleEndMouseWheel = function () {
    publicAPI.endScrolling();
  };

  publicAPI.handleMiddleButtonPress = function (calldata) {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.MIDDLE_MOUSE_BUTTON) {
      publicAPI.startScrolling(calldata.position);
    }
  };

  publicAPI.handleMiddleButtonRelease = function () {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.MIDDLE_MOUSE_BUTTON) {
      publicAPI.endScrolling();
    }
  };

  publicAPI.handleEvent = function (callData) {
    if (model.activeState.getActive()) {
      publicAPI[publicAPI.getActiveInteraction()](callData);
      publicAPI.invokeInternalInteractionEvent();
      return macro.EVENT_ABORT;
    }

    return macro.VOID;
  };

  publicAPI.invokeInternalInteractionEvent = function () {
    var methodName = publicAPI.getActiveInteraction();
    var computeFocalPointOffset = methodName !== InteractionMethodsName.RotateLine;
    var canUpdateFocalPoint = methodName === InteractionMethodsName.RotateLine;
    publicAPI.invokeInteractionEvent({
      computeFocalPointOffset: computeFocalPointOffset,
      canUpdateFocalPoint: canUpdateFocalPoint
    });
  };

  publicAPI.startInteraction = function () {
    publicAPI.invokeStartInteractionEvent(); // When interacting, plane actor and lines must be re-rendered on other views

    publicAPI.getViewWidgets().forEach(function (viewWidget) {
      viewWidget.getInteractor().requestAnimation(publicAPI);
    });
  };

  publicAPI.endInteraction = function () {
    publicAPI.invokeEndInteractionEvent();
    publicAPI.getViewWidgets().forEach(function (viewWidget) {
      viewWidget.getInteractor().cancelAnimation(publicAPI);
    });
  };

  publicAPI.translateCenterOnPlaneDirection = function (nbSteps) {
    var dirProj = model.widgetState.getPlanes()[model.viewType].normal;
    var oldCenter = model.widgetState.getCenter();
    var image = model.widgetState.getImage();
    var imageSpacing = image.getSpacing(); // Use Chebyshev norm
    // https://math.stackexchange.com/questions/71423/what-is-the-term-for-the-projection-of-a-vector-onto-the-unit-cube

    var absDirProj = dirProj.map(function (value) {
      return Math.abs(value);
    });
    var index = absDirProj.indexOf(Math.max.apply(Math, _toConsumableArray(absDirProj)));
    var movingFactor = nbSteps * imageSpacing[index] / Math.abs(dirProj[index]); // Define the potentially new center

    var newCenter = [oldCenter[0] + movingFactor * dirProj[0], oldCenter[1] + movingFactor * dirProj[1], oldCenter[2] + movingFactor * dirProj[2]];
    newCenter = publicAPI.getBoundedCenter(newCenter);
    model.widgetState.setCenter(newCenter);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };

  publicAPI[InteractionMethodsName.TranslateAxis] = function (calldata) {
    var lineHandle = publicAPI.getActiveLineHandle();
    var lineName = publicAPI.getActiveLineName();
    var pointOnLine = add(lineHandle.getOrigin(), lineHandle.getDirection(), []);
    var currentLineVector = lineHandle.getDirection();
    normalize(currentLineVector); // Translate the current line along the other line

    var otherLineHandle = publicAPI.getOtherLineHandle(lineName);
    var otherLineVector = otherLineHandle.getDirection();
    normalize(otherLineVector);
    var axisTranslation = otherLineVector;
    var dot$1 = dot(currentLineVector, otherLineVector); // lines are colinear, translate along perpendicular axis from current line

    if (dot$1 === 1 || dot$1 === -1) {
      cross(currentLineVector, model.planeManipulator.getWidgetNormal(), axisTranslation);
    }

    var closestPoint = [];
    var worldCoords = model.planeManipulator.handleEvent(calldata, model._apiSpecificRenderWindow);
    vtkLine.distanceToLine(worldCoords, lineHandle.getOrigin(), pointOnLine, closestPoint);
    var translationVector = subtract(worldCoords, closestPoint, []);
    var translationDistance = dot(translationVector, axisTranslation);
    var center = model.widgetState.getCenter();
    var newOrigin = multiplyAccumulate(center, axisTranslation, translationDistance, [0, 0, 0]);
    newOrigin = publicAPI.getBoundedCenter(newOrigin);
    model.widgetState.setCenter(newOrigin);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };

  publicAPI.getBoundedCenter = function (newCenter) {
    var oldCenter = model.widgetState.getCenter();
    var imageBounds = model.widgetState.getImage().getBounds();

    if (vtkBoundingBox.containsPoint.apply(vtkBoundingBox, [imageBounds].concat(_toConsumableArray(newCenter)))) {
      return newCenter;
    }

    return boundPointOnPlane(newCenter, oldCenter, imageBounds);
  };

  publicAPI[InteractionMethodsName.TranslateCenter] = function (calldata) {
    var worldCoords = model.planeManipulator.handleEvent(calldata, model._apiSpecificRenderWindow);
    var translation = subtract(worldCoords, previousPosition, []);
    previousPosition = worldCoords;
    var newCenter = add(model.widgetState.getCenter(), translation, []);
    newCenter = publicAPI.getBoundedCenter(newCenter);
    model.widgetState.setCenter(newCenter);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };

  publicAPI[InteractionMethodsName.RotateLine] = function (calldata) {
    var activeLineHandle = publicAPI.getActiveLineHandle();
    var planeNormal = model.planeManipulator.getWidgetNormal();
    var worldCoords = model.planeManipulator.handleEvent(calldata, model._apiSpecificRenderWindow);
    var center = model.widgetState.getCenter();
    var previousLineDirection = activeLineHandle.getDirection();
    normalize(previousLineDirection);

    if (publicAPI.getActiveRotationPointName() === 'point1') {
      multiplyScalar(previousLineDirection, -1);
    }

    var currentVectorToOrigin = [0, 0, 0];
    subtract(worldCoords, center, currentVectorToOrigin);
    normalize(currentVectorToOrigin);
    var radianAngle = signedAngleBetweenVectors(previousLineDirection, currentVectorToOrigin, planeNormal);
    publicAPI.rotateLineInView(publicAPI.getActiveLineName(), radianAngle);
  };
  /**
   * Rotate a line by a specified angle
   * @param {string} lineName The line name to rotate (e.g. YinX, ZinX, XinY, ZinY, XinZ, YinZ)
   * @param {Number} radianAngle Applied angle in radian
   */


  publicAPI.rotateLineInView = function (lineName, radianAngle) {
    var viewType = planeNameToViewType[getLinePlaneName(lineName)];
    var inViewType = planeNameToViewType[getLineInPlaneName(lineName)];
    var planeNormal = model.widgetState.getPlanes()[inViewType].normal;
    publicAPI.rotatePlane(viewType, radianAngle, planeNormal);

    if (publicAPI.getKeepOrthogonality()) {
      var otherLineName = getOtherLineName(lineName);
      var otherPlaneName = getLinePlaneName(otherLineName);
      publicAPI.rotatePlane(planeNameToViewType[otherPlaneName], radianAngle, planeNormal);
    }

    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };
  /**
   * Rotate a specified plane around an other specified plane.
   * @param {ViewTypes} viewType Define which plane will be rotated
   * @param {Number} radianAngle Applied angle in radian
   * @param {vec3} planeNormal Define the axis to rotate around
   */


  publicAPI.rotatePlane = function (viewType, radianAngle, planeNormal) {
    var _model$widgetState$ge = model.widgetState.getPlanes()[viewType],
        normal = _model$widgetState$ge.normal,
        viewUp = _model$widgetState$ge.viewUp;
    var newNormal = rotateVector(normal, planeNormal, radianAngle);
    var newViewUp = rotateVector(viewUp, planeNormal, radianAngle);
    model.widgetState.getPlanes()[viewType] = {
      normal: newNormal,
      viewUp: newViewUp
    };
  }; // --------------------------------------------------------------------------
  // initialization
  // --------------------------------------------------------------------------


  model.planeManipulator = vtkPlanePointManipulator.newInstance();
}

export { widgetBehavior as default };
