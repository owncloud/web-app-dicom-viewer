import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkActor from '../../Rendering/Core/Actor.js';
import vtkGlyph3DMapper from '../../Rendering/Core/Glyph3DMapper.js';
import vtkHandleRepresentation from './HandleRepresentation.js';
import vtkContextRepresentation from './ContextRepresentation.js';
import vtkSphereSource from '../../Filters/Sources/SphereSource.js';
import vtkPolyData from '../../Common/DataModel/PolyData.js';
import { ScalarMode } from '../../Rendering/Core/Mapper/Constants.js';
import { getPixelWorldHeightAtCoord } from '../Core/WidgetManager.js';
import vtkWidgetRepresentation, { allocateArray } from './WidgetRepresentation.js';
import { Behavior } from './WidgetRepresentation/Constants.js';
import { OrientationModes } from '../../Rendering/Core/Glyph3DMapper/Constants.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// vtkGlyphRepresentation methods
// ----------------------------------------------------------------------------

function origin(publicAPI, model) {
  return function (polyData, states) {
    var points = allocateArray(polyData, 'points', states.length).getData();
    var j = 0;

    for (var i = 0; i < states.length; ++i) {
      var coord = states[i].getOrigin(model.scaleInPixels && model.displayScaleParams);
      points[j++] = coord[0];
      points[j++] = coord[1];
      points[j++] = coord[2];
    }
  };
}
function noPosition(publicAPI, model) {
  return function (polyData, states) {
    allocateArray(polyData, 'points', 0);
  };
}
function color3(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setColorByArrayName('color');

    var colorArray = allocateArray(polyData, 'color', states.length, 'Uint8Array', // RGBA
    4);
    var colors = colorArray.getData();
    var j = 0;

    for (var i = 0; i < states.length; ++i) {
      var c3 = states[i].getColor3();

      if (states[i].getActive() && model.useActiveColor) {
        c3 = model.activeColor;
      }

      colors[j++] = c3[0];
      colors[j++] = c3[1];
      colors[j++] = c3[2];
      colors[j++] = states[i].getOpacity();
    }

    colorArray.dataChange();
  };
}
function color(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setColorByArrayName('color');

    var colors = allocateArray(polyData, 'color', states.length).getData();

    for (var i = 0; i < states.length; ++i) {
      var c = states[i].getColor();

      if (states[i].getActive() && model.useActiveColor) {
        c = model.activeColor;
      }

      colors[i] = c;
    }
  };
}
function noColor(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setColorByArrayName(null);
  };
}
function scale3(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setScaleArray('scale');

    model._pipeline.mapper.setScaleFactor(1);

    model._pipeline.mapper.setScaling(true);

    model._pipeline.mapper.setScaleMode(vtkGlyph3DMapper.ScaleModes.SCALE_BY_COMPONENTS);

    var scales = allocateArray(polyData, 'scale', states.length, 'Float32Array', 3).getData();
    var j = 0;

    for (var i = 0; i < states.length; ++i) {
      var _state$getScale, _state$getScale2;

      var state = states[i];
      var scaleFactor = state.getActive() ? model.activeScaleFactor : 1;

      if (publicAPI.getScaleInPixels()) {
        scaleFactor *= getPixelWorldHeightAtCoord(state.getOrigin(), model.displayScaleParams);
      }

      var scale = (_state$getScale = (_state$getScale2 = state.getScale3) === null || _state$getScale2 === void 0 ? void 0 : _state$getScale2.call(state)) !== null && _state$getScale !== void 0 ? _state$getScale : model.defaultScale;
      scales[j++] = scaleFactor * scale[0];
      scales[j++] = scaleFactor * scale[1];
      scales[j++] = scaleFactor * scale[2];
    }
  };
}
function scale1(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setScaleArray('scale');

    model._pipeline.mapper.setScaleFactor(1);

    model._pipeline.mapper.setScaling(true);

    var scales = allocateArray(polyData, 'scale', states.length).getData();

    for (var i = 0; i < states.length; ++i) {
      var _state$getScale3, _state$getScale4;

      var state = states[i];
      var scaleFactor = state.getActive() ? model.activeScaleFactor : 1;

      if (publicAPI.getScaleInPixels()) {
        scaleFactor *= getPixelWorldHeightAtCoord(state.getOrigin(), model.displayScaleParams);
      }

      var scale = (_state$getScale3 = (_state$getScale4 = state.getScale1) === null || _state$getScale4 === void 0 ? void 0 : _state$getScale4.call(state)) !== null && _state$getScale3 !== void 0 ? _state$getScale3 : model.defaultScale;
      scales[i] = scaleFactor * scale;
    }
  };
}
function noScale(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setScaleArray(null);

    model._pipeline.mapper.setScaleFactor(model.defaultScale);

    model._pipeline.mapper.setScaling(model.defaultScale !== 1);
  };
}
function direction(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setOrientationArray('orientation');

    model._pipeline.mapper.setOrientationMode(OrientationModes.MATRIX);

    var orientation = allocateArray(polyData, 'orientation', states.length, 'Float32Array', 9).getData();

    for (var i = 0; i < states.length; ++i) {
      var state = states[i];
      var right = state.getRight ? state.getRight() : [1, 0, 0];
      var up = state.getUp ? state.getUp() : [0, 1, 0];
      var dir = state.getDirection ? state.getDirection() : [0, 0, 1];
      orientation.set(right, 9 * i);
      orientation.set(up, 9 * i + 3);
      orientation.set(dir, 9 * i + 6);
    }
  };
}
function noOrientation(publicAPI, model) {
  return function (polyData, states) {
    model._pipeline.mapper.setOrientationArray(null);
  };
}

function vtkGlyphRepresentation(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkGlyphRepresentation');

  var superClass = _objectSpread({}, publicAPI);

  var internalPolyData = vtkPolyData.newInstance({
    mtime: 0
  });

  function hasMixin(states) {
    for (var _len = arguments.length, requiredMixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      requiredMixins[_key - 1] = arguments[_key];
    }

    return requiredMixins.every(function (requiredMixin) {
      var _states$, _states$$;

      return ((_states$ = states[0]) === null || _states$ === void 0 ? void 0 : (_states$$ = _states$["get".concat(macro.capitalize(requiredMixin))]) === null || _states$$ === void 0 ? void 0 : _states$$.call(_states$)) != null;
    });
  } // --------------------------------------------------------------------------
  // Generic rendering pipeline
  // --------------------------------------------------------------------------
  // --------------------------------------------------------------------------


  publicAPI.getRepresentationStates = function () {
    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.inputData[0];
    return superClass.getRepresentationStates(input).filter(function (state) {
      var _state$getOrigin, _state$isVisible, _state$isVisible2;

      return ((_state$getOrigin = state.getOrigin) === null || _state$getOrigin === void 0 ? void 0 : _state$getOrigin.call(state)) && ((_state$isVisible = (_state$isVisible2 = state.isVisible) === null || _state$isVisible2 === void 0 ? void 0 : _state$isVisible2.call(state)) !== null && _state$isVisible !== void 0 ? _state$isVisible : true);
    });
  }; // --------------------------------------------------------------------------


  publicAPI.getMixins = function (states) {
    var glyphProperties = {};

    if (hasMixin(states, 'origin')) {
      glyphProperties.position = model.applyMixin.origin;
    } else {
      glyphProperties.position = model.applyMixin.noPosition;
    }

    if (hasMixin(states, 'color3')) {
      glyphProperties.color = model.applyMixin.color3;
    } else if (hasMixin(states, 'color')) {
      glyphProperties.color = model.applyMixin.color;
    } else {
      glyphProperties.color = model.applyMixin.noColor;
    }

    if (hasMixin(states, 'scale3')) {
      glyphProperties.scale = model.applyMixin.scale3;
    } else if (hasMixin(states, 'scale1')) {
      glyphProperties.scale = model.applyMixin.scale1;
    } else {
      glyphProperties.scale = model.applyMixin.noScale;
    }

    if (hasMixin(states, 'direction')) {
      glyphProperties.orientation = model.applyMixin.direction;
    } else {
      glyphProperties.orientation = model.applyMixin.noOrientation;
    }

    return glyphProperties;
  };

  publicAPI.requestData = function (inData, outData) {
    var states = publicAPI.getRepresentationStates(inData[0]);
    outData[0] = internalPolyData;
    var glyphProperties = publicAPI.getMixins(states);
    Object.values(glyphProperties).forEach(function (property) {
      return property(internalPolyData, states);
    });
    internalPolyData.getPoints().modified();
    internalPolyData.modified();
  };

  vtkWidgetRepresentation.connectPipeline(model._pipeline);
  publicAPI.addActor(model._pipeline.actor);
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


function defaultValues(publicAPI, model, initialValues) {
  var _initialValues$_pipel, _initialValues$_pipel2, _initialValues$_pipel3, _initialValues$_pipel4, _initialValues$_pipel5, _initialValues$_pipel6, _initialValues$_pipel7, _initialValues$_pipel8, _initialValues$applyM, _initialValues$applyM2, _initialValues$applyM3, _initialValues$applyM4, _initialValues$applyM5, _initialValues$applyM6, _initialValues$applyM7, _initialValues$applyM8, _initialValues$applyM9, _initialValues$applyM10, _initialValues$applyM11, _initialValues$applyM12, _initialValues$applyM13, _initialValues$applyM14, _initialValues$applyM15, _initialValues$applyM16, _initialValues$applyM17, _initialValues$applyM18, _initialValues$applyM19, _initialValues$applyM20;

  return _objectSpread(_objectSpread({
    defaultScale: 1
  }, initialValues), {}, {
    _pipeline: _objectSpread({
      source: (_initialValues$_pipel = (_initialValues$_pipel2 = initialValues._pipeline) === null || _initialValues$_pipel2 === void 0 ? void 0 : _initialValues$_pipel2.source) !== null && _initialValues$_pipel !== void 0 ? _initialValues$_pipel : publicAPI,
      glyph: (_initialValues$_pipel3 = (_initialValues$_pipel4 = initialValues._pipeline) === null || _initialValues$_pipel4 === void 0 ? void 0 : _initialValues$_pipel4.glyph) !== null && _initialValues$_pipel3 !== void 0 ? _initialValues$_pipel3 : // in case glyph was provided
      vtkSphereSource.newInstance({
        phiResolution: 8,
        thetaResolution: 8
      }),
      mapper: (_initialValues$_pipel5 = (_initialValues$_pipel6 = initialValues._pipeline) === null || _initialValues$_pipel6 === void 0 ? void 0 : _initialValues$_pipel6.mapper) !== null && _initialValues$_pipel5 !== void 0 ? _initialValues$_pipel5 : // in case mapper was provided
      vtkGlyph3DMapper.newInstance({
        scalarMode: ScalarMode.USE_POINT_FIELD_DATA
      }),
      actor: (_initialValues$_pipel7 = (_initialValues$_pipel8 = initialValues._pipeline) === null || _initialValues$_pipel8 === void 0 ? void 0 : _initialValues$_pipel8.actor) !== null && _initialValues$_pipel7 !== void 0 ? _initialValues$_pipel7 : // in case actor was provided
      vtkActor.newInstance({
        parentProp: publicAPI
      })
    }, initialValues._pipeline),
    applyMixin: _objectSpread({
      origin: (_initialValues$applyM = (_initialValues$applyM2 = initialValues.applyMixin) === null || _initialValues$applyM2 === void 0 ? void 0 : _initialValues$applyM2.origin) !== null && _initialValues$applyM !== void 0 ? _initialValues$applyM : origin(publicAPI, model),
      noPosition: (_initialValues$applyM3 = (_initialValues$applyM4 = initialValues.applyMixin) === null || _initialValues$applyM4 === void 0 ? void 0 : _initialValues$applyM4.noPosition) !== null && _initialValues$applyM3 !== void 0 ? _initialValues$applyM3 : noPosition(),
      color3: (_initialValues$applyM5 = (_initialValues$applyM6 = initialValues.applyMixin) === null || _initialValues$applyM6 === void 0 ? void 0 : _initialValues$applyM6.color3) !== null && _initialValues$applyM5 !== void 0 ? _initialValues$applyM5 : color3(publicAPI, model),
      color: (_initialValues$applyM7 = (_initialValues$applyM8 = initialValues.applyMixin) === null || _initialValues$applyM8 === void 0 ? void 0 : _initialValues$applyM8.color) !== null && _initialValues$applyM7 !== void 0 ? _initialValues$applyM7 : color(publicAPI, model),
      noColor: (_initialValues$applyM9 = (_initialValues$applyM10 = initialValues.applyMixin) === null || _initialValues$applyM10 === void 0 ? void 0 : _initialValues$applyM10.noColor) !== null && _initialValues$applyM9 !== void 0 ? _initialValues$applyM9 : noColor(publicAPI, model),
      scale3: (_initialValues$applyM11 = (_initialValues$applyM12 = initialValues.applyMixin) === null || _initialValues$applyM12 === void 0 ? void 0 : _initialValues$applyM12.scale3) !== null && _initialValues$applyM11 !== void 0 ? _initialValues$applyM11 : scale3(publicAPI, model),
      scale1: (_initialValues$applyM13 = (_initialValues$applyM14 = initialValues.applyMixin) === null || _initialValues$applyM14 === void 0 ? void 0 : _initialValues$applyM14.scale1) !== null && _initialValues$applyM13 !== void 0 ? _initialValues$applyM13 : scale1(publicAPI, model),
      noScale: (_initialValues$applyM15 = (_initialValues$applyM16 = initialValues.applyMixin) === null || _initialValues$applyM16 === void 0 ? void 0 : _initialValues$applyM16.noScale) !== null && _initialValues$applyM15 !== void 0 ? _initialValues$applyM15 : noScale(publicAPI, model),
      direction: (_initialValues$applyM17 = (_initialValues$applyM18 = initialValues.applyMixin) === null || _initialValues$applyM18 === void 0 ? void 0 : _initialValues$applyM18.direction) !== null && _initialValues$applyM17 !== void 0 ? _initialValues$applyM17 : direction(publicAPI, model),
      noOrientation: (_initialValues$applyM19 = (_initialValues$applyM20 = initialValues.applyMixin) === null || _initialValues$applyM20 === void 0 ? void 0 : _initialValues$applyM20.noOrientation) !== null && _initialValues$applyM19 !== void 0 ? _initialValues$applyM19 : noOrientation(publicAPI, model)
    }, initialValues.applyMixin)
  });
} // ----------------------------------------------------------------------------


function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (initialValues.behavior === Behavior.CONTEXT) {
    vtkContextRepresentation.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));
  } else {
    vtkHandleRepresentation.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));
  }

  macro.setGet(publicAPI, model._pipeline, ['defaultScale']);
  macro.get(publicAPI, model._pipeline, ['glyph', 'mapper', 'actor']); // Expose the mixin functions to allow overwriting

  macro.setGet(publicAPI, model.applyMixin, Object.keys(model.applyMixin)); // Object specific methods

  vtkGlyphRepresentation(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkGlyphRepresentation'); // ----------------------------------------------------------------------------

var vtkGlyphRepresentation$1 = {
  newInstance: newInstance,
  extend: extend
};

export { color, color3, vtkGlyphRepresentation$1 as default, direction, extend, newInstance, noColor, noOrientation, noPosition, noScale, origin, scale1, scale3 };
