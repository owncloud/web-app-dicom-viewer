import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkActor from '../../Rendering/Core/Actor.js';
import vtkMapper from '../../Rendering/Core/Mapper.js';
import { B as areEquals } from '../../Common/Core/Math/index.js';
import vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';
import vtkTubeFilter from '../../Filters/General/TubeFilter.js';
import { getPixelWorldHeightAtCoord } from '../Core/WidgetManager.js';
import vtkWidgetRepresentation, { allocateArray } from './WidgetRepresentation.js';
import { RenderingTypes } from '../Core/WidgetManager/Constants.js';
import vtkPolyData from '../../Common/DataModel/PolyData.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// vtkPolyLineRepresentation methods
// ----------------------------------------------------------------------------

function vtkPolyLineRepresentation(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPolyLineRepresentation');

  var superClass = _objectSpread({}, publicAPI); // --------------------------------------------------------------------------
  // Internal polydata dataset
  // --------------------------------------------------------------------------


  var internalPolyData = vtkPolyData.newInstance({
    mtime: 0
  });

  function allocateSize(polyData, size) {
    var closePolyLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var points = null;

    if (size < 2) {
      // FIXME: Why 1 point and not 0 ?
      points = allocateArray(polyData, 'points', 1).getData();
      points.set([0, 0, 0]);
      allocateArray(polyData, 'lines', 0).getData();
    } else if (!polyData.getPoints() || polyData.getPoints().length !== size * 3) {
      points = allocateArray(polyData, 'points', size).getData();
      var cellSize = size + (closePolyLine ? 1 : 0);

      if (polyData.getLines().getNumberOfCells() !== 1 || polyData.getLines().getCellSizes()[0] !== cellSize) {
        var lines = allocateArray(polyData, 'lines', cellSize + 1); // +1 for the number of points

        var cellData = lines.getData();
        cellData[0] = cellSize;

        for (var i = 1; i <= cellSize; i++) {
          cellData[i] = i - 1;
        }

        if (closePolyLine) {
          cellData[cellSize - 1] = 0;
        }

        lines.setData(cellData);
      }
    }

    return points;
  }
  /**
   * Change the line/tube thickness.
   * @param {number} lineThickness
   */


  function applyLineThickness(lineThickness) {
    var scaledLineThickness = lineThickness;

    if (publicAPI.getScaleInPixels() && internalPolyData) {
      var center = vtkBoundingBox.getCenter(internalPolyData.getBounds());
      scaledLineThickness *= getPixelWorldHeightAtCoord(center, model.displayScaleParams);
    }

    model._pipelines.tubes.filter.setRadius(scaledLineThickness);
  } // --------------------------------------------------------------------------
  // Generic rendering pipeline
  // --------------------------------------------------------------------------


  model._pipelines = {
    tubes: {
      source: publicAPI,
      filter: vtkTubeFilter.newInstance({
        radius: model.lineThickness,
        numberOfSides: 12,
        capping: false
      }),
      mapper: vtkMapper.newInstance(),
      actor: vtkActor.newInstance({
        parentProp: publicAPI
      })
    }
  };
  vtkWidgetRepresentation.connectPipeline(model._pipelines.tubes);
  publicAPI.addActor(model._pipelines.tubes.actor); // --------------------------------------------------------------------------

  publicAPI.requestData = function (inData, outData) {
    var _state$getLineThickne, _state$getLineThickne2;

    var state = inData[0];
    outData[0] = internalPolyData; // Remove invalid and coincident points for tube filter.

    var list = publicAPI.getRepresentationStates(state).reduce(function (subStates, subState) {
      var subStateOrigin = subState.getOrigin && subState.getOrigin() ? subState.getOrigin() : null;
      var previousSubStateOrigin = subStates.length && subStates[subStates.length - 1].getOrigin();

      if (!subStateOrigin || previousSubStateOrigin && areEquals(subStateOrigin, previousSubStateOrigin)) {
        return subStates;
      }

      subStates.push(subState);
      return subStates;
    }, []);
    var size = list.length;
    var points = allocateSize(outData[0], size, model.closePolyLine && size > 2);

    if (points) {
      for (var i = 0; i < size; i++) {
        var coords = list[i].getOrigin();
        points[i * 3] = coords[0];
        points[i * 3 + 1] = coords[1];
        points[i * 3 + 2] = coords[2];
      }
    }

    outData[0].getPoints().modified();
    outData[0].modified();
    var lineThickness = (_state$getLineThickne = (_state$getLineThickne2 = state.getLineThickness) === null || _state$getLineThickne2 === void 0 ? void 0 : _state$getLineThickne2.call(state)) !== null && _state$getLineThickne !== void 0 ? _state$getLineThickne : model.lineThickness;
    applyLineThickness(lineThickness);
  };
  /**
   * When mousing over the line, if behavior != CONTEXT,
   * returns the parent state.
   * @param {object} prop
   * @param {number} compositeID
   * @returns {object}
   */


  publicAPI.getSelectedState = function (prop, compositeID) {
    return model.inputData[0];
  };

  publicAPI.updateActorVisibility = function (renderingType, ctxVisible, hVisible) {
    var _state$getLineThickne3, _state$getLineThickne4;

    var state = model.inputData[0]; // Make lines/tubes thicker for picking

    var lineThickness = (_state$getLineThickne3 = (_state$getLineThickne4 = state.getLineThickness) === null || _state$getLineThickne4 === void 0 ? void 0 : _state$getLineThickne4.call(state)) !== null && _state$getLineThickne3 !== void 0 ? _state$getLineThickne3 : model.lineThickness;

    if (renderingType === RenderingTypes.PICKING_BUFFER) {
      lineThickness = Math.max(4, lineThickness);
    }

    applyLineThickness(lineThickness);
    return superClass.updateActorVisibility(renderingType, ctxVisible, hVisible);
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  threshold: Number.EPSILON,
  closePolyLine: false,
  lineThickness: 2,
  scaleInPixels: true
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var newDefault = _objectSpread(_objectSpread({}, DEFAULT_VALUES), initialValues);

  vtkWidgetRepresentation.extend(publicAPI, model, newDefault);
  macro.setGet(publicAPI, model, ['threshold', 'closePolyLine', 'lineThickness']);
  vtkPolyLineRepresentation(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkPolyLineRepresentation'); // ----------------------------------------------------------------------------

var vtkPolyLineRepresentation$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkPolyLineRepresentation$1 as default, extend, newInstance };
