import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkActor from '../../Rendering/Core/Actor.js';
import vtkGlyphRepresentation from './GlyphRepresentation.js';
import vtkPixelSpaceCallbackMapper from '../../Rendering/Core/PixelSpaceCallbackMapper.js';
import vtkCylinderSource from '../../Filters/Sources/CylinderSource.js';
import { allocateArray } from './WidgetRepresentation.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var INFINITE_RATIO = 100000; // ----------------------------------------------------------------------------
// vtkLineHandleRepresentation methods
// ----------------------------------------------------------------------------

function vtkLineHandleRepresentation(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLineHandleRepresentation'); // --------------------------------------------------------------------------
  // Generic rendering pipeline
  // --------------------------------------------------------------------------

  /*
   * displayActors and displayMappers are used to render objects in HTML, allowing objects
   * to be 'rendered' internally in a VTK scene without being visible on the final output
   */

  model.displayMapper = vtkPixelSpaceCallbackMapper.newInstance();
  model.displayActor = vtkActor.newInstance({
    parentProp: publicAPI
  }); // model.displayActor.getProperty().setOpacity(0); // don't show in 3D

  model.displayActor.setMapper(model.displayMapper);
  model.displayMapper.setInputConnection(publicAPI.getOutputPort());
  publicAPI.addActor(model.displayActor);
  model.alwaysVisibleActors = [model.displayActor]; // --------------------------------------------------------------------------

  publicAPI.setGlyphResolution = macro.chain(publicAPI.setGlyphResolution, model._pipeline.glyph.setThetaResolution, model._pipeline.glyph.setPhiResolution); // --------------------------------------------------------------------------

  function callbackProxy(coords) {
    if (model.displayCallback) {
      var filteredList = [];
      var states = publicAPI.getRepresentationStates();

      for (var i = 0; i < states.length; i++) {
        if (states[i].getActive()) {
          filteredList.push(coords[i]);
        }
      }

      if (filteredList.length) {
        model.displayCallback(filteredList);
        return;
      }
    }

    model.displayCallback();
  }

  publicAPI.setDisplayCallback = function (callback) {
    model.displayCallback = callback;
    model.displayMapper.setCallback(callback ? callbackProxy : null);
  };
  /**
   * Overwrite scale3 to optionally make lines infinite
   */


  var superScale3 = publicAPI.getScale3();
  publicAPI.setScale3(function (polyData, states) {
    superScale3(polyData, states);

    if (model.infiniteLine) {
      var scales = allocateArray(polyData, 'scale', states.length, 'Float32Array', 3).getData();

      for (var i = 0; i < states.length; ++i) {
        scales[3 * i + 2] = INFINITE_RATIO;
      }
    }
  });
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


function defaultValues(initialValues) {
  var _initialValues$glyphR;

  return _objectSpread({
    infiniteLine: true,
    glyphResolution: 4,
    _pipeline: {
      glyph: vtkCylinderSource.newInstance({
        resolution: (_initialValues$glyphR = initialValues.glyphResolution) !== null && _initialValues$glyphR !== void 0 ? _initialValues$glyphR : 4,
        direction: [0, 0, 1]
      })
    }
  }, initialValues);
} // ----------------------------------------------------------------------------


function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  vtkGlyphRepresentation.extend(publicAPI, model, defaultValues(initialValues));
  macro.setGet(publicAPI, model, ['infiniteLine', 'glyphResolution']); // Object specific methods

  vtkLineHandleRepresentation(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkLineHandleRepresentation'); // ----------------------------------------------------------------------------

var vtkLineHandleRepresentation$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkLineHandleRepresentation$1 as default, extend, newInstance };
