import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkProp from '../../Rendering/Core/Prop.js';
import vtkCellArray from '../../Common/Core/CellArray.js';
import vtkDataArray from '../../Common/Core/DataArray.js';
import vtkPoints from '../../Common/Core/Points.js';
import { Behavior } from './WidgetRepresentation/Constants.js';
import { RenderingTypes } from '../Core/WidgetManager/Constants.js';
import { CATEGORIES } from '../../Rendering/Core/Mapper/CoincidentTopologyHelper.js';
import { POLYDATA_FIELDS } from '../../Common/DataModel/PolyData/Constants.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkErrorMacro = macro.vtkErrorMacro,
    vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------

var STYLE_CATEGORIES = ['active', 'inactive', 'static'];

function applyCoincidentTopologyParametersToMapper(mapper, parameters) {
  if (mapper && mapper.setResolveCoincidentTopologyToPolygonOffset) {
    mapper.setResolveCoincidentTopologyToPolygonOffset();
    CATEGORIES.forEach(function (category) {
      if (parameters[category]) {
        var methodName = "setRelativeCoincidentTopology".concat(category, "OffsetParameters");

        if (mapper[methodName]) {
          var _parameters$category = parameters[category],
              factor = _parameters$category.factor,
              offset = _parameters$category.offset;
          mapper[methodName](factor, offset);
        }
      }
    });
  }
}

function mergeStyles(elementNames) {
  for (var _len = arguments.length, stylesToMerge = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    stylesToMerge[_key - 1] = arguments[_key];
  }

  var newStyleObject = {
    active: {},
    inactive: {},
    static: {}
  };
  STYLE_CATEGORIES.forEach(function (category) {
    var cat = newStyleObject[category];
    elementNames.forEach(function (name) {
      if (!cat[name]) {
        cat[name] = {};
      }

      stylesToMerge.filter(function (s) {
        return s && s[category] && s[category][name];
      }).forEach(function (s) {
        return Object.assign(cat[name], s[category][name]);
      });
    });
  });
  return newStyleObject;
} // ----------------------------------------------------------------------------

function applyStyles(pipelines, styles, activeActor) {
  if (!activeActor) {
    // static
    Object.keys(styles.static).forEach(function (name) {
      if (pipelines[name]) {
        pipelines[name].actor.getProperty().set(styles.static[name]);
      }
    }); // inactive

    Object.keys(styles.inactive).forEach(function (name) {
      if (pipelines[name]) {
        pipelines[name].actor.getProperty().set(styles.inactive[name]);
      }
    });
  } else {
    Object.keys(pipelines).forEach(function (name) {
      var style = pipelines[name].actor === activeActor ? styles.active[name] : styles.inactive[name];

      if (style) {
        pipelines[name].actor.getProperty().set(style);
      }
    });
  }
} // ----------------------------------------------------------------------------

function connectPipeline(pipeline) {
  var source = pipeline.source;

  if (pipeline.filter) {
    if (source.isA('vtkDataSet')) {
      pipeline.filter.setInputData(source);
    } else {
      pipeline.filter.setInputConnection(source.getOutputPort());
    }

    source = pipeline.filter;
  }

  if (source) {
    if (source.isA('vtkDataSet')) {
      pipeline.mapper.setInputData(source);
    } else {
      pipeline.mapper.setInputConnection(source.getOutputPort());
    }
  }

  if (pipeline.glyph) {
    pipeline.mapper.setInputConnection(pipeline.glyph.getOutputPort(), 1);
  }

  pipeline.actor.setMapper(pipeline.mapper);
} // Internal convenient function to create a data array:

function allocateArray(polyData, name, numberOfTuples, dataType, numberOfComponents) {
  var _polyData$;

  // Check first whether name is points, verts, lines, polys, otherwise it is a point data array.
  var dataArray = ((_polyData$ = polyData["get".concat(macro.capitalize(name))]) === null || _polyData$ === void 0 ? void 0 : _polyData$.call(polyData)) || polyData.getPointData().getArrayByName(name);

  if (!dataArray || dataType !== undefined && dataArray.getDataType() !== dataType || numberOfComponents !== undefined && dataArray.getNumberOfComponents() !== numberOfComponents) {
    var arrayType = vtkDataArray;
    var arrayDataType = dataType;
    var arrayNumberOfComponents = numberOfComponents;

    if (name === 'points') {
      var _arrayDataType;

      arrayType = vtkPoints;
      arrayDataType = (_arrayDataType = arrayDataType) !== null && _arrayDataType !== void 0 ? _arrayDataType : 'Float32Array';
      arrayNumberOfComponents = numberOfComponents !== null && numberOfComponents !== void 0 ? numberOfComponents : 3;
    } else if (POLYDATA_FIELDS.includes(name)) {
      var _arrayDataType2;

      arrayType = vtkCellArray;
      arrayDataType = (_arrayDataType2 = arrayDataType) !== null && _arrayDataType2 !== void 0 ? _arrayDataType2 : 'Uint16Array';
      arrayNumberOfComponents = numberOfComponents !== null && numberOfComponents !== void 0 ? numberOfComponents : 1;
    } else {
      var _arrayDataType3;

      // data array
      arrayDataType = (_arrayDataType3 = arrayDataType) !== null && _arrayDataType3 !== void 0 ? _arrayDataType3 : 'Float32Array';
      arrayNumberOfComponents = numberOfComponents !== null && numberOfComponents !== void 0 ? numberOfComponents : 1;
    }

    dataArray = arrayType.newInstance({
      name: name,
      dataType: arrayDataType,
      numberOfComponents: arrayNumberOfComponents,
      size: arrayNumberOfComponents * numberOfTuples,
      empty: numberOfTuples === 0
    });

    if (name === 'points' || POLYDATA_FIELDS.includes(name)) {
      polyData["set".concat(macro.capitalize(name))](dataArray);
    } else {
      polyData.getPointData().addArray(dataArray);
    }
  } else if (dataArray.getNumberOfTuples() !== numberOfTuples) {
    dataArray.resize(numberOfTuples);
  }

  return dataArray;
} // ----------------------------------------------------------------------------
// vtkWidgetRepresentation
// ----------------------------------------------------------------------------

function vtkWidgetRepresentation(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWidgetRepresentation'); // Internal cache

  var cache = {
    mtimes: {},
    states: []
  };

  model._onCoincidentTopologyParametersChanged = function () {
    publicAPI.getActors().forEach(function (actor) {
      applyCoincidentTopologyParametersToMapper(actor.getMapper(), model.coincidentTopologyParameters);
    });
  }; // --------------------------------------------------------------------------


  publicAPI.getActors = function () {
    return model.actors;
  };

  publicAPI.getNestedProps = publicAPI.getActors; // --------------------------------------------------------------------------

  publicAPI.setLabels = function () {
    for (var _len2 = arguments.length, labels = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      labels[_key2] = arguments[_key2];
    }

    if (labels.length === 1) {
      model.labels = [].concat(labels[0]);
    } else {
      model.labels = labels;
    }

    publicAPI.modified();
  };

  publicAPI.getRepresentationStates = function () {
    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.inputData[0];

    if (cache.mtimes.representation === publicAPI.getMTime() && cache.mtimes.input === input.getMTime()) {
      return cache.states;
    } // Reinitialize cache


    cache.mtimes.representation = publicAPI.getMTime();
    cache.mtimes.input = input.getMTime();
    cache.states = []; // Fill states that are going to be used in the representation

    model.labels.forEach(function (name) {
      cache.states = cache.states.concat(input.getStatesWithLabel(name) || []);
    });
    return cache.states;
  };

  publicAPI.getSelectedState = function (prop, compositeID) {
    var representationStates = publicAPI.getRepresentationStates();

    if (compositeID < representationStates.length) {
      return representationStates[compositeID];
    }

    vtkErrorMacro("Representation ".concat(publicAPI.getClassName(), " should implement getSelectedState(prop, compositeID) method."));
    return null;
  };

  publicAPI.updateActorVisibility = function () {
    var renderingType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RenderingTypes.FRONT_BUFFER;
    var ctxVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var handleVisible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var otherFlag = true;

    switch (model.behavior) {
      case Behavior.HANDLE:
        otherFlag = renderingType === RenderingTypes.PICKING_BUFFER || handleVisible;
        break;

      case Behavior.CONTEXT:
        otherFlag = ctxVisible;
        break;

      default:
        otherFlag = true;
        break;
    }

    var visibilityFlag = otherFlag;

    for (var i = 0; i < model.actors.length; i++) {
      if (model.visibilityFlagArray) {
        model.actors[i].setVisibility(visibilityFlag && model.visibilityFlagArray[i]);
      } else {
        model.actors[i].setVisibility(visibilityFlag);
      }
    }

    if (model.alwaysVisibleActors) {
      for (var _i = 0; _i < model.alwaysVisibleActors.length; _i++) {
        model.alwaysVisibleActors[_i].setVisibility(true);
      }
    }
  }; // Add warning to model.actors.push


  model.actors.push = function () {
    vtkWarningMacro('You should use publicAPI.addActor() to initialize the actor properly');

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    args.forEach(function (actor) {
      return publicAPI.addActor(actor);
    });
  };

  publicAPI.addActor = function (actor) {
    applyCoincidentTopologyParametersToMapper(actor.getMapper(), model.coincidentTopologyParameters);
    Array.prototype.push.apply(model.actors, [actor]);
  }; // Make sure setting the labels at build time works with string/array...


  publicAPI.setLabels(model.labels);
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


function defaultValues(initialValues) {
  return _objectSpread({
    activeScaleFactor: 1.2,
    activeColor: 1,
    useActiveColor: true,
    actors: [],
    labels: [],
    behavior: Behavior.CONTEXT,
    coincidentTopologyParameters: {
      Point: {
        factor: -1.0,
        offset: -1.0
      },
      Line: {
        factor: -1.0,
        offset: -1.0
      },
      Polygon: {
        factor: -1.0,
        offset: -1.0
      }
    },
    scaleInPixels: false,
    displayScaleParams: {
      dispHeightFactor: 1,
      cameraPosition: [0, 0, 0],
      cameraDir: [1, 0, 0],
      isParallel: false,
      rendererPixelDims: [1, 1]
    },
    _internalArrays: {}
  }, initialValues);
} // ----------------------------------------------------------------------------


function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Object methods
  vtkProp.extend(publicAPI, model, defaultValues(initialValues));
  macro.algo(publicAPI, model, 1, 1);
  macro.get(publicAPI, model, ['labels', 'displayScaleParams', 'coincidentTopologyParameters']);
  macro.set(publicAPI, model, [{
    type: 'object',
    name: 'displayScaleParams'
  }, {
    type: 'object',
    name: 'coincidentTopologyParameters'
  }]);
  macro.setGet(publicAPI, model, ['scaleInPixels', 'activeScaleFactor', 'activeColor', 'useActiveColor']); // Object specific methods

  vtkWidgetRepresentation(publicAPI, model);
} // ----------------------------------------------------------------------------

var vtkWidgetRepresentation$1 = {
  extend: extend,
  mergeStyles: mergeStyles,
  applyStyles: applyStyles,
  connectPipeline: connectPipeline
};

export { allocateArray, applyStyles, connectPipeline, vtkWidgetRepresentation$1 as default, extend, mergeStyles };
