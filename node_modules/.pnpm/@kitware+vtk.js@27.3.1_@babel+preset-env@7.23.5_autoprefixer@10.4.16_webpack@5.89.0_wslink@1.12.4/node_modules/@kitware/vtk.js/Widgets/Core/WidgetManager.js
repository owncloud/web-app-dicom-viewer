import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { f as vtkMath } from '../../Common/Core/Math/index.js';
import { FieldAssociations } from '../../Common/DataModel/DataSet/Constants.js';
import macro from '../../macros.js';
import WidgetManagerConst from './WidgetManager/Constants.js';
import { WIDGET_PRIORITY } from './AbstractWidget/Constants.js';

var ViewTypes = WidgetManagerConst.ViewTypes,
    RenderingTypes = WidgetManagerConst.RenderingTypes,
    CaptureOn = WidgetManagerConst.CaptureOn;
var vtkErrorMacro = macro.vtkErrorMacro,
    vtkWarningMacro = macro.vtkWarningMacro;
var viewIdCount = 1; // ----------------------------------------------------------------------------
// Helper
// ----------------------------------------------------------------------------

function extractRenderingComponents(renderer) {
  var camera = renderer.getActiveCamera();
  var renderWindow = renderer.getRenderWindow();
  var interactor = renderWindow.getInteractor();
  var apiSpecificRenderWindow = interactor.getView();
  return {
    renderer: renderer,
    renderWindow: renderWindow,
    interactor: interactor,
    apiSpecificRenderWindow: apiSpecificRenderWindow,
    camera: camera
  };
}
function getPixelWorldHeightAtCoord(worldCoord, displayScaleParams) {
  var dispHeightFactor = displayScaleParams.dispHeightFactor,
      cameraPosition = displayScaleParams.cameraPosition,
      cameraDir = displayScaleParams.cameraDir,
      isParallel = displayScaleParams.isParallel,
      rendererPixelDims = displayScaleParams.rendererPixelDims;
  var scale = 1;

  if (isParallel) {
    scale = dispHeightFactor;
  } else {
    var worldCoordToCamera = _toConsumableArray(worldCoord);

    vtkMath.subtract(worldCoordToCamera, cameraPosition, worldCoordToCamera);
    scale = vtkMath.dot(worldCoordToCamera, cameraDir) * dispHeightFactor;
  }

  var rHeight = rendererPixelDims[1];
  return scale / rHeight;
} // ----------------------------------------------------------------------------
// vtkWidgetManager methods
// ----------------------------------------------------------------------------

function vtkWidgetManager(publicAPI, model) {
  if (!model.viewId) {
    model.viewId = "view-".concat(viewIdCount++);
  }

  model.classHierarchy.push('vtkWidgetManager');
  var propsWeakMap = new WeakMap();
  var subscriptions = []; // --------------------------------------------------------------------------
  // API internal
  // --------------------------------------------------------------------------

  function updateWidgetWeakMap(widget) {
    var representations = widget.getRepresentations();

    for (var i = 0; i < representations.length; i++) {
      var representation = representations[i];
      var origin = {
        widget: widget,
        representation: representation
      };
      var actors = representation.getActors();

      for (var j = 0; j < actors.length; j++) {
        var actor = actors[j];
        propsWeakMap.set(actor, origin);
      }
    }
  }

  function getViewWidget(widget) {
    return widget && (widget.isA('vtkAbstractWidget') ? widget : widget.getWidgetForView({
      viewId: model.viewId
    }));
  } // --------------------------------------------------------------------------
  // Widget scaling
  // --------------------------------------------------------------------------


  function updateDisplayScaleParams() {
    var _apiSpecificRenderWindow = model._apiSpecificRenderWindow,
        _camera = model._camera,
        _renderer = model._renderer;

    if (_renderer && _apiSpecificRenderWindow && _camera) {
      var _apiSpecificRenderWin = _apiSpecificRenderWindow.getSize(),
          _apiSpecificRenderWin2 = _slicedToArray(_apiSpecificRenderWin, 2),
          rwW = _apiSpecificRenderWin2[0],
          rwH = _apiSpecificRenderWin2[1];

      var _renderer$getViewport = _renderer.getViewport(),
          _renderer$getViewport2 = _slicedToArray(_renderer$getViewport, 4),
          vxmin = _renderer$getViewport2[0],
          vymin = _renderer$getViewport2[1],
          vxmax = _renderer$getViewport2[2],
          vymax = _renderer$getViewport2[3];

      var pixelRatio = _apiSpecificRenderWindow.getComputedDevicePixelRatio();

      var rendererPixelDims = [rwW * (vxmax - vxmin) / pixelRatio, rwH * (vymax - vymin) / pixelRatio];

      var cameraPosition = _camera.getPosition();

      var cameraDir = _camera.getDirectionOfProjection();

      var isParallel = _camera.getParallelProjection();

      var dispHeightFactor = isParallel ? 2 * _camera.getParallelScale() : 2 * Math.tan(vtkMath.radiansFromDegrees(_camera.getViewAngle()) / 2);
      model.widgets.forEach(function (w) {
        w.getNestedProps().forEach(function (r) {
          if (r.getScaleInPixels()) {
            r.setDisplayScaleParams({
              dispHeightFactor: dispHeightFactor,
              cameraPosition: cameraPosition,
              cameraDir: cameraDir,
              isParallel: isParallel,
              rendererPixelDims: rendererPixelDims
            });
          }
        });
      });
    }
  } // --------------------------------------------------------------------------
  // API public
  // --------------------------------------------------------------------------


  function updateSelection(_x, _x2, _x3) {
    return _updateSelection.apply(this, arguments);
  }

  function _updateSelection() {
    _updateSelection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(callData, fromTouchEvent, callID) {
      var position, _yield$publicAPI$getS, requestCount, selectedState, representation, widget, activateHandle, wantRender, i, w;

      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              activateHandle = function _activateHandle(w) {
                if (fromTouchEvent) {
                  // release any previous left button interaction
                  model._interactor.invokeLeftButtonRelease(callData);
                }

                w.activateHandle({
                  selectedState: selectedState,
                  representation: representation
                });

                if (fromTouchEvent) {
                  // re-trigger the left button press to pick the now-active widget
                  model._interactor.invokeLeftButtonPress(callData);
                }
              };

              position = callData.position;
              _context3.next = 4;
              return publicAPI.getSelectedDataForXY(position.x, position.y);

            case 4:
              _yield$publicAPI$getS = _context3.sent;
              requestCount = _yield$publicAPI$getS.requestCount;
              selectedState = _yield$publicAPI$getS.selectedState;
              representation = _yield$publicAPI$getS.representation;
              widget = _yield$publicAPI$getS.widget;

              if (!(requestCount || callID !== model._currentUpdateSelectionCallID)) {
                _context3.next = 11;
                break;
              }

              return _context3.abrupt("return");

            case 11:
              // Default cursor behavior
              model._apiSpecificRenderWindow.setCursor(widget ? 'pointer' : 'default');

              model.activeWidget = null;
              wantRender = false;

              if (model.widgetInFocus === widget && widget.hasFocus()) {
                activateHandle(widget);
                model.activeWidget = widget;
                wantRender = true;
              } else {
                for (i = 0; i < model.widgets.length; i++) {
                  w = model.widgets[i];

                  if (w === widget && w.getNestedPickable()) {
                    activateHandle(w);
                    model.activeWidget = w;
                    wantRender = true;
                  } else {
                    wantRender || (wantRender = !!w.getActiveState());
                    w.deactivateAllHandles();
                  }
                }
              }

              if (wantRender) {
                model._interactor.render();
              }

            case 16:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _updateSelection.apply(this, arguments);
  }

  var handleEvent = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(callData) {
      var fromTouchEvent,
          callID,
          _args = arguments;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              fromTouchEvent = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;

              if (!(!model.isAnimating && model.pickingEnabled)) {
                _context.next = 6;
                break;
              }

              callID = Symbol('UpdateSelection');
              model._currentUpdateSelectionCallID = callID;
              _context.next = 6;
              return updateSelection(callData, fromTouchEvent, callID);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handleEvent(_x4) {
      return _ref.apply(this, arguments);
    };
  }();

  function updateWidgetForRender(w) {
    w.updateRepresentationForRender(model.renderingType);
  }

  function renderPickingBuffer() {
    model.renderingType = RenderingTypes.PICKING_BUFFER;
    model.widgets.forEach(updateWidgetForRender);
  }

  function renderFrontBuffer() {
    model.renderingType = RenderingTypes.FRONT_BUFFER;
    model.widgets.forEach(updateWidgetForRender);
  }

  function captureBuffers(_x5, _x6, _x7, _x8) {
    return _captureBuffers.apply(this, arguments);
  }

  function _captureBuffers() {
    _captureBuffers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(x1, y1, x2, y2) {
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!model._captureInProgress) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return");

            case 2:
              model._captureInProgress = true;
              renderPickingBuffer();
              model._capturedBuffers = null;
              _context4.next = 7;
              return model._selector.getSourceDataAsync(model._renderer, x1, y1, x2, y2);

            case 7:
              model._capturedBuffers = _context4.sent;
              model.previousSelectedData = null;
              renderFrontBuffer();
              model._captureInProgress = false;

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _captureBuffers.apply(this, arguments);
  }

  publicAPI.enablePicking = function () {
    model.pickingEnabled = true;
    publicAPI.renderWidgets();
  };

  publicAPI.renderWidgets = function () {
    if (model.pickingEnabled && model.captureOn === CaptureOn.MOUSE_RELEASE) {
      var _model$_apiSpecificRe = model._apiSpecificRenderWindow.getSize(),
          _model$_apiSpecificRe2 = _slicedToArray(_model$_apiSpecificRe, 2),
          w = _model$_apiSpecificRe2[0],
          h = _model$_apiSpecificRe2[1];

      captureBuffers(0, 0, w, h);
    }

    renderFrontBuffer();
    publicAPI.modified();
  };

  publicAPI.disablePicking = function () {
    model.pickingEnabled = false;
  };

  publicAPI.setRenderer = function (renderer) {
    var renderingComponents = extractRenderingComponents(renderer);
    Object.assign(model, renderingComponents);
    macro.moveToProtected({}, model, Object.keys(renderingComponents));

    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }

    model._selector = model._apiSpecificRenderWindow.createSelector();

    model._selector.setFieldAssociation(FieldAssociations.FIELD_ASSOCIATION_POINTS);

    subscriptions.push(model._apiSpecificRenderWindow.onWindowResizeEvent(updateDisplayScaleParams));
    subscriptions.push(model._camera.onModified(updateDisplayScaleParams));
    updateDisplayScaleParams();
    subscriptions.push(model._interactor.onStartAnimation(function () {
      model.isAnimating = true;
    }));
    subscriptions.push(model._interactor.onEndAnimation(function () {
      model.isAnimating = false;
      publicAPI.renderWidgets();
    }));
    subscriptions.push(model._interactor.onMouseMove(function (eventData) {
      handleEvent(eventData);
      return macro.VOID;
    })); // must be handled after widgets, hence the given priority.

    subscriptions.push(model._interactor.onLeftButtonPress(function (eventData) {
      var deviceType = eventData.deviceType;
      var touchEvent = deviceType === 'touch' || deviceType === 'pen'; // only try selection if the left button press is from touch.

      if (touchEvent) {
        handleEvent(eventData, touchEvent);
      }

      return macro.VOID;
    }, WIDGET_PRIORITY / 2));
    publicAPI.modified();

    if (model.pickingEnabled) {
      publicAPI.enablePicking();
    }
  };

  function addWidgetInternal(viewWidget) {
    viewWidget.setWidgetManager(publicAPI);
    updateWidgetWeakMap(viewWidget);
    updateDisplayScaleParams(); // Register to renderer

    model._renderer.addActor(viewWidget);
  }

  publicAPI.addWidget = function (widget, viewType, initialValues) {
    if (!model._renderer) {
      vtkErrorMacro('Widget manager MUST BE link to a view before registering widgets');
      return null;
    }

    var viewId = model.viewId,
        _renderer = model._renderer;
    var w = widget.getWidgetForView({
      viewId: viewId,
      renderer: _renderer,
      viewType: viewType || ViewTypes.DEFAULT,
      initialValues: initialValues
    });

    if (w != null && model.widgets.indexOf(w) === -1) {
      model.widgets.push(w);
      addWidgetInternal(w);
      publicAPI.modified();
    }

    return w;
  };

  function removeWidgetInternal(viewWidget) {
    model._renderer.removeActor(viewWidget);

    viewWidget.delete();
  }

  function onWidgetRemoved() {
    model._renderer.getRenderWindow().getInteractor().render();

    publicAPI.renderWidgets();
  }

  publicAPI.removeWidgets = function () {
    model.widgets.forEach(removeWidgetInternal);
    model.widgets = [];
    model.widgetInFocus = null;
    onWidgetRemoved();
  };

  publicAPI.removeWidget = function (widget) {
    var viewWidget = getViewWidget(widget);
    var index = model.widgets.indexOf(viewWidget);

    if (index !== -1) {
      model.widgets.splice(index, 1);
      var isWidgetInFocus = model.widgetInFocus === viewWidget;

      if (isWidgetInFocus) {
        publicAPI.releaseFocus();
      }

      removeWidgetInternal(viewWidget);
      onWidgetRemoved();
    }
  };

  publicAPI.getSelectedDataForXY = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(x, y) {
      var capturedRegion;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              model.selections = null;

              if (!model.pickingEnabled) {
                _context2.next = 12;
                break;
              }

              if (!(!model._capturedBuffers || model.captureOn === CaptureOn.MOUSE_MOVE)) {
                _context2.next = 7;
                break;
              }

              _context2.next = 5;
              return captureBuffers(x, y, x, y);

            case 5:
              _context2.next = 11;
              break;

            case 7:
              // or do we need a pixel that is outside the last capture?
              capturedRegion = model._capturedBuffers.area;

              if (!(x < capturedRegion[0] || x > capturedRegion[2] || y < capturedRegion[1] || y > capturedRegion[3])) {
                _context2.next = 11;
                break;
              }

              _context2.next = 11;
              return captureBuffers(x, y, x, y);

            case 11:
              model.selections = model._capturedBuffers.generateSelection(x, y, x, y);

            case 12:
              return _context2.abrupt("return", publicAPI.getSelectedData());

            case 13:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x9, _x10) {
      return _ref2.apply(this, arguments);
    };
  }();

  publicAPI.updateSelectionFromXY = function (x, y) {
    vtkWarningMacro('updateSelectionFromXY is deprecated, please use getSelectedDataForXY');

    if (model.pickingEnabled) {
      // Then pick regular representations.
      if (model.captureOn === CaptureOn.MOUSE_MOVE) {
        captureBuffers(x, y, x, y);
      }
    }
  };

  publicAPI.updateSelectionFromMouseEvent = function (event) {
    vtkWarningMacro('updateSelectionFromMouseEvent is deprecated, please use getSelectedDataForXY');
    var pageX = event.pageX,
        pageY = event.pageY;

    var _model$_apiSpecificRe3 = model._apiSpecificRenderWindow.getCanvas().getBoundingClientRect(),
        top = _model$_apiSpecificRe3.top,
        left = _model$_apiSpecificRe3.left,
        height = _model$_apiSpecificRe3.height;

    var x = pageX - left;
    var y = height - (pageY - top);
    publicAPI.updateSelectionFromXY(x, y);
  };

  publicAPI.getSelectedData = function () {
    if (!model.selections || !model.selections.length) {
      model.previousSelectedData = null;
      return {};
    }

    var _model$selections$0$g = model.selections[0].getProperties(),
        propID = _model$selections$0$g.propID,
        compositeID = _model$selections$0$g.compositeID,
        prop = _model$selections$0$g.prop;

    var _model$selections$0$g2 = model.selections[0].getProperties(),
        widget = _model$selections$0$g2.widget,
        representation = _model$selections$0$g2.representation; // widget is undefined for handle representation.


    if (model.previousSelectedData && model.previousSelectedData.prop === prop && model.previousSelectedData.widget === widget && model.previousSelectedData.compositeID === compositeID) {
      model.previousSelectedData.requestCount++;
      return model.previousSelectedData;
    }

    if (propsWeakMap.has(prop)) {
      var props = propsWeakMap.get(prop);
      widget = props.widget;
      representation = props.representation;
    }

    if (widget && representation) {
      var selectedState = representation.getSelectedState(prop, compositeID);
      model.previousSelectedData = {
        requestCount: 0,
        propID: propID,
        compositeID: compositeID,
        prop: prop,
        widget: widget,
        representation: representation,
        selectedState: selectedState
      };
      return model.previousSelectedData;
    }

    model.previousSelectedData = null;
    return {};
  };

  publicAPI.grabFocus = function (widget) {
    var viewWidget = getViewWidget(widget);

    if (model.widgetInFocus && model.widgetInFocus !== viewWidget) {
      model.widgetInFocus.loseFocus();
    }

    model.widgetInFocus = viewWidget;

    if (model.widgetInFocus) {
      model.widgetInFocus.grabFocus();
    }
  };

  publicAPI.releaseFocus = function () {
    return publicAPI.grabFocus(null);
  };

  var superDelete = publicAPI.delete;

  publicAPI.delete = function () {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }

    superDelete();
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  // _camera: null,
  // _selector: null,
  // _currentUpdateSelectionCallID: null,
  viewId: null,
  widgets: [],
  activeWidget: null,
  renderer: null,
  viewType: ViewTypes.DEFAULT,
  isAnimating: false,
  pickingEnabled: true,
  selections: null,
  previousSelectedData: null,
  widgetInFocus: null,
  captureOn: CaptureOn.MOUSE_MOVE
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['captureOn', {
    type: 'enum',
    name: 'viewType',
    enum: ViewTypes
  }]);
  macro.get(publicAPI, model, ['selections', 'widgets', 'viewId', 'pickingEnabled', 'activeWidget']); // Object specific methods

  vtkWidgetManager(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkWidgetManager'); // ----------------------------------------------------------------------------

var vtkWidgetManager$1 = {
  newInstance: newInstance,
  extend: extend,
  Constants: WidgetManagerConst,
  getPixelWorldHeightAtCoord: getPixelWorldHeightAtCoord
};

export { vtkWidgetManager$1 as default, extend, extractRenderingComponents, getPixelWorldHeightAtCoord, newInstance };
