import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import macro from '../../../macros.js';
import Endian from '../../../Common/Core/Endian.js';
import { DataTypeByteSize } from '../../../Common/Core/DataArray/Constants.js';
import { has, registerType } from '../DataAccessHelper.js';

var vtkErrorMacro = macro.vtkErrorMacro,
    vtkDebugMacro = macro.vtkDebugMacro;

var REJECT_COMPRESSION = function REJECT_COMPRESSION() {
  vtkErrorMacro('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.');
  return Promise.reject(new Error('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.'));
};
/* eslint-disable prefer-promise-reject-errors */


var requestCount = 0;

function openAsyncXHR(method, url) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var xhr = new XMLHttpRequest();
  xhr.open(method, url, true);

  if (options.headers) {
    Object.entries(options.headers).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      return xhr.setRequestHeader(key, value);
    });
  }

  if (options.progressCallback) {
    xhr.addEventListener('progress', options.progressCallback);
  }

  return xhr;
}

function fetchBinary(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var xhr = openAsyncXHR('GET', url, options);

    xhr.onreadystatechange = function (e) {
      if (xhr.readyState === 4) {
        if (xhr.status === 200 || xhr.status === 0) {
          resolve(xhr.response);
        } else {
          reject({
            xhr: xhr,
            e: e
          });
        }
      }
    }; // Make request


    xhr.responseType = 'arraybuffer';
    xhr.send();
  });
}

function fetchArray(instance, baseURL, array) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }

  if (array.ref && !array.ref.pending) {
    return new Promise(function (resolve, reject) {
      var url = [baseURL, array.ref.basepath, array.ref.id].join('/');
      var xhr = openAsyncXHR('GET', url, options);

      xhr.onreadystatechange = function (e) {
        if (xhr.readyState === 1) {
          array.ref.pending = true;

          if (++requestCount === 1 && instance !== null && instance !== void 0 && instance.invokeBusy) {
            instance.invokeBusy(true);
          }
        }

        if (xhr.readyState === 4) {
          array.ref.pending = false;

          if (xhr.status === 200 || xhr.status === 0) {
            array.buffer = xhr.response;

            if (array.ref.encode === 'JSON') {
              array.values = JSON.parse(array.buffer);
            } else {
              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
                // Need to swap bytes
                vtkDebugMacro("Swap bytes of ".concat(array.name));
                Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);
              }

              array.values = macro.newTypedArray(array.dataType, array.buffer);
            }

            if (array.values.length !== array.size) {
              vtkErrorMacro("Error in FetchArray: ".concat(array.name, ", does not have the proper array size. Got ").concat(array.values.length, ", instead of ").concat(array.size));
            } // Done with the ref and work


            delete array.ref;

            if (--requestCount === 0 && instance !== null && instance !== void 0 && instance.invokeBusy) {
              instance.invokeBusy(false);
            }

            if (instance !== null && instance !== void 0 && instance.modified) {
              instance.modified();
            }

            resolve(array);
          } else {
            reject({
              xhr: xhr,
              e: e
            });
          }
        }
      }; // Make request


      xhr.responseType = array.dataType !== 'string' ? 'arraybuffer' : 'text';
      xhr.send();
    });
  }

  return Promise.resolve(array);
} // ----------------------------------------------------------------------------


function fetchJSON(instance, url) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }

  return new Promise(function (resolve, reject) {
    var xhr = openAsyncXHR('GET', url, options);

    xhr.onreadystatechange = function (e) {
      if (xhr.readyState === 1) {
        if (++requestCount === 1 && instance !== null && instance !== void 0 && instance.invokeBusy) {
          instance.invokeBusy(true);
        }
      }

      if (xhr.readyState === 4) {
        if (--requestCount === 0 && instance !== null && instance !== void 0 && instance.invokeBusy) {
          instance.invokeBusy(false);
        }

        if (xhr.status === 200 || xhr.status === 0) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject({
            xhr: xhr,
            e: e
          });
        }
      }
    }; // Make request


    xhr.responseType = 'text';
    xhr.send();
  });
} // ----------------------------------------------------------------------------


function fetchText(instance, url) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }

  return new Promise(function (resolve, reject) {
    var xhr = openAsyncXHR('GET', url, options);

    xhr.onreadystatechange = function (e) {
      if (xhr.readyState === 1) {
        if (++requestCount === 1 && instance !== null && instance !== void 0 && instance.invokeBusy) {
          instance.invokeBusy(true);
        }
      }

      if (xhr.readyState === 4) {
        if (--requestCount === 0 && instance !== null && instance !== void 0 && instance.invokeBusy) {
          instance.invokeBusy(false);
        }

        if (xhr.status === 200 || xhr.status === 0) {
          resolve(xhr.responseText);
        } else {
          reject({
            xhr: xhr,
            e: e
          });
        }
      }
    }; // Make request


    xhr.responseType = 'text';
    xhr.send();
  });
} // ----------------------------------------------------------------------------


function fetchImage(instance, url) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return new Promise(function (resolve, reject) {
    var img = new Image();

    if (options.crossOrigin) {
      img.crossOrigin = options.crossOrigin;
    }

    img.onload = function () {
      return resolve(img);
    };

    img.onerror = reject;
    img.src = url;
  });
}
/* eslint-enable prefer-promise-reject-errors */
// ----------------------------------------------------------------------------


var LiteHttpDataAccessHelper = {
  fetchArray: fetchArray,
  fetchJSON: fetchJSON,
  fetchText: fetchText,
  fetchBinary: fetchBinary,
  // Only for HTTP
  fetchImage: fetchImage
}; // The lite version should never override a full feature one...

if (!has('http')) {
  registerType('http', function (options) {
    return LiteHttpDataAccessHelper;
  });
}

export { LiteHttpDataAccessHelper as default };
