{"version":3,"file":"index.module.js","sources":["../src/utils/general.ts","../src/TaskInstance.ts","../src/Task.ts","../src/wrap-utils.ts","../src/utils/ssr-utils.ts","../src/TaskGroup.ts"],"sourcesContent":["import { computed, Ref, watch, reactive } from \"./api\";\nimport useTask, { Task } from \"../Task\";\nimport { TaskInstance } from \"../TaskInstance\";\nimport { AbortSignalWithPromise } from \"../types/index\";\n\nexport function waitForValue<T = any>(cb: () => T): Promise<T> {\n  return new Promise((resolve) => {\n    const stop = watch(cb, value => {\n      if (value !== undefined && value !== null) {\n        resolve(value);\n        stop && stop();\n      }\n    }, { immediate: true });\n  });\n}\n\nexport const reachedMaxConcurrency = (task: Task<any, any>): boolean =>\n  task._runningInstances.length >= task._maxConcurrency;\n\nexport const cancelFirstRunning = (task: Task<any, any>): void => {\n  const firstRunningInstance = task._activeInstances[0];\n  if (firstRunningInstance) {\n    firstRunningInstance.cancel();\n  }\n};\n\nexport const dropEnqueued = (task: Task<any, any>): void => {\n  task._enqueuedInstances.forEach((instance) => {\n    instance.isEnqueued = false;\n    instance.isDropped = true;\n  });\n};\n\ntype BooleanKeys<T> = {\n  [k in keyof T]: T[k] extends boolean ? k : never;\n}[keyof T];\n\nexport function filteredInstances(\n  cb: () => Task<any, any>,\n  key: BooleanKeys<TaskInstance<any>>\n) {\n  if (!key) {\n    return computed(() => []);\n  }\n\n  return computedFilterBy(() => cb()._instances, key);\n}\n\nfunction computedFilterBy<T>(cb: () => T[], key: keyof T, value?: any) {\n  return computed(() => {\n    const collection = cb();\n    return collection.filter((item) => {\n      const curr = item[key];\n      if (value) {\n        return curr === value;\n      }\n\n      return curr;\n    });\n  });\n}\n\nexport function computedLength(cb: () => any[]): Readonly<Ref<number>> {\n  return computed(() => {\n    const arr = cb();\n    return arr.length;\n  });\n}\n\nexport function computedLastOf<T>(cb: () => readonly T[]): Ref<T | undefined> {\n  return computed(() => {\n    const collection = cb();\n    return collection[collection.length - 1];\n  });\n}\n\nexport function computedFirstOf<T>(\n  cb: () => readonly T[]\n): Readonly<Ref<T | undefined>> {\n  return computed(() => {\n    const collection = cb();\n    return collection[0];\n  });\n}\n\nexport type Reactive<T> = {\n  [K in keyof T]: T[K] extends Ref<infer U> ? U : T[K];\n};\n\nexport const _reactiveContent = <T>(obj: T) => {\n  return obj as Reactive<T>;\n};\n\nexport function _reactive<T extends object>(obj: T) {\n  return reactive(obj) as T;\n}\n\nexport type DeferredObject<T> = {\n  promise: Promise<T>;\n  resolve: Function;\n  reject: Function;\n};\nexport function defer<T>(): DeferredObject<T> {\n  const deferredObject: Record<string, any> = {};\n  const promise = new Promise((resolve, reject) => {\n    deferredObject.resolve = resolve;\n    deferredObject.reject = reject;\n  });\n  deferredObject.promise = promise as Promise<T>;\n\n  return deferredObject as DeferredObject<T>;\n}\n\nexport function printTask(task: Task<any, any>) {\n  let taskType = \"General\";\n\n  if (task._isDropping) {\n    taskType = \"Drop\";\n  }\n\n  if (task._isEnqueuing) {\n    taskType = \"Enqueue\";\n  }\n\n  if (task._isRestartable) {\n    taskType = \"Restartable\";\n  }\n\n  if (task._isKeepingLatest) {\n    taskType = \"KeepLatest\";\n  }\n\n  let header = `${taskType} Task`;\n\n  if (taskType !== \"General\") {\n    header = `${header} with maxConcurrency ${task._maxConcurrency}`;\n  }\n\n  const instanceRows = task._instances.map((instance) => {\n    let colorEmoji;\n\n    if (instance.isSuccessful) {\n      colorEmoji = \"ðŸ\";\n    } else if (instance.isRunning || instance.isEnqueued) {\n      colorEmoji = \"ðŸŠ\";\n    } else if (instance.isError || instance.isCanceled || instance.isDropped) {\n      colorEmoji = \"ðŸ”´\";\n    }\n\n    const { status, value, error } = instance;\n    return { status: `${colorEmoji} ${status}`, value, error };\n  });\n\n  console.log(`ðŸš¦ ${header}`);\n  console.table(instanceRows);\n}\n\nexport function timeout(time) {\n  if (process.env.NODE_ENV === \"test\") {\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve) => setTimeout(resolve, time));\n}\n\nexport function getCancelToken<T extends { CancelToken: any }>(\n  axios: T,\n  signal: AbortSignalWithPromise\n) {\n  return new axios.CancelToken((cancel) => {\n    signal.pr.catch((reason) => {\n      if (reason === \"cancel\") {\n        cancel();\n      }\n    });\n  });\n}\n\nexport function useAsyncTask<T, U extends any[]>(\n  fn: (signal: AbortSignalWithPromise, ...params: U) => Promise<T>\n) {\n  return useTask(function* (signal, ...params: U) {\n    return fn(signal, ...params);\n  });\n}\n","\nimport CAF, { cancelToken } from \"caf\";\nimport { computed, EffectScope } from \"./utils/api\";\nimport { _reactive, _reactiveContent, DeferredObject, defer } from \"./utils/general\";\nimport {\n  AbortSignalWithPromise,\n  TaskCb,\n  onFulfilled,\n  onRejected,\n} from \"./types/index\";\n\nexport type TaskInstanceStatus =\n  | \"running\"\n  | \"enqueued\"\n  | \"canceled\"\n  | \"canceling\"\n  | \"dropped\"\n  | \"error\"\n  | \"success\";\nexport interface TaskInstance<T> extends PromiseLike<T> {\n  id: number;\n\n  // Lifecycle\n  hasStarted: boolean;\n  isRunning: boolean;\n  isActive: boolean;\n  isFinished: boolean;\n  isError: boolean;\n  isSuccessful: boolean;\n\n  isCanceling: boolean;\n  isCanceled: boolean;\n\n  isNotDropped: boolean;\n  status: TaskInstanceStatus;\n\n  _run: () => void;\n  cancel: (options?: { force: boolean }) => void;\n  canceledOn: (signal: AbortSignalWithPromise) => TaskInstance<T>;\n  token?: Record<string, any>;\n\n  // Concurrency\n  isDropped: boolean;\n  isEnqueued: boolean;\n\n  // Data State\n  value: T | null;\n  error: any | null;\n\n  // Promise-like stuff\n  _shouldThrow: boolean;\n  _canAbort: boolean;\n  _deferredObject: DeferredObject<T>;\n  _handled: boolean; // this is needed to set to true so that Vue does not show error about unhandled rejection\n  then: (onfulfilled: onFulfilled<T>, onrejected?: onRejected) => Promise<any>;\n  catch: (onrejected?: onRejected) => any;\n  finally: (onfulfilled: () => any) => any;\n}\n\nexport interface ModifierOptions {\n  drop: boolean;\n  enqueue: boolean;\n}\n\nexport interface TaskInstanceOptions {\n  id: number;\n  scope: EffectScope,\n  modifiers: ModifierOptions;\n  onFinish: (taskInstance: TaskInstance<any>) => any;\n}\n\nexport default function createTaskInstance<T>(\n  cb: TaskCb<T, any>,\n  params: any[],\n  options: TaskInstanceOptions\n): TaskInstance<T> {\n  // Initial State\n  const content = _reactiveContent({\n    id: options.id,\n    isDropped: false,\n    isEnqueued: false,\n\n    hasStarted: false,\n    isRunning: false,\n    isFinished: false,\n    isCanceling: false,\n    isCanceled: computed(\n      () => taskInstance.isCanceling && taskInstance.isFinished\n    ),\n    isActive: computed(\n      () => taskInstance.isRunning && !taskInstance.isCanceling\n    ),\n    isSuccessful: false,\n    isNotDropped: computed(() => !taskInstance.isDropped),\n    isError: computed(() => !!taskInstance.error),\n    status: computed(() => {\n      const t = taskInstance;\n      const match = [\n        [t.isRunning, \"running\"],\n        [t.isEnqueued, \"enqueued\"],\n        [t.isCanceled, \"canceled\"],\n        [t.isCanceling, \"canceling\"],\n        [t.isDropped, \"dropped\"],\n        [t.isError, \"error\"],\n        [t.isSuccessful, \"success\"],\n      ].find(([cond]) => cond) as [boolean, TaskInstanceStatus];\n      return match && match[1];\n    }),\n\n    error: null,\n    value: null,\n    cancel({ force } = { force: false }) {\n      if (!force) {\n        taskInstance.isCanceling = true;\n\n        if (taskInstance.isEnqueued) {\n          taskInstance.isFinished = true;\n        }\n\n        taskInstance.isEnqueued = false;\n      }\n\n      if (taskInstance.token && taskInstance._canAbort) {\n        taskInstance.token.abort(\"cancel\");\n        try {\n          taskInstance.token.discard();\n        } catch (e) {\n          // this can cause an error where AbortSignal cannot be changed\n          // perhaps browsers consider it to be immutable\n          // all in all, failed token discard is no big deal, the memory saved is not that big\n        }\n        taskInstance.token = undefined;\n        taskInstance._canAbort = false;\n      }\n    },\n    canceledOn(signal: AbortSignalWithPromise) {\n      signal.pr.catch((e) => {\n        taskInstance.cancel();\n      });\n\n      return taskInstance;\n    },\n    _run() {\n      runTaskInstance(taskInstance, cb, params, options);\n    },\n\n    // PromiseLike things. These are necessary so that TaskInstance is `then`able and can be `await`ed\n\n    // Workaround for Vue not to scream because of unhandled rejection. Task is always \"handled\" because the error is saved to taskInstance.error.\n    _handled: true,\n    _deferredObject: defer<T>(),\n    _shouldThrow: false, // task throws only if it's used promise-like way (then, catch, await)\n    _canAbort: true,\n    then(onFulfilled, onRejected) {\n      taskInstance._shouldThrow = true;\n      return taskInstance._deferredObject.promise.then(onFulfilled, onRejected);\n    },\n    catch(onRejected, shouldThrow = true) {\n      taskInstance._shouldThrow = shouldThrow;\n      return taskInstance._deferredObject.promise.catch(onRejected);\n    },\n    finally(cb) {\n      taskInstance._shouldThrow = true;\n      return taskInstance._deferredObject.promise.finally(cb);\n    },\n  });\n\n  // Create\n  const taskInstance = _reactive(content) as TaskInstance<T>;\n\n  // Process = drop, enqueue or run right away!\n  const { modifiers } = options;\n  if (modifiers.drop) {\n    taskInstance.isDropped = true;\n  } else if (modifiers.enqueue) {\n    taskInstance.isEnqueued = true;\n  } else {\n    taskInstance._run();\n  }\n\n  return taskInstance;\n}\n\nfunction runTaskInstance<T>(\n  taskInstance: TaskInstance<any>,\n  cb: TaskCb<T, any>,\n  params: any[],\n  options: TaskInstanceOptions\n): void {\n  // because not all environemnts support package.exports field (TS, WP4 and others), it's necessary to look for CAF function in two places\n  const token = new cancelToken();\n  const cancelable = CAF(cb, token);\n  taskInstance.token = token;\n\n  taskInstance.hasStarted = true;\n  taskInstance.isRunning = true;\n  taskInstance.isEnqueued = false;\n\n  function setFinished() {\n    taskInstance.isRunning = false;\n    taskInstance.isFinished = true;\n  }\n\n  cancelable\n    .call(taskInstance, token, ...params)\n    .then((value) => {\n      taskInstance.value = value;\n      taskInstance.isSuccessful = true;\n\n      setFinished();\n      taskInstance._deferredObject.resolve(value);\n      taskInstance._canAbort = false;\n      options.onFinish(taskInstance);\n    })\n    .catch((e) => {\n      if (e !== \"cancel\") {\n        taskInstance.error = e;\n      }\n\n      setFinished();\n      if (taskInstance._shouldThrow) {\n        taskInstance._deferredObject.reject(e);\n      }\n      options.onFinish(taskInstance);\n    });\n}\n","import { computed, onBeforeUnmount, getCurrentInstance, effectScope, EffectScope } from \"./utils/api\";\nimport createTaskInstance, {\n  TaskInstance,\n  ModifierOptions,\n} from \"./TaskInstance\";\nimport {\n  reachedMaxConcurrency,\n  cancelFirstRunning,\n  filteredInstances,\n  computedLength,\n  computedLastOf,\n  computedFirstOf,\n  _reactive,\n  _reactiveContent,\n  dropEnqueued,\n} from \"./utils/general\";\nimport { Resolved, TaskCb } from \"./types/index\";\n\nexport type Task<T, U extends any[]> = {\n  // Lifecycle state\n  isIdle: boolean;\n  isRunning: boolean;\n  isError: boolean;\n  performCount: number;\n\n  // Shortcuts to useful instances\n  last: TaskInstance<T> | undefined;\n  lastSuccessful: TaskInstance<T> | undefined;\n  firstEnqueued: TaskInstance<T> | undefined;\n\n  // Action Methods\n  cancelAll: (options?: { force: boolean }) => void;\n  perform: (...params: U) => TaskInstance<T>;\n  clear: () => void;\n  destroy: () => void;\n\n  // Modifiers\n  restartable: () => Task<T, U>;\n  drop: () => Task<T, U>;\n  enqueue: () => Task<T, U>;\n  keepLatest: () => Task<T, U>;\n  maxConcurrency: (number) => Task<T, U>;\n  _resetModifierFlags: () => void;\n\n  // Modifier flags\n  _maxConcurrency: number;\n  _isRestartable: boolean;\n  _isEnqueuing: boolean;\n  _isDropping: boolean;\n  _isKeepingLatest: boolean;\n\n  _hasConcurrency: boolean;\n\n  // Instances\n  _instances: TaskInstance<T>[];\n  _successfulInstances: readonly TaskInstance<T>[];\n  _runningInstances: readonly TaskInstance<T>[];\n  _activeInstances: readonly TaskInstance<T>[];\n  _enqueuedInstances: readonly TaskInstance<T>[];\n  _notDroppedInstances: readonly TaskInstance<T>[];\n};\n\nexport default function useTask<T, U extends any[]>(\n  cb: TaskCb<T, U>,\n  options = { cancelOnUnmount: true }\n): Task<Resolved<T>, U> {\n  const vm = getCurrentInstance();\n  const scope = effectScope();\n  const content = _reactiveContent({\n    _isRestartable: false,\n    _isDropping: false,\n    _isEnqueuing: false,\n    _isKeepingLatest: false,\n    _maxConcurrency: 1, // this is used only when concurrency modifier is active (otherwise it has no effect)\n    _hasConcurrency: computed(\n      () =>\n        task._isRestartable ||\n        task._isDropping ||\n        task._isEnqueuing ||\n        task._isKeepingLatest\n    ),\n\n    isIdle: computed(() => !task.isRunning),\n    isRunning: computed(\n      () => !!task._instances.find((instance) => instance.isRunning)\n    ),\n    isError: computed(() => !!(task.last && task.last.isError)),\n\n    _instances: [],\n    // TODO: the filter + lastOf combo is concise and clear, but more efficient would be classic loop and iterating from the end (findLastIf macro)\n    _successfulInstances: filteredInstances(() => task, \"isSuccessful\"),\n    _runningInstances: filteredInstances(() => task, \"isRunning\"),\n    _enqueuedInstances: filteredInstances(() => task, \"isEnqueued\"),\n    _notDroppedInstances: filteredInstances(() => task, \"isNotDropped\"),\n    _activeInstances: filteredInstances(() => task, \"isActive\"),\n    performCount: computedLength(() => task._instances),\n    last: computedLastOf(() => task._notDroppedInstances),\n    lastSuccessful: computedLastOf(() => task._successfulInstances),\n    firstEnqueued: computedFirstOf(() => task._enqueuedInstances),\n\n    cancelAll({ force } = { force: false }) {\n      // Cancel all running and enqueued instances. Finished and dropped instances can't really be canceled.\n      task._instances.forEach(\n        (taskInstance) => {\n          try {\n            if (force || !taskInstance.isDropped && !taskInstance.isFinished) {\n              taskInstance.cancel({ force });\n            }\n          } catch (e) {\n            if (e !== \"cancel\") {\n              throw e;\n            }\n          }\n        }\n      );\n    },\n\n    perform(...params) {\n      const modifiers: ModifierOptions = {\n        enqueue: false,\n        drop: false,\n      };\n\n      if (task._hasConcurrency && reachedMaxConcurrency(task)) {\n        if (task._isDropping) {\n          modifiers.drop = true;\n        }\n\n        if (task._isRestartable) {\n          cancelFirstRunning(task);\n        }\n\n        if (task._isKeepingLatest) {\n          dropEnqueued(task);\n        }\n\n        if (task._isEnqueuing || task._isKeepingLatest) {\n          modifiers.enqueue = true;\n        }\n      }\n\n      const onFinish = () => onTaskInstanceFinish(task);\n      const create = () => createTaskInstance<T>(cb, params, {\n        modifiers,\n        onFinish,\n        scope: scope,\n        id: task._instances.length + 1,\n      });\n      // @ts-expect-error property is not exposed on types in Vue 2.7\n      const newInstance = scope.active ? scope.run(create) : create();\n      // @ts-expect-error\n      if (!scope.active) {\n        console.warn('Task instance has been created in inactive scope. Perhaps youre creating task out of setup?');\n      }\n      \n      task._instances = [...task._instances, newInstance as TaskInstance<T>];\n\n      return newInstance;\n    },\n\n    clear() {\n      this.cancelAll({ force: true });\n      this._instances = [];\n    },\n\n    destroy() {\n      scope.stop();\n      this.clear();\n    },\n\n    restartable() {\n      task._resetModifierFlags();\n      task._isRestartable = true;\n      return task;\n    },\n\n    drop() {\n      task._resetModifierFlags();\n      task._isDropping = true;\n      return task;\n    },\n\n    enqueue() {\n      task._resetModifierFlags();\n      task._isEnqueuing = true;\n      return task;\n    },\n\n    keepLatest() {\n      task._resetModifierFlags();\n      task._isKeepingLatest = true;\n      return task;\n    },\n\n    _resetModifierFlags() {\n      task._isKeepingLatest = false;\n      task._isRestartable = false;\n      task._isEnqueuing = false;\n      task._isDropping = false;\n    },\n\n    maxConcurrency(number) {\n      task._maxConcurrency = number;\n      return task;\n    },\n  });\n  const task = _reactive(content) as Task<T, U>;\n\n  if (vm && options.cancelOnUnmount) {\n    onBeforeUnmount(() => {\n      // check if there's instances still, Vue 3 might have done some cleanup already\n      if (task._instances) {\n        // cancelAll with force is more performant is theres less need for checks\n        task.destroy();\n      }\n    });\n  }\n\n  return task as Task<Resolved<T>, U>;\n}\n\nfunction onTaskInstanceFinish(task: Task<any, any>): void {\n  if (task._isEnqueuing || task._isKeepingLatest) {\n    const { firstEnqueued } = task;\n    if (firstEnqueued) {\n      firstEnqueued._run();\n    }\n  }\n}\n","import useTask, { Task } from \"./Task\";\n\nexport function usePipeTask<T, U extends any[]>(\n  firstTask: Task<any, U>,\n  ...restTasks: Task<any, any>[]\n): Task<T, U> {\n  return useTask(function*(signal, ...args: U) {\n    let result = yield firstTask.perform(...args).canceledOn(signal);\n    for (let task of restTasks) {\n      result = yield task.perform(result).canceledOn(signal);\n    }\n\n    return result;\n  });\n}\n\nexport function useParallelTask(...tasks: Task<any, any>[]): Task<any[], any> {\n  return useTask(function*(signal, ...args) {\n    const instances = tasks.map((task) => {\n      return task.perform(...args).canceledOn(signal);\n    });\n\n    const values = yield Promise.all(instances);\n    return values as any[];\n  });\n}\n\nexport function useSequentialTask<U extends any[]>(\n  ...tasks: Task<any, any>[]\n): Task<any, U> {\n  return useTask(function*(signal, ...args: U) {\n    const instances: any[] = [];\n    for (let task of tasks) {\n      instances.push((yield task.perform(...args).canceledOn(signal)) as any);\n    }\n\n    return instances;\n  });\n}\n","import {\n  onServerPrefetch,\n  getCurrentInstance,\n  computed,\n} from \"./api\";\nimport { TaskInstance } from \"../TaskInstance\";\nimport { Task } from \"../Task\";\n\nconst isServer = () => typeof window === \"undefined\";\n\nexport function reviveTaskInstance(instance: TaskInstance<any>) {\n  if (instance.isError) {\n    instance._deferredObject.promise = Promise.reject(instance.error);\n  } else {\n    instance._deferredObject.promise = Promise.resolve(instance.value);\n  }\n\n  instance.cancel = () => { };\n  instance.canceledOn = () => instance;\n  instance._run = () => { };\n  instance.then = (...params) =>\n    instance._deferredObject.promise.then(...params);\n  instance.catch = (...params) =>\n    instance._deferredObject.promise.catch(...params);\n  instance.finally = (...params) =>\n    instance._deferredObject.promise.finally(...params);\n}\n\nexport function useTaskPrefetch<T>(\n  key: string,\n  task: Task<T, any>\n): TaskInstance<T> {\n  /* Server */\n  if (isServer()) {\n    // perform, add to prefetch, add to ssrContext\n    const taskInstance = task.perform();\n    onServerPrefetch(async () => {\n      try {\n        await taskInstance;\n        saveTaskToNuxtState(key, task);\n      } catch (e) {\n        // no need for extra handling\n      }\n    });\n    return taskInstance;\n  }\n\n  /* Client */\n  const [last] = reviveTaskInstances(key, task).reverse();\n\n  if (last) {\n    return last;\n  } else {\n    return task.perform();\n  }\n}\n\nfunction saveTaskToNuxtState(key: string, task: Task<any, any>) {\n  const { $root } = getCurrentInstance() as any;\n  const nuxtState = $root && $root.context && $root.context.nuxtState;\n  if (!nuxtState) {\n    throw new Error(\"Could not access $root.context.nuxtState\");\n  }\n\n  if (!nuxtState.vueConcurrency) {\n    nuxtState.vueConcurrency = {};\n  }\n\n  nuxtState.vueConcurrency[key] = computed(() => ({\n    instances: task._instances,\n  }));\n}\n\nfunction reviveTaskInstances(key: string, task: Task<any, any>) {\n  const taskCache = getTaskFromContext(key);\n  if (taskCache) {\n    task._instances = taskCache.instances || [];\n    task._instances.forEach(reviveTaskInstance);\n    deleteTaskCache(key);\n  }\n\n  return task._instances;\n}\n\nfunction getNuxtData() {\n  return (window as any).__NUXT__;\n}\n\nfunction getTaskFromContext(key) {\n  if (!getNuxtData()) {\n    throw Error(`Could not access  window.__NUXT__`);\n  }\n\n  return getNuxtData().vueConcurrency[key].value;\n}\n\nfunction deleteTaskCache(key) {\n  const nuxtData = getNuxtData();\n  delete nuxtData.vueConcurrency[key];\n}\n\nexport function useSSRPersistance(key: string, task: Task<any, any>) {\n  if (isServer()) {\n    saveTaskToNuxtState(key, task);\n    return;\n  }\n\n  reviveTaskInstances(key, task);\n}\n","import { Task } from \"./Task\";\nimport { reactive, computed } from \"./utils/api\";\n\nexport interface TaskState {\n  isRunning: boolean;\n  isIdle: boolean;\n}\n\nexport type TaskGroup<U extends Record<string, Task<any, any>>> = TaskState & U;\n\nexport default function useTaskGroup<U extends Record<string, Task<any, any>>>(\n  taskMap: U\n): TaskGroup<U> {\n  const taskArray = Object.values(taskMap);\n  const taskGroup = reactive({\n    isRunning: computed(() => !!taskArray.find((task) => task.isRunning)),\n    isIdle: computed(() => !taskGroup.isRunning),\n    isError: computed(() => !!taskArray.find((task) => task.isError)),\n    ...taskMap,\n  });\n\n  return taskGroup;\n}\n"],"names":["waitForValue","cb","Promise","resolve","stop","watch","value","immediate","reachedMaxConcurrency","task","_runningInstances","length","_maxConcurrency","cancelFirstRunning","firstRunningInstance","_activeInstances","cancel","_enqueuedInstances","forEach","instance","isEnqueued","isDropped","filteredInstances","key","computed","filter","item","computedFilterBy","_instances","computedLastOf","collection","computedFirstOf","_reactive","obj","reactive","printTask","_isDropping","taskType","_isEnqueuing","_isRestartable","_isKeepingLatest","header","instanceRows","map","colorEmoji","isSuccessful","isRunning","isError","isCanceled","status","error","console","log","table","timeout","time","process","env","NODE_ENV","setTimeout","axios","signal","CancelToken","pr","reason","useAsyncTask","fn","useTask","_regeneratorRuntime","mark","_callee","concat","slice","call","_args","createTaskInstance","params","options","deferredObject","content","id","hasStarted","isFinished","isCanceling","taskInstance","isActive","isNotDropped","find","_ref","match","_temp","force","token","_canAbort","abort","discard","e","undefined","canceledOn","_run","cancelToken","cancelable","CAF","setFinished","apply","then","_deferredObject","onFinish","_shouldThrow","reject","runTaskInstance","_handled","promise","onFulfilled","onRejected","shouldThrow","modifiers","drop","enqueue","cancelOnUnmount","getCurrentInstance","effectScope","_hasConcurrency","isIdle","last","_successfulInstances","_notDroppedInstances","performCount","computedLength","lastSuccessful","firstEnqueued","cancelAll","perform","_arguments","arguments","dropEnqueued","onTaskInstanceFinish","create","scope","active","run","warn","newInstance","clear","this","destroy","restartable","_resetModifierFlags","keepLatest","maxConcurrency","number","vm","onBeforeUnmount","usePipeTask","firstTask","restTasks","result","_iterator","_step","wrap","_context","prev","next","done","useParallelTask","tasks","instances","_context2","all","values","_callee2","useSequentialTask","_iterator2","_createForOfIteratorHelperLoose","_step2","_context3","push","isServer","window","_instance$_deferredOb","_instance$_deferredOb2","_instance$_deferredOb3","useTaskPrefetch","onServerPrefetch","_temp2","saveTaskToNuxtState","_catch","reviveTaskInstances","reverse","$root","nuxtState","context","vueConcurrency","taskCache","getNuxtData","Error","getTaskFromContext","reviveTaskInstance","deleteTaskCache","__NUXT__","useSSRPersistance","useTaskGroup","taskMap","taskArray","Object","taskGroup"],"mappings":"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"}