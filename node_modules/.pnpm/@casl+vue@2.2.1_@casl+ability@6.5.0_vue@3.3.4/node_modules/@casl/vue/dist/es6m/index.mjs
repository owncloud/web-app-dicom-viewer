import{ref as t,inject as i,provide as n,defineComponent as r}from"vue";import{PureAbility as o}from"@casl/ability";function reactiveAbility(i){if(i.hasOwnProperty("possibleRulesFor"))return i;const n=t(true);i.on("updated",(()=>{n.value=!n.value}));const r=i.possibleRulesFor.bind(i);i.possibleRulesFor=(t,i)=>{n.value=n.value;return r(t,i)};i.can=i.can.bind(i);i.cannot=i.cannot.bind(i);return i}const e=Symbol("ability");function useAbility(){const t=i(e);if(!t)throw new Error("Cannot inject Ability instance because it was not provided");return t}function provideAbility(t){n(e,reactiveAbility(t))}function s(t){if(void 0!==t.a)return"a";if(void 0!==t.this)return"this";if(void 0!==t.an)return"an";return""}const u=r({name:"Can",props:{I:String,do:String,a:[String,Function],an:[String,Function],this:[String,Function,Object],on:[String,Function,Object],not:Boolean,passThrough:Boolean,field:String},setup(t,{slots:i}){const n=t;let r="do";let o="on";if(void 0===n[r]){r="I";o=s(t)}if(!n[r])throw new Error("Neither `I` nor `do` prop was passed in <Can>");if(!i.default)throw new Error("Expects to receive default slot");const e=useAbility();return()=>{const s=e.can(n[r],n[o],n.field);const u=t.not?!s:s;if(!t.passThrough)return u?i.default():null;return i.default({allowed:u,ability:e})}}});function l(t,i,n){if(!i||!(i instanceof o))throw new Error("Please provide an Ability instance to abilitiesPlugin plugin");t.provide(e,reactiveAbility(i));if(n&&n.useGlobalProperties){t.config.globalProperties.$ability=i;t.config.globalProperties.$can=i.can.bind(i)}}export{e as ABILITY_TOKEN,u as Can,l as abilitiesPlugin,provideAbility,useAbility};
//# sourceMappingURL=index.mjs.map
